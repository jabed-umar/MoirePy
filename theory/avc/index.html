<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://jabed-umar.github.io/MoirePy/theory/avc/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Angle Value Calculator - MoirePy – Python Library for Moiré Lattice Simulation</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../assets/_mkdocstrings.css" rel="stylesheet" />
        <link href="../../assets/style.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Angle Value Calculator";
        var mkdocs_page_input_path = "theory/avc.md";
        var mkdocs_page_url = "/MoirePy/theory/avc/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> MoirePy – Python Library for Moiré Lattice Simulation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Getting Started</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting_started/gs_intro/">Getting Started</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting_started/installation/">Installation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting_started/prepare_layers/">Prepare Layers</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting_started/moire_lattice_and_hamiltonian/">Moiré Lattice and Hamiltonian</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../examples/">EXAMPLE NOTEBOOKS</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Theoretical Background</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../theory_intro/">Theoretical Background</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tight_binding_ham/">Tight Binding Moiré Hamiltonian</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../search_algorithm_kdtree/">Searching Algorithm & KDTree</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../angle_calculation_process/">Angle Calculation Process</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Angle Value Calculator</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#calculator">Calculator</a>
    </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">API Reference</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../api/layers/">Layers</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../api/moire/">Moire</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../api/utils/">Utils</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">MoirePy – Python Library for Moiré Lattice Simulation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Theoretical Background</li>
      <li class="breadcrumb-item active">Angle Value Calculator</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/jabed-umar/MoirePy/edit/master/docs/theory/avc.md">Edit on jabed-umar/MoirePy</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <style>
    .input-form {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-bottom: 20px;
    }

    input,
    select,
    button {
        font-size: 16px;
        padding: 5px;
    }

    button {
        cursor: pointer;
        background-color: rgb(41, 128, 185);
        color: white;
        border: none;
        padding: 10px;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
    }

    th,
    td {
        padding: 8px;
        text-align: center;
        border: 1px solid #ddd;
    }

    thead {
        background-color: #f2f2f2;
    }

    .hidden {
        display: none;
    }

    .vector-inputs input {
        width: 80px;
        margin: 5px;
    }

    #end, #start {
        border: 1px solid #000;
        border-radius: 5px;
        padding: 8px;
        width: 100px;
        font-size: 16px;
    }
    .section{
        text-align: justify;
    }
</style>

<h1 id="angle-value-calculator">Angle Value Calculator</h1>
<p>The <strong>Moiré Angle Calculator</strong> finds all possible commensurate angles between two stacked lattices by trimming both layers within a given radius and checking for periodic overlaps following the <a href="../angle_calculation_process/">Angle Calculation Process</a>. After calculation, it provides a list of angles with their corresponding <code>ll1</code>, <code>ll2</code>, <code>ul1</code>, <code>ul2</code> values that define the rotation between the two lattices along with the number of points in each cell of the Moiré lattice. Since most angles are irrational and can't be precisely represented, the rotation is defined using these coordinate pairs instead — they mark the overlapping points between the two lattices. Once you've selected an angle from the list, just copy the <code>ll1</code>, <code>ll2</code>, <code>ul1</code>, and <code>ul2</code> values into your code — the system will figure out the exact rotation angle from that. This also makes it easy to calculate the moire lattice vectors.</p>
<details class="warning">
<summary>Some Guidelines</summary>
<p>A <strong>radius</strong> must be specified to define the extent of the circular region centred at the origin. This value is used to truncate <em>both</em> the upper and lower lattices. <strong>Larger radius</strong> Includes more lattice points, potentially giving more precise calculations and revealing smaller angles, <strong>but</strong> increases computation time. <strong>Smaller radius</strong> Produces faster results, yet may detect only larger angle values.</p>
<p><strong>Currently supported systems:</strong></p>
<ul>
<li>Both layers <strong>60<span class="arithmatex">\(^\circ\)</span></strong> (Triangular, Hexagonal and Kagome lattices)</li>
<li>Both layers <strong>90<span class="arithmatex">\(^\circ\)</span></strong> (Square lattice)</li>
<li>
<p><strong>Custom mode</strong> – <em>experimental</em>  </p>
<p><em>Possible problems</em><br />
- Erroneous or nonsensical output<br />
- Unresponsiveness or infinite loops<br />
- Unexpected program behaviour  </p>
<p>Proceed only if you believe the results yielded by the <a href="../angle_calculation_process">Angle Calculation Process</a> are correct and meaningful for your custom lattice vectors.</p>
</li>
</ul>
<p><strong>Larger Value of points per cell</strong> More points per cell in the lattice means larger hamiltonian matrix, which can lead to longer computation times and higher memory usage. Especially if planning to invert the hamiltonian matrix and find eigenvalues and eigenvectors later.</p>
<p><strong>Number of Points</strong> has been calculated assuming only one point per unit cell. If you are using lattices which have multiple points per unit cell like hexagonal (2) or kagome (3), multiply this value by the number of points per unit cell in your lattice to get the actual number of points in the Moiré lattice.</p>
<p><strong>Precision</strong> has <strong>NO effect on the calculation</strong>. It only affects the output format of the results. (In the calculation, we stick to integer values to avoid floating point errors).</p>
</details>
<h2 id="calculator">Calculator</h2>
<div class="input-form">
    <div style="display: flex; gap: 10px; align-items: center;">
        <label for="radius">Radius:</label>
        <input type="number" id="radius" value="20" style="width: 30vw;" step="any" min="0">
    </div>

    <label for="latticeType">Lattice Type:</label>
    <select id="latticeType" onchange="updateLatticeVectors()">
        <option value="TriangularLayer">both layers 60 degree (Triangular, Hexagonal and Kagome lattice)</option>
        <option value="SquareLayer">both layers 90 degree (Square lattice)</option>
        <option value="Custom">Custom (experimental)</option>
    </select>

    <div id="custom-vectors" class="vector-inputs hidden">
        <label>Lattice Vectors for Layer 1:</label>
        <div>
            lv1: <input type="text" inputmode="decimal" id="layer1-lv1x"> x +
            <input type="text" inputmode="decimal" id="layer1-lv1y"> y
        </div>
        <div>
            lv2: <input type="text" inputmode="decimal" id="layer1-lv2x"> x +
            <input type="text" inputmode="decimal" id="layer1-lv2y"> y
        </div>

        <label>Lattice Vectors for Layer 2:</label>
        <div>
            lv1: <input type="text" inputmode="decimal" id="layer2-lv1x"> x +
            <input type="text" inputmode="decimal" id="layer2-lv1y"> y
        </div>
        <div>
            lv2: <input type="text" inputmode="decimal" id="layer2-lv2x"> x +
            <input type="text" inputmode="decimal" id="layer2-lv2y"> y
        </div>
        <div style="color: red; border: 1px solid red; padding: 5px; text-align: center;"><b>WARNING:</b> RESULTS MIGHT BE MEANINGLESS OR INACCURATE</div>
    </div>

    <div style="display: flex; gap: 10px; align-items: center;">
        <label for="precision">Precision:</label>
        <input type="range" id="precision" min="2" max="12" value="6" step="1" style="width: 30vw;">
        <span id="precision-value">6</span>
    </div>   

    <button onclick="calculate()">CALCULATE</button>
</div>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The last column (number of points per unit cell in the Moiré lattice) has been calculated assuming only one point per unit cell. If you are using lattices which have multiple points per unit cell like hexagonal (2) or kagome (3), multiply this value by the number of points per unit cell in your lattice to get the actual number of points in the Moiré lattice.</p>
</div>
<table id="results-table">
    <thead>
        <tr>
            <th></th>
            <th>angle (deg)</th>
            <th>angle (rad)</th>
            <th>ll1</th>
            <th>ll2</th>
            <th>ul1</th>
            <th>ul2</th>
            <th>points/cell</th>
        </tr>
    </thead>
    <tbody id="results-body">
        <!-- Generated results will be displayed here -->
    </tbody>
</table>
</div>
<!-- <script src="assets/script_find_theta.js"></script> -->

<script>

    let root3 = Math.sqrt(3);

    const latticeDefaults = {
        HexagonalLayer: [1, 0, 0.5, root3 / 2],
        SquareLayer: [1, 0, 0, 1],
        RhombusLayer: [1, 0, 0.5, root3 / 2],
        TriangularLayer: [1, 0, 0.5, root3 / 2],
        KagomeLayer: [1, 0, 0.5, root3 / 2],
    };

    document.getElementById("precision").addEventListener("input", function() {
        document.getElementById("precision-value").textContent = this.value;
    });

    function updateLatticeVectors() {
        const type = document.getElementById("latticeType").value;
        const customDiv = document.getElementById("custom-vectors");

        if (type === "Custom") {
            customDiv.classList.remove("hidden");
        } else {
            customDiv.classList.add("hidden");

            const vec = latticeDefaults[type] || [1, 1, 1, 1];

            // Set both layers with the same vectors
            document.getElementById("layer1-lv1x").value = vec[0];
            document.getElementById("layer1-lv1y").value = vec[1];
            document.getElementById("layer1-lv2x").value = vec[2];
            document.getElementById("layer1-lv2y").value = vec[3];

            document.getElementById("layer2-lv1x").value = vec[0];
            document.getElementById("layer2-lv1y").value = vec[1];
            document.getElementById("layer2-lv2x").value = vec[2];
            document.getElementById("layer2-lv2y").value = vec[3];
        }
    }

    function gcd(x, y) {
        if (y === 0) return x;
        else return gcd(y, x % y);
    }

    function angleId(p1, p2) {
        // Dot product
        const dot = p1[0] * p2[0] + p1[1] * p2[1];
        const dotSq = dot * dot;

        // Norms squared
        const norm1Sq = p1[0] ** 2 + p1[1] ** 2;
        const norm2Sq = p2[0] ** 2 + p2[1] ** 2;
        const denom = norm1Sq * norm2Sq;

        // Reduce the fraction dotSq / denom
        const commonDivisor = gcd(dotSq, denom);
        const num = dotSq / commonDivisor;
        const den = denom / commonDivisor;

        // Return as a string ID
        return `${num}/${den}`;
    }

    function calculate() {
        const radius = parseInt(document.getElementById("radius").value);

        const layer1Vectors = [
            parseFloat(document.getElementById("layer1-lv1x").value),
            parseFloat(document.getElementById("layer1-lv1y").value),
            parseFloat(document.getElementById("layer1-lv2x").value),
            parseFloat(document.getElementById("layer1-lv2y").value)
        ];

        const layer2Vectors = [
            parseFloat(document.getElementById("layer2-lv1x").value),
            parseFloat(document.getElementById("layer2-lv1y").value),
            parseFloat(document.getElementById("layer2-lv2x").value),
            parseFloat(document.getElementById("layer2-lv2y").value)
        ];

        const precision = parseInt(document.getElementById("precision").value);

        // console.log(radius, layer1Vectors, layer2Vectors);

        const results = find_values(radius, layer1Vectors, layer2Vectors, tol=precision);

        console.log(results);
        console.log("Number of results:", results.length);
        displayResults_(results);
    }

    function calc_indices(p, lv1, lv2) {
        const [a, b] = lv1;
        const [c, d] = lv2;
        const [x, y] = p;
        const det = (a * d - b * c);
        const nx = (d * x - c * y) / det;
        const ny = (a * y - b * x) / det;

        if (Math.abs(Math.round(nx) - nx) > 1e-5 || Math.abs(Math.round(ny) - ny) > 1e-5) {
            throw new Error(`Calculation error for indices: ${nx}, ${ny}`);
        }

        return [Math.round(nx), Math.round(ny)];
    }

    function generate_lattice_points(lv1, lv2, radius) {
        const points = [];
        const maxGridSize = Math.floor(radius / Math.abs(lv2[1])) + 5;

        // console.log(radius, lv1, lv2, maxGridSize);

        for (let i = -maxGridSize; i <= maxGridSize; i++) {
            for (let j = -maxGridSize; j <= maxGridSize; j++) {
                // console.log(i, j);
                const point = [i * lv1[0] + j * lv2[0], i * lv1[1] + j * lv2[1]];
                const dist = Math.sqrt(point[0] ** 2 + point[1] ** 2);
                if (dist <= radius) points.push(point);
            }
        }

        return points;
    }

    function angle_from_x(p) {
        return Math.atan2(p[1], p[0]) * 180 / Math.PI;
    }

    function process_lattice(points, tol) {
        const distances = points.map(p => Math.hypot(p[0], p[1]));
        const distMap = new Map();

        // console.log(distMap);

        for (let i = 0; i < points.length; i++) {
            const d = parseFloat(distances[i].toFixed(tol));
            if (!distMap.has(d)) distMap.set(d, {});
            distMap.get(d)[i] = points[i];
        }

        return [distMap, new Set([...distMap.keys()])];
    }

    function find_values(radius, layer1Vectors, layer2Vectors, tol = 6) {

        const [a1x, a1y, b1x, b1y] = layer1Vectors;
        const [a2x, a2y, b2x, b2y] = layer2Vectors;

        if (JSON.stringify(layer1Vectors) !== JSON.stringify(layer2Vectors)) {
            alert("Warning: Vectors are not identical! Results might be inaccurate or meaningless.");
        }

        const lv1 = [a1x, a1y];
        const lv2 = [b1x, b1y];

        const lattice1 = generate_lattice_points(lv1, lv2, radius);
        const lattice2 = generate_lattice_points(lv1, lv2, radius);

        const [dict1, dist_set1] = process_lattice(lattice1, tol);
        const [dict2, dist_set2] = process_lattice(lattice2, tol);

        const common_dists = [...dist_set1].filter(d => dist_set2.has(d)).sort((a, b) => a - b).slice(1);

        const angle_dict = {};
        const lattice_angle = angle_from_x(lv2) - angle_from_x(lv1);

        const isValidTheta = (theta) => theta > 0 && theta < lattice_angle;

        for (const d of common_dists) {
            // console.log(d)
            const pts1 = Object.values(dict1.get(d)).filter(p => isValidTheta(angle_from_x(p)));
            const pts2 = Object.values(dict2.get(d)).filter(p => isValidTheta(angle_from_x(p)));

            for (const p1 of pts1) {
                const theta1 = parseFloat(angle_from_x(p1).toFixed(tol));

                for (const p2 of pts2) {
                    const theta2 = parseFloat(angle_from_x(p2));
                    const angle = parseFloat((theta2 - theta1));
                    // use cos theta square between p1 and p2 as uid
                    const uid = angleId(p1, p2);

                    if (
                        theta2 <= theta1 ||
                        angle < Math.pow(10, -tol) ||
                        uid in angle_dict
                    ) continue;

                    angle_dict[uid] = [p1, p2, angle];
                }
            }
        }

        const results = Object.entries(angle_dict)
        .sort(([, a], [, b]) => parseFloat(a[2]) - parseFloat(b[2]))  // ascending by angle
        .map(([k, [p1, p2, angle]]) => {
            const thetaRad = (parseFloat(angle) * Math.PI) / 180;
            const thetaDeg = parseFloat(angle);
            const [i1, j1] = calc_indices(p1, lv1, lv2);
            const [i2, j2] = calc_indices(p2, lv1, lv2);
            const num_pts =   2*(p1[0] * p1[0] + p1[1] * p1[1]) * 1;  // 1 for one point per unit cell
            return [thetaDeg.toFixed(tol), thetaRad.toFixed(tol), i2, j2, i1, j1, num_pts];
        });

        return results;
    }

    function displayResults_(results) {
        const resultsBody = document.getElementById("results-body");
        resultsBody.innerHTML = ""; // Clear previous results
        results.forEach((tuple, index) => {
            const row = document.createElement("tr");
            const cell = document.createElement("td");
            cell.textContent = index + 1;  // add the index
            row.appendChild(cell);
            tuple.forEach(value => {
                const cell = document.createElement("td");
                cell.textContent = value;
                row.appendChild(cell);
            });
            resultsBody.appendChild(row);
        });
    }

    updateLatticeVectors('layer1');
    updateLatticeVectors('layer2');

</script>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../angle_calculation_process/" class="btn btn-neutral float-left" title="Angle Calculation Process"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../api/layers/" class="btn btn-neutral float-right" title="Layers">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/jabed-umar/MoirePy" class="fa fa-code-fork" style="color: #fcfcfc"> jabed-umar/MoirePy</a>
        </span>
    
    
      <span><a href="../angle_calculation_process/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../api/layers/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
