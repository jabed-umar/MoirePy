{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MoirePy: Twist It, Solve It, Own It! MoirePy is a Python package for the analysis of moir\u00e9 lattice. It is designed to be a user-friendly tool for studying bilayer moir\u00e9 lattices. License This project is licensed under the MIT License . Cite This Work If you use this software or a modified version in academic or scientific research, please cite: @misc{MoirePy2025, author = {Aritra Mukhopadhyay, Jabed Umar}, title = {MoirePy: Python package for efficient tight binding simulation of bilayer moir\u00e9 lattices}, year = {2025}, url = {https://jabed-umar.github.io/MoirePy/}, }","title":"Home"},{"location":"#moirepy-twist-it-solve-it-own-it","text":"MoirePy is a Python package for the analysis of moir\u00e9 lattice. It is designed to be a user-friendly tool for studying bilayer moir\u00e9 lattices.","title":"MoirePy: Twist It, Solve It, Own It!"},{"location":"#license","text":"This project is licensed under the MIT License .","title":"License"},{"location":"#cite-this-work","text":"If you use this software or a modified version in academic or scientific research, please cite: @misc{MoirePy2025, author = {Aritra Mukhopadhyay, Jabed Umar}, title = {MoirePy: Python package for efficient tight binding simulation of bilayer moir\u00e9 lattices}, year = {2025}, url = {https://jabed-umar.github.io/MoirePy/}, }","title":"Cite This Work"},{"location":"angle_calculation_details/","text":"Angle Calculation Details This will have information about given some certain a and b how the angle is calculated, why are the calculations such? how to calculate the moire lattice vector given a and b... why? illustrate with diagram and examples.... given an a and a b how the angle is calculated @jabed write. Here is a javascript code for reference (note that this loops through all start and end... you just need to mathematically write how given an a and a b, the theta can be calculated): Inputs: - ( a, b ) (integer coefficients) - Layer 1 Lattice Vectors: ( \\mathbf{A_1}, \\mathbf{B_1} ) - Layer 2 Lattice Vectors: ( \\mathbf{A_2}, \\mathbf{B_2} ) Vectors: [ \\mathbf{V_1} = a \\mathbf{A_1} + b \\mathbf{B_1} ] [ \\mathbf{V_2} = b \\mathbf{A_2} + a \\mathbf{B_2} ] Angle ( \\theta ) Between ( \\mathbf{V_1} ) and ( \\mathbf{V_2} ): [ \\theta = \\cos^{-1} \\left( \\frac{\\mathbf{V_1} \\cdot \\mathbf{V_2}}{||\\mathbf{V_1}|| \\cdot ||\\mathbf{V_2}||} \\right) ] (Ensure ( \\gcd(a, b) = 1 ) for valid results.) function find_values(start, end, layer1Vectors, layer2Vectors) { const [a1x, a1y, b1x, b1y] = layer1Vectors; const [a2x, a2y, b2x, b2y] = layer2Vectors; const dot = (v1, v2) => v1[0] * v2[0] + v1[1] * v2[1]; const norm = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]); const results = []; for (let a = start; a <= end; a++) { for (let b = start; b <= end; b++) { if (a >= b || a < 1) continue; // checks const one = [a * a1x + b * b1x, a * a1y + b * b1y]; const two = [b * a2x + a * b2x, b * a2y + a * b2y]; const c = dot(one, two) / (norm(one) * norm(two)); const thetaRad = Math.acos(c); const thetaDeg = (thetaRad * 180) / Math.PI; if (gcd(a, b) !== 1) continue; // checks results.push([thetaDeg.toFixed(8), thetaRad.toFixed(8), a, b]); } } results.sort((x, y) => x[0] - y[0]); return results; }","title":"Angle Calculation Details"},{"location":"angle_calculation_details/#angle-calculation-details","text":"This will have information about given some certain a and b how the angle is calculated, why are the calculations such? how to calculate the moire lattice vector given a and b... why? illustrate with diagram and examples.... given an a and a b how the angle is calculated @jabed write. Here is a javascript code for reference (note that this loops through all start and end... you just need to mathematically write how given an a and a b, the theta can be calculated): Inputs: - ( a, b ) (integer coefficients) - Layer 1 Lattice Vectors: ( \\mathbf{A_1}, \\mathbf{B_1} ) - Layer 2 Lattice Vectors: ( \\mathbf{A_2}, \\mathbf{B_2} ) Vectors: [ \\mathbf{V_1} = a \\mathbf{A_1} + b \\mathbf{B_1} ] [ \\mathbf{V_2} = b \\mathbf{A_2} + a \\mathbf{B_2} ] Angle ( \\theta ) Between ( \\mathbf{V_1} ) and ( \\mathbf{V_2} ): [ \\theta = \\cos^{-1} \\left( \\frac{\\mathbf{V_1} \\cdot \\mathbf{V_2}}{||\\mathbf{V_1}|| \\cdot ||\\mathbf{V_2}||} \\right) ] (Ensure ( \\gcd(a, b) = 1 ) for valid results.) function find_values(start, end, layer1Vectors, layer2Vectors) { const [a1x, a1y, b1x, b1y] = layer1Vectors; const [a2x, a2y, b2x, b2y] = layer2Vectors; const dot = (v1, v2) => v1[0] * v2[0] + v1[1] * v2[1]; const norm = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]); const results = []; for (let a = start; a <= end; a++) { for (let b = start; b <= end; b++) { if (a >= b || a < 1) continue; // checks const one = [a * a1x + b * b1x, a * a1y + b * b1y]; const two = [b * a2x + a * b2x, b * a2y + a * b2y]; const c = dot(one, two) / (norm(one) * norm(two)); const thetaRad = Math.acos(c); const thetaDeg = (thetaRad * 180) / Math.PI; if (gcd(a, b) !== 1) continue; // checks results.push([thetaDeg.toFixed(8), thetaRad.toFixed(8), a, b]); } } results.sort((x, y) => x[0] - y[0]); return results; }","title":"Angle Calculation Details"},{"location":"find_theta/","text":".input-form { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; } input, select, button { font-size: 16px; padding: 5px; } button { cursor: pointer; background-color: rgb(41, 128, 185); color: white; border: none; padding: 10px; } table { width: 100%; border-collapse: collapse; margin-top: 20px; } th, td { padding: 8px; text-align: center; border: 1px solid #ddd; } thead { background-color: #f2f2f2; } .hidden { display: none; } .vector-inputs input { width: 80px; margin: 5px; } #end, #start { border: 1px solid #000; border-radius: 5px; padding: 8px; width: 100px; font-size: 16px; } Angle Value Calculator The Moire class takes two integers, a and b , to compute \u03b8 (the rotation angle of the upper lattice while keeping the lower lattice fixed) and other quantities like moir\u00e9 lattice vectors. This tool helps you find suitable values of a and b for your desired angles. (Finding a and b for a given \u03b8 is inefficient, as not all rotations are possible for finite lattice sizes.) Guidelines Currently, both layers must be the same . We do not support different layer types yet, but we plan to in the future. Results depend only on lattice vectors , not layer types. Identical lattice vectors (e.g., HexagonalLayer and TriangularLayer ) will yield the same results. Choosing Start and End Values Start and End define the range for a and b . The tool computes \u03b8 for all valid pairs within this range. A higher LCM of a and b results in a smaller \u03b8 . Larger values of a and b produce even smaller angles, but this significantly increases the number of results. Expect longer processing times. For details on how \u03b8 is calculated, see Angle Calculation Details . Calculator Start: End: Layer 1: Custom SquareLayer RhombusLayer TriangularLayer HexagonalLayer KagomeLayer Lattice Vectors for Layer 1: lv1: x + y lv2: x + y Layer 2: Custom SquareLayer RhombusLayer TriangularLayer HexagonalLayer KagomeLayer Lattice Vectors for Layer 2: lv1: x + y lv2: x + y CALCULATE angle (deg) angle (rad) a b let root3 = Math.sqrt(3); const latticeDefaults = { HexagonalLayer: [1, 0, 0.5, root3 / 2], SquareLayer: [1, 0, 0, 1], RhombusLayer: [1, 0, 0.5, root3 / 2], TriangularLayer: [1, 0, 0.5, root3 / 2], KagomeLayer: [1, 0, 0.5, root3 / 2], }; function updateLatticeVectors(layerId) { // only for custom vectors const layer = document.getElementById(layerId).value; const vectorContainer = document.getElementById(`${layerId}-vectors`); if (layer === \"Custom\") { vectorContainer.classList.remove(\"hidden\"); } else { vectorContainer.classList.add(\"hidden\"); const vectors = latticeDefaults[layer] || [1, 1, 1, 1]; // Placeholder if values are unknown document.getElementById(`${layerId}-lv1x`).value = vectors[0]; document.getElementById(`${layerId}-lv1y`).value = vectors[1]; document.getElementById(`${layerId}-lv2x`).value = vectors[2]; document.getElementById(`${layerId}-lv2y`).value = vectors[3]; } } function gcd(x, y) { if (y === 0) return x; else return gcd(y, x % y); } function calculate() { const start = parseInt(document.getElementById(\"start\").value); const end = parseInt(document.getElementById(\"end\").value); const layer1Vectors = [ parseFloat(document.getElementById(\"layer1-lv1x\").value), parseFloat(document.getElementById(\"layer1-lv1y\").value), parseFloat(document.getElementById(\"layer1-lv2x\").value), parseFloat(document.getElementById(\"layer1-lv2y\").value) ]; const layer2Vectors = [ parseFloat(document.getElementById(\"layer2-lv1x\").value), parseFloat(document.getElementById(\"layer2-lv1y\").value), parseFloat(document.getElementById(\"layer2-lv2x\").value), parseFloat(document.getElementById(\"layer2-lv2y\").value) ]; const results = find_values(start, end, layer1Vectors, layer2Vectors); console.log(\"Number of results: \", results.length); console.log(displayResults); displayResults_(results); } function find_values(start, end, layer1Vectors, layer2Vectors) { const [a1x, a1y, b1x, b1y] = layer1Vectors; const [a2x, a2y, b2x, b2y] = layer2Vectors; const dot = (v1, v2) => v1[0] * v2[0] + v1[1] * v2[1]; const norm = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]); const results = []; for (let a = start; a <= end; a++) { for (let b = start; b <= end; b++) { if (a >= b || a < 1) continue; // checks const one = [a * a1x + b * b1x, a * a1y + b * b1y]; const two = [b * a2x + a * b2x, b * a2y + a * b2y]; const c = dot(one, two) / (norm(one) * norm(two)); const thetaRad = Math.acos(c); const thetaDeg = (thetaRad * 180) / Math.PI; if (gcd(a, b) !== 1) continue; // checks results.push([thetaDeg.toFixed(8), thetaRad.toFixed(8), a, b]); } } results.sort((x, y) => x[0] - y[0]); return results; } function displayResults_(results) { console.log(results); const resultsBody = document.getElementById(\"results-body\"); resultsBody.innerHTML = \"\"; // Clear previous results results.forEach(tuple => { const row = document.createElement(\"tr\"); tuple.forEach(value => { const cell = document.createElement(\"td\"); cell.textContent = value; row.appendChild(cell); }); resultsBody.appendChild(row); }); } updateLatticeVectors('layer1'); updateLatticeVectors('layer2');","title":"Angle Value Calculator"},{"location":"find_theta/#angle-value-calculator","text":"The Moire class takes two integers, a and b , to compute \u03b8 (the rotation angle of the upper lattice while keeping the lower lattice fixed) and other quantities like moir\u00e9 lattice vectors. This tool helps you find suitable values of a and b for your desired angles. (Finding a and b for a given \u03b8 is inefficient, as not all rotations are possible for finite lattice sizes.)","title":"Angle Value Calculator"},{"location":"find_theta/#guidelines","text":"Currently, both layers must be the same . We do not support different layer types yet, but we plan to in the future. Results depend only on lattice vectors , not layer types. Identical lattice vectors (e.g., HexagonalLayer and TriangularLayer ) will yield the same results.","title":"Guidelines"},{"location":"find_theta/#choosing-start-and-end-values","text":"Start and End define the range for a and b . The tool computes \u03b8 for all valid pairs within this range. A higher LCM of a and b results in a smaller \u03b8 . Larger values of a and b produce even smaller angles, but this significantly increases the number of results. Expect longer processing times. For details on how \u03b8 is calculated, see Angle Calculation Details .","title":"Choosing Start and End Values"},{"location":"find_theta/#calculator","text":"Start: End: Layer 1: Custom SquareLayer RhombusLayer TriangularLayer HexagonalLayer KagomeLayer Lattice Vectors for Layer 1: lv1: x + y lv2: x + y Layer 2: Custom SquareLayer RhombusLayer TriangularLayer HexagonalLayer KagomeLayer Lattice Vectors for Layer 2: lv1: x + y lv2: x + y CALCULATE angle (deg) angle (rad) a b let root3 = Math.sqrt(3); const latticeDefaults = { HexagonalLayer: [1, 0, 0.5, root3 / 2], SquareLayer: [1, 0, 0, 1], RhombusLayer: [1, 0, 0.5, root3 / 2], TriangularLayer: [1, 0, 0.5, root3 / 2], KagomeLayer: [1, 0, 0.5, root3 / 2], }; function updateLatticeVectors(layerId) { // only for custom vectors const layer = document.getElementById(layerId).value; const vectorContainer = document.getElementById(`${layerId}-vectors`); if (layer === \"Custom\") { vectorContainer.classList.remove(\"hidden\"); } else { vectorContainer.classList.add(\"hidden\"); const vectors = latticeDefaults[layer] || [1, 1, 1, 1]; // Placeholder if values are unknown document.getElementById(`${layerId}-lv1x`).value = vectors[0]; document.getElementById(`${layerId}-lv1y`).value = vectors[1]; document.getElementById(`${layerId}-lv2x`).value = vectors[2]; document.getElementById(`${layerId}-lv2y`).value = vectors[3]; } } function gcd(x, y) { if (y === 0) return x; else return gcd(y, x % y); } function calculate() { const start = parseInt(document.getElementById(\"start\").value); const end = parseInt(document.getElementById(\"end\").value); const layer1Vectors = [ parseFloat(document.getElementById(\"layer1-lv1x\").value), parseFloat(document.getElementById(\"layer1-lv1y\").value), parseFloat(document.getElementById(\"layer1-lv2x\").value), parseFloat(document.getElementById(\"layer1-lv2y\").value) ]; const layer2Vectors = [ parseFloat(document.getElementById(\"layer2-lv1x\").value), parseFloat(document.getElementById(\"layer2-lv1y\").value), parseFloat(document.getElementById(\"layer2-lv2x\").value), parseFloat(document.getElementById(\"layer2-lv2y\").value) ]; const results = find_values(start, end, layer1Vectors, layer2Vectors); console.log(\"Number of results: \", results.length); console.log(displayResults); displayResults_(results); } function find_values(start, end, layer1Vectors, layer2Vectors) { const [a1x, a1y, b1x, b1y] = layer1Vectors; const [a2x, a2y, b2x, b2y] = layer2Vectors; const dot = (v1, v2) => v1[0] * v2[0] + v1[1] * v2[1]; const norm = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]); const results = []; for (let a = start; a <= end; a++) { for (let b = start; b <= end; b++) { if (a >= b || a < 1) continue; // checks const one = [a * a1x + b * b1x, a * a1y + b * b1y]; const two = [b * a2x + a * b2x, b * a2y + a * b2y]; const c = dot(one, two) / (norm(one) * norm(two)); const thetaRad = Math.acos(c); const thetaDeg = (thetaRad * 180) / Math.PI; if (gcd(a, b) !== 1) continue; // checks results.push([thetaDeg.toFixed(8), thetaRad.toFixed(8), a, b]); } } results.sort((x, y) => x[0] - y[0]); return results; } function displayResults_(results) { console.log(results); const resultsBody = document.getElementById(\"results-body\"); resultsBody.innerHTML = \"\"; // Clear previous results results.forEach(tuple => { const row = document.createElement(\"tr\"); tuple.forEach(value => { const cell = document.createElement(\"td\"); cell.textContent = value; row.appendChild(cell); }); resultsBody.appendChild(row); }); } updateLatticeVectors('layer1'); updateLatticeVectors('layer2');","title":"Calculator"},{"location":"index_/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"index_/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"index_/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"index_/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"installation/","text":"Installation Guide","title":"Installation"},{"location":"installation/#installation-guide","text":"","title":"Installation Guide"},{"location":"api/layers/","text":"Layer Source code in moirepy/layers.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 class Layer : # parent class def __init__ ( self , pbc : bool = False , study_proximity : int = 1 ) -> None : \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. Defaults to False. study_proximity (int): Scaling factor for proximity calculations, **enabiling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers without complaining. Defaults to 1. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. Example: ```python layer = Layer(pbc=True, study_proximity=2) Create a Layer object with PBC and study of second nearest neighbours ``` \"\"\" self . toll_scale = max ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ) ) if self . lv1 [ 1 ] != 0 or self . lv2 [ 1 ] < 0 : raise ValueError ( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://example.com \"\"\" # @jabed add link to documentation we will write this ) self . rot_m = np . eye ( 2 ) self . pbc = pbc self . points = None self . kdtree = None self . study_proximity = study_proximity def perform_rotation ( self , rot = None ) -> None : \"\"\" Rotates the lattice layer and its components by a specified angle. Args: rot (float): The rotation angle in radians. Default to `None`. Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation(np.pi/4) ``` \"\"\" rot_m = get_rotation_matrix ( rot ) self . rot_m = rot_m # Rotate lv1 and lv2 vectors self . lv1 = rot_m @ self . lv1 self . lv2 = rot_m @ self . lv2 # Rotate lattice_points self . lattice_points = [ [ * ( rot_m @ np . array ([ x , y ])), atom_type ] for x , y , atom_type in self . lattice_points ] # Rotate neighbours self . neighbours = { atom_type : [ rot_m @ np . array ( neighbour ) for neighbour in neighbour_list ] for atom_type , neighbour_list in self . neighbours . items () } def generate_points ( self , mlv1 : np . array , mlv2 : np . array , mln1 : int = 1 , mln2 : int = 1 , # bring_to_center = False ) -> None : \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.array): The first Moir\u00e9 lattice vector. mlv2 (np.array): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. Returns: None: The function modifies the object state and stores the generated points and their types. Raises: ValueError: If the number of unit cells is non-positive. Example: ```python lattice = MoireLattice() lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=3, mln2=2) print(lattice.points) ``` \"\"\" self . mlv1 = mlv1 # Moire lattice vector 1 self . mlv2 = mlv2 # Moire lattice vector 2 self . mln1 = mln1 # Number of moire unit cells along mlv1 self . mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the grid resolution points = [ np . array ([ 0 , 0 ]), mlv1 , mlv2 , mlv1 + mlv2 ] max_distance = max ( np . linalg . norm ( points [ 0 ] - points [ 1 ]), np . linalg . norm ( points [ 0 ] - points [ 2 ]), np . linalg . norm ( points [ 0 ] - points [ 3 ]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math . ceil ( max_distance / min ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range ( - n , n + 1 ): # Iterate along mlv1 for j in range ( - n , n + 1 ): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self . lv1 + j * self . lv2 for xpos , ypos , name in self . lattice_points : point = point_o + np . array ([ xpos , ypos ]) step1_points . append ( point ) step1_names . append ( name ) step1_points = np . array ( step1_points ) step1_names = np . array ( step1_names ) # Apply the boundary check method (inside_boundaries) to filter the points mask = self . _inside_boundaries ( step1_points , 1 , 1 ) step1_points = step1_points [ mask ] step1_names = step1_names [ mask ] # Step 3: Copy and translate the unit cell to create the full moire pattern points = [] # List to hold all the moire points names = [] for i in range ( self . mln1 ): # Translate along mlv1 direction for j in range ( self . mln2 ): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points . append ( translated_points ) names . append ( step1_names ) self . points = np . vstack ( points ) self . point_types = np . hstack ( names ) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") self . generate_kdtree () def _point_positions ( self , points : np . ndarray , A : np . ndarray , B : np . ndarray ) -> np . ndarray : \"\"\" Determines the position of each point relative to a parallelogram defined by vectors A and B. Args: points (np.ndarray): Array of points to be analyzed. A (np.ndarray): The first vector of the parallelogram. B (np.ndarray): The second vector of the parallelogram. Returns: np.ndarray: An array indicating the position of each point: - (0, 0) for points inside the parallelogram. - (-1, 1) or (1, -1) for points outside on specific sides. left side and right side will give -1 and 1 respectively top side and bottom side will give -1 and 1 respectively Example: ```python points = np.array([[0, 0], [1, 1], [-1, -1]]) A = np.array([1, 0]) B = np.array([0, 1]) positions = _point_positions(points, A, B) print(positions) ``` \"\"\" # Compute determinants for positions relative to OA and BC det_OA = ( points [:, 0 ] * A [ 1 ] - points [:, 1 ] * A [ 0 ]) <= self . toll_scale * 1e-2 det_BC = (( points [:, 0 ] - B [ 0 ]) * A [ 1 ] - ( points [:, 1 ] - B [ 1 ]) * A [ 0 ]) <= self . toll_scale * 1e-2 position_y = det_OA . astype ( float ) + det_BC . astype ( float ) # Compute determinants for positions relative to OB and AC det_OB = ( points [:, 0 ] * B [ 1 ] - points [:, 1 ] * B [ 0 ]) > - self . toll_scale * 1e-2 det_AC = (( points [:, 0 ] - A [ 0 ]) * B [ 1 ] - ( points [:, 1 ] - A [ 1 ]) * B [ 0 ]) > - self . toll_scale * 1e-2 position_x = det_OB . astype ( float ) + det_AC . astype ( float ) return np . column_stack (( position_x , position_y )) - 1 def _inside_polygon ( self , points : np . ndarray , polygon : np . ndarray ) -> np . ndarray : \"\"\" Determines if each point is inside a polygon using the ray-casting method. Args: points (np.ndarray): Array of points to check. polygon (np.ndarray): Vertices of the polygon to test against, in counterclockwise order. Returns: np.ndarray: A boolean array where True indicates that the point is inside the polygon. Example: ```python points = np.array([[0.5, 0.5], [1, 1], [-1, -1]]) polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]) inside = _inside_polygon(points, polygon) print(inside) ``` \"\"\" x , y = points [:, 0 ], points [:, 1 ] px , py = polygon [:, 0 ], polygon [:, 1 ] px_next , py_next = np . roll ( px , - 1 ), np . roll ( py , - 1 ) edge_cond = ( y [:, None ] > np . minimum ( py , py_next )) & ( y [:, None ] <= np . maximum ( py , py_next )) with np . errstate ( divide = 'ignore' , invalid = 'ignore' ): xinters = np . where ( py != py_next , ( y [:, None ] - py ) * ( px_next - px ) / ( py_next - py ) + px , np . inf ) ray_crosses = edge_cond & ( x [:, None ] <= xinters ) inside = np . sum ( ray_crosses , axis = 1 ) % 2 == 1 return inside # mask def _inside_boundaries ( self , points : np . ndarray , mln1 = None , mln2 = None ) -> np . ndarray : \"\"\" Determines if the given points lie within the boundaries of the Moir\u00e9 lattice pattern. Args: points (np.ndarray): Array of points to check. mln1 (int, optional): The number of unit cells along the first direction. Defaults to the object's current value. mln2 (int, optional): The number of unit cells along the second direction. Defaults to the object's current value. Returns: np.ndarray: A boolean array where True indicates that the point is within the boundaries of the lattice. Raises: ValueError: If the points array has an invalid shape. Example: ```python points = np.array([[0.5, 0.5], [2, 2], [-1, -1]]) lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3) print(lattice_boundaries) ``` \"\"\" v1 = ( mln1 if mln1 else self . mln1 ) * self . mlv1 v2 = ( mln2 if mln2 else self . mln2 ) * self . mlv2 p1 = np . array ([ 0 , 0 ]) p2 = np . array ([ v1 [ 0 ], v1 [ 1 ]]) p3 = np . array ([ v2 [ 0 ], v2 [ 1 ]]) p4 = np . array ([ v1 [ 0 ] + v2 [ 0 ], v1 [ 1 ] + v2 [ 1 ]]) return self . _inside_polygon ( points , np . array ([ p1 , p2 , p4 , p3 ]) - self . toll_scale * 1e-4 ) def generate_kdtree ( self ) -> None : \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all atoms). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. Example: ```python lattice = MoireLattice() lattice.generate_kdtree() kdtree = lattice.kdtree print(kdtree) ``` \"\"\" if not self . pbc : # OBC is easy self . kdtree = KDTree ( self . points ) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range ( - 1 , 2 ): for j in range ( - 1 , 2 ): all_points . append ( self . points + i * self . mln1 * self . mlv1 + j * self . mln2 * self . mlv2 ) all_point_names . append ( self . point_types ) all_points = np . vstack ( all_points ) all_point_names = np . hstack ( all_point_names ) v1 = self . mln1 * self . mlv1 v2 = self . mln2 * self . mlv2 neigh_pad_1 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv1 ) / np . linalg . norm ( v1 ) neigh_pad_2 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv2 ) / np . linalg . norm ( v2 ) mask = self . _inside_polygon ( all_points , np . array ([ ( - neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ( - neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ])) print ( mask . shape , mask . dtype ) points = all_points [ mask ] point_names = all_point_names [ mask ] self . bigger_points = points self . bigger_point_types = point_names self . kdtree = KDTree ( points ) # # plot the points but with colours based on the point_positions # # - point_positions = [0, 0] -> black # # - point_positions = [1, 0] -> red # # - do not plot the rest of the points at all # plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], 'k.') # plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], 'r.') # plt.plot(*all_points.T, \"ro\") # plt.plot(*points.T, \"b.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.grid() # plt.show() self . _generate_mapping () def _generate_mapping ( self ) -> None : \"\"\" Generates a mapping between two sets of points (larger and smaller lattices) based on their positions and computes the distances between corresponding points. If the distance between a point in the larger lattice and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots the lattice points for visualization. This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice. It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points` and values are the corresponding indices in `self.points`. Raises: ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`. Example: ```python my_lattice._generate_mapping() ``` The function performs the following steps: 1. Initializes an empty dictionary `self.mappings`. 2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`). 3. Computes the translation needed for each point based on a lattice scaling factor. 4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points. 5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`. 6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization. Note: - The function assumes `self.points` and `self.bigger_points` are defined as numpy arrays with the coordinates of the points in the lattices. - The translations used in the function are calculated based on `mln1`, `mln2`, `mlv1`, and `mlv2`, which define the lattice scaling and vectors. \"\"\" self . mappings = {} tree = KDTree ( self . points ) translations = self . _point_positions ( self . bigger_points , self . mln1 * self . mlv1 , self . mln2 * self . mlv2 ) for i , ( dx , dy ) in enumerate ( translations ): point = self . bigger_points [ i ] - ( dx * self . mlv1 * self . mln1 + dy * self . mlv2 * self . mln2 ) distance , index = tree . query ( point ) if distance >= self . toll_scale * 1e-3 : print ( f \"Distance { distance } exceeds tolerance for point { i } at location { point } with translation ( { dx } , { dy } ).\" ) plt . plot ( * self . bigger_points . T , \"ko\" , alpha = 0.3 ) plt . plot ( * self . points . T , \"k.\" ) # plt.plot(*self.bigger_points[i], \"b.\") # plt.plot(*point, \"r.\") # plt.plot(*self.points[index], \"g.\") # parallellogram around the whole lattice plt . plot ([ 0 , self . mln1 * self . mlv1 [ 0 ]], [ 0 , self . mln1 * self . mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , self . mln2 * self . mlv2 [ 0 ]], [ 0 , self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mln1 * self . mlv1 [ 0 ], self . mln1 * self . mlv1 [ 0 ] + self . mln2 * self . mlv2 [ 0 ]], [ self . mln1 * self . mlv1 [ 1 ], self . mln1 * self . mlv1 [ 1 ] + self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mln2 * self . mlv2 [ 0 ], self . mln1 * self . mlv1 [ 0 ] + self . mln2 * self . mlv2 [ 0 ]], [ self . mln2 * self . mlv2 [ 1 ], self . mln1 * self . mlv1 [ 1 ] + self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) # just plot mlv1 and mlv2 parallellogram plt . plot ([ 0 , self . mlv1 [ 0 ]], [ 0 , self . mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , self . mlv2 [ 0 ]], [ 0 , self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mlv1 [ 0 ], self . mlv1 [ 0 ] + self . mlv2 [ 0 ]], [ self . mlv1 [ 1 ], self . mlv1 [ 1 ] + self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mlv2 [ 0 ], self . mlv1 [ 0 ] + self . mlv2 [ 0 ]], [ self . mlv2 [ 1 ], self . mlv1 [ 1 ] + self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) # for index, point in enumerate(self.bigger_points): # plt.text(*point, f\"{index}\", fontsize=6) plt . gca () . add_patch ( plt . Circle ( point , distance / 2 , color = 'r' , fill = False )) plt . grid () plt . show () raise ValueError ( f \"FATAL ERROR: Distance { distance } exceeds tolerance for point { i } at location { point } .\" ) self . mappings [ i ] = index # point positions... for each point in self.point, point position is a array of length 2 (x, y) # where the elemnts are -1, 0 and 1... this is what their value mean about their position # (-1, 1) | (0, 1) | (1, 1) # ----------------------------- # (-1, 0) | (0, 0) | (1, 0) # ----------------------------- # (-1,-1) | (0,-1) | (1,-1) # ----------------------------- # (0, 0) is our actual lattice part... # do this for all points in self.bigger_points: # all point with point_positions = (x, y) need to be translated by # (-x*self.mlv1*self.mln1 - y*self.mlv2*self.mln2) to get the corresponding point inside the lattice # then you would need to run a query on a newly kdtree of the smaller points... # to the get the index of the corresponding point inside the lattice (distance should be zero, just saying) # now we already know the index of the point in the self.bigger_points... so we can map that to the index of the point in the self.points # then we will store that in `self.mappings`` # self.mapppings will be a dictionary with keys as the indices in the # self.bigger_points (unique) and values as the indices in the self.points (not unique) # def kth_nearest_neighbours(self, points, types, k = 1) -> None: # distance_matrix = self.kdtree.sparse_distance_matrix(self.kdtree, k) def first_nearest_neighbours ( self , points : np . ndarray , types : np . ndarray ): \"\"\" Finds the first nearest neighbors for each point in the given array. Args: points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors. types (np.ndarray): An (N,) array of types corresponding to each point in `points`. Returns: tuple: A tuple containing: - distances_list (list): A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. - indices_list (list): A list of lists, where each inner list contains the indices of the nearest neighbors in `self.points`. Raises: AssertionError: If `self.kdtree` is not initialized. AssertionError: If the number of points does not match the number of types. ValueError: If a point type is not defined in `self.neighbours`. ValueError: If PBC is enabled and a distance exceeds the specified tolerance. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> types = np.array([0, 1]) >>> distances, indices = layer.first_nearest_neighbours(points, types) ``` \"\"\" assert self . kdtree is not None , \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" assert points . shape [ 0 ] == types . shape [ 0 ], \"Mismatch between number of points and types.\" distances_list , indices_list = [], [] for point , t in zip ( points , types ): if t not in self . neighbours : raise ValueError ( f \"Point type ' { t } ' is not defined in self.neighbours.\" ) relative_neighbours = np . array ( self . neighbours [ t ]) absolute_neighbours = point + relative_neighbours distances , indices = self . kdtree . query ( absolute_neighbours , k = 1 ) filtered_distances , filtered_indices = [], [] for dist , idx in zip ( distances , indices ): if self . pbc : if dist > 1e-2 * self . toll_scale : raise ValueError ( f \"Distance { dist } exceeds tolerance.\" ) filtered_distances . append ( dist ) filtered_indices . append ( self . mappings [ idx ]) else : # if dist > 1e-2 * self.toll_scale: # raise ValueError(f\"Distance {dist} exceeds tolerance.\") filtered_distances . append ( dist ) filtered_indices . append ( idx ) distances_list . append ( filtered_distances ) indices_list . append ( filtered_indices ) return distances_list , indices_list def query ( self , points : np . ndarray , k : int = 1 ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query. Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Raises: AssertionError: If `self.kdtree` is not initialized. RuntimeError: If PBC is enabled and the mapping process fails. RuntimeError: If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior: - If `self.pbc` is False, the function returns the nearest neighbors as given by KDTree. - If `self.pbc` is True, the function applies `self.mappings` to remap indices according to periodic boundary conditions. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query(points, k=2) ``` \"\"\" # Step 1: # - get a normal query from KDTree # - distance, index = self.kdtree.query(points, k=k) # - remove all the points farther than (1+0.1*toll_scale) * min distance # - return here just that if OBC # Step 2: it will come here if PBC is True # - for all the points map them using self.mappings # - replace the indices with the mapped indices # - return the mapped indices and distances (distance will be the same) assert self . kdtree is not None , \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" distances , indices = self . kdtree . query ( points , k = k ) # for k=1, it returns squeezed arrays... so we need to unsqueeze them if k == 1 : distances = distances [:, None ] indices = indices [:, None ] distances_list , indices_list = distances . tolist (), indices . tolist () if k > 1 : # Set minimum distance threshold min_distance = distances [:, 1 ] . min () threshold = ( 1 + 1e-2 * self . toll_scale ) * min_distance # print(f\"{min_distance = }, {threshold = }\") # Filter distances and indices based on thresholds for i in range ( len ( distances_list )): while distances_list [ i ] and distances_list [ i ][ - 1 ] > threshold : distances_list [ i ] . pop () indices_list [ i ] . pop () if not self . pbc : return distances_list , indices_list # Convert lists back to numpy arrays for PBC try : distances = np . array ( distances_list ) indices = np . array ( indices_list ) except ValueError as e : raise RuntimeError ( \"FATAL ERROR: Uneven row lengths in PBC.\" ) from e # Apply mappings try : vectorized_fn = np . vectorize ( self . mappings . get ) remapped_indices = vectorized_fn ( indices ) except TypeError as e : raise RuntimeError ( \"FATAL ERROR: Mapping failed during vectorization. Check if all indices are valid.\" ) from e return distances , remapped_indices def query_non_self ( self , points : np . ndarray , k : int = 1 ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Queries the KDTree for the k nearest neighbors of given points, excluding the point itself. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query (excluding the point itself). Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Behavior: - Calls `self.query(points, k=k+1)` to get `k+1` neighbors, including the point itself. - Removes the first neighbor (which is the query point itself) from both distances and indices. - If `self.pbc` is False, it processes the lists iteratively. - If `self.pbc` is True, it slices the arrays to exclude the self-point. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query_non_self(points, k=2) ``` \"\"\" distances , indices = self . query ( points , k = k + 1 ) if self . pbc is False : for i in range ( len ( indices )): indices [ i ] = indices [ i ][ 1 :] distances [ i ] = distances [ i ][ 1 :] else : indices = indices [:, 1 :] distances = distances [:, 1 :] # return distances[:, 1:], indices[:, 1:] return distances , indices def plot_lattice ( self , plot_connections : bool = True , plot_unit_cell : bool = False ) -> None : \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. plot_unit_cell (bool, optional): If True, overlays the unit cell grid on the lattice. Defaults to False. Behavior: - Plots all lattice points grouped by atom type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. - If `plot_unit_cell` is True, it overlays the unit cell using the lattice vectors `lv1` and `lv2`. Example: ```python >>> lattice = Lattice() >>> lattice.generate_points() >>> lattice.plot_lattice(plot_connections=True, plot_unit_cell=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. - The unit cell grid (if enabled) is displayed as dotted black lines with reduced opacity. \"\"\" # plt.figure(figsize=(8, 8)) for atom_type , atom_points in self . lattice_points . items (): x_coords = [ point [ 0 ] for point in atom_points ] y_coords = [ point [ 1 ] for point in atom_points ] plt . scatter ( x_coords , y_coords , s = 5 ) if plot_connections : for point in atom_points : for neighbor in self . neighbours [ atom_type ]: connection = point + np . array ( neighbor ) plt . plot ( [ point [ 0 ], connection [ 0 ]], [ point [ 1 ], connection [ 1 ]], \"r--\" , alpha = 0.5 , ) if plot_unit_cell : for i in range ( self . ny + 1 ): # line from (lv1*0 + lv2*i) to (lv1*nx + lv2*i) plt . plot ( [ self . lv1 [ 0 ] * 0 + self . lv2 [ 0 ] * i , self . lv1 [ 0 ] * self . nx + self . lv2 [ 0 ] * i ], [ self . lv1 [ 1 ] * 0 + self . lv2 [ 1 ] * i , self . lv1 [ 1 ] * self . nx + self . lv2 [ 1 ] * i ], \"k:\" , alpha = 0.3 , ) for i in range ( self . nx + 1 ): # line from (lv1*i + lv2*0) to (lv1*i + lv2*ny) plt . plot ( [ self . lv1 [ 0 ] * i + self . lv2 [ 0 ] * 0 , self . lv1 [ 0 ] * i + self . lv2 [ 0 ] * self . ny ], [ self . lv1 [ 1 ] * i + self . lv2 [ 1 ] * 0 , self . lv1 [ 1 ] * i + self . lv2 [ 1 ] * self . ny ], \"k:\" , alpha = 0.3 , ) plt . title ( \"Lattice Points\" ) plt . xlabel ( \"X Coordinate\" ) plt . ylabel ( \"Y Coordinate\" ) plt . axis ( \"equal\" ) __init__ ( pbc = False , study_proximity = 1 ) Initializes the Layer object Parameters: pbc ( bool , default: False ) \u2013 Flag to indicate if periodic boundary conditions (PBC) are applied. Defaults to False. study_proximity ( int , default: 1 ) \u2013 Scaling factor for proximity calculations, enabiling the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers without complaining. Defaults to 1. Raises: ValueError \u2013 If lv1 is not along the x-axis or if lv2 has a negative y-component. Example: layer = Layer(pbc=True, study_proximity=2) Create a Layer object with PBC and study of second nearest neighbours Source code in moirepy/layers.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , pbc : bool = False , study_proximity : int = 1 ) -> None : \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. Defaults to False. study_proximity (int): Scaling factor for proximity calculations, **enabiling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers without complaining. Defaults to 1. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. Example: ```python layer = Layer(pbc=True, study_proximity=2) Create a Layer object with PBC and study of second nearest neighbours ``` \"\"\" self . toll_scale = max ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ) ) if self . lv1 [ 1 ] != 0 or self . lv2 [ 1 ] < 0 : raise ValueError ( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://example.com \"\"\" # @jabed add link to documentation we will write this ) self . rot_m = np . eye ( 2 ) self . pbc = pbc self . points = None self . kdtree = None self . study_proximity = study_proximity _generate_mapping () Generates a mapping between two sets of points (larger and smaller lattices) based on their positions and computes the distances between corresponding points. If the distance between a point in the larger lattice and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a ValueError and plots the lattice points for visualization. This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice. It stores the resulting mappings in the self.mappings dictionary, where keys are indices in self.bigger_points and values are the corresponding indices in self.points . Raises: ValueError \u2013 If the distance between a point and its nearest neighbor exceeds the tolerance defined by self.toll_scale . Example: my_lattice._generate_mapping() The function performs the following steps: 1. Initializes an empty dictionary self.mappings . 2. Uses a KDTree to query the neighbors for each point in the larger lattice ( self.bigger_points ). 3. Computes the translation needed for each point based on a lattice scaling factor. 4. If the distance between the corresponding points exceeds the tolerance, it raises a ValueError and plots the points. 5. Stores the index mappings of the larger lattice points to smaller lattice points in self.mappings . 6. The lattice plots show the parallelograms formed by mlv1 and mlv2 vectors for visualization. Note The function assumes self.points and self.bigger_points are defined as numpy arrays with the coordinates of the points in the lattices. The translations used in the function are calculated based on mln1 , mln2 , mlv1 , and mlv2 , which define the lattice scaling and vectors. Source code in moirepy/layers.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def _generate_mapping ( self ) -> None : \"\"\" Generates a mapping between two sets of points (larger and smaller lattices) based on their positions and computes the distances between corresponding points. If the distance between a point in the larger lattice and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots the lattice points for visualization. This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice. It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points` and values are the corresponding indices in `self.points`. Raises: ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`. Example: ```python my_lattice._generate_mapping() ``` The function performs the following steps: 1. Initializes an empty dictionary `self.mappings`. 2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`). 3. Computes the translation needed for each point based on a lattice scaling factor. 4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points. 5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`. 6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization. Note: - The function assumes `self.points` and `self.bigger_points` are defined as numpy arrays with the coordinates of the points in the lattices. - The translations used in the function are calculated based on `mln1`, `mln2`, `mlv1`, and `mlv2`, which define the lattice scaling and vectors. \"\"\" self . mappings = {} tree = KDTree ( self . points ) translations = self . _point_positions ( self . bigger_points , self . mln1 * self . mlv1 , self . mln2 * self . mlv2 ) for i , ( dx , dy ) in enumerate ( translations ): point = self . bigger_points [ i ] - ( dx * self . mlv1 * self . mln1 + dy * self . mlv2 * self . mln2 ) distance , index = tree . query ( point ) if distance >= self . toll_scale * 1e-3 : print ( f \"Distance { distance } exceeds tolerance for point { i } at location { point } with translation ( { dx } , { dy } ).\" ) plt . plot ( * self . bigger_points . T , \"ko\" , alpha = 0.3 ) plt . plot ( * self . points . T , \"k.\" ) # plt.plot(*self.bigger_points[i], \"b.\") # plt.plot(*point, \"r.\") # plt.plot(*self.points[index], \"g.\") # parallellogram around the whole lattice plt . plot ([ 0 , self . mln1 * self . mlv1 [ 0 ]], [ 0 , self . mln1 * self . mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , self . mln2 * self . mlv2 [ 0 ]], [ 0 , self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mln1 * self . mlv1 [ 0 ], self . mln1 * self . mlv1 [ 0 ] + self . mln2 * self . mlv2 [ 0 ]], [ self . mln1 * self . mlv1 [ 1 ], self . mln1 * self . mlv1 [ 1 ] + self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mln2 * self . mlv2 [ 0 ], self . mln1 * self . mlv1 [ 0 ] + self . mln2 * self . mlv2 [ 0 ]], [ self . mln2 * self . mlv2 [ 1 ], self . mln1 * self . mlv1 [ 1 ] + self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) # just plot mlv1 and mlv2 parallellogram plt . plot ([ 0 , self . mlv1 [ 0 ]], [ 0 , self . mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , self . mlv2 [ 0 ]], [ 0 , self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mlv1 [ 0 ], self . mlv1 [ 0 ] + self . mlv2 [ 0 ]], [ self . mlv1 [ 1 ], self . mlv1 [ 1 ] + self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mlv2 [ 0 ], self . mlv1 [ 0 ] + self . mlv2 [ 0 ]], [ self . mlv2 [ 1 ], self . mlv1 [ 1 ] + self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) # for index, point in enumerate(self.bigger_points): # plt.text(*point, f\"{index}\", fontsize=6) plt . gca () . add_patch ( plt . Circle ( point , distance / 2 , color = 'r' , fill = False )) plt . grid () plt . show () raise ValueError ( f \"FATAL ERROR: Distance { distance } exceeds tolerance for point { i } at location { point } .\" ) self . mappings [ i ] = index _inside_boundaries ( points , mln1 = None , mln2 = None ) Determines if the given points lie within the boundaries of the Moir\u00e9 lattice pattern. Parameters: points ( ndarray ) \u2013 Array of points to check. mln1 ( int , default: None ) \u2013 The number of unit cells along the first direction. Defaults to the object's current value. mln2 ( int , default: None ) \u2013 The number of unit cells along the second direction. Defaults to the object's current value. Returns: ndarray \u2013 np.ndarray: A boolean array where True indicates that the point is within the boundaries of the lattice. Raises: ValueError \u2013 If the points array has an invalid shape. Example: points = np.array([[0.5, 0.5], [2, 2], [-1, -1]]) lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3) print(lattice_boundaries) Source code in moirepy/layers.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def _inside_boundaries ( self , points : np . ndarray , mln1 = None , mln2 = None ) -> np . ndarray : \"\"\" Determines if the given points lie within the boundaries of the Moir\u00e9 lattice pattern. Args: points (np.ndarray): Array of points to check. mln1 (int, optional): The number of unit cells along the first direction. Defaults to the object's current value. mln2 (int, optional): The number of unit cells along the second direction. Defaults to the object's current value. Returns: np.ndarray: A boolean array where True indicates that the point is within the boundaries of the lattice. Raises: ValueError: If the points array has an invalid shape. Example: ```python points = np.array([[0.5, 0.5], [2, 2], [-1, -1]]) lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3) print(lattice_boundaries) ``` \"\"\" v1 = ( mln1 if mln1 else self . mln1 ) * self . mlv1 v2 = ( mln2 if mln2 else self . mln2 ) * self . mlv2 p1 = np . array ([ 0 , 0 ]) p2 = np . array ([ v1 [ 0 ], v1 [ 1 ]]) p3 = np . array ([ v2 [ 0 ], v2 [ 1 ]]) p4 = np . array ([ v1 [ 0 ] + v2 [ 0 ], v1 [ 1 ] + v2 [ 1 ]]) return self . _inside_polygon ( points , np . array ([ p1 , p2 , p4 , p3 ]) - self . toll_scale * 1e-4 ) _inside_polygon ( points , polygon ) Determines if each point is inside a polygon using the ray-casting method. Parameters: points ( ndarray ) \u2013 Array of points to check. polygon ( ndarray ) \u2013 Vertices of the polygon to test against, in counterclockwise order. Returns: ndarray \u2013 np.ndarray: A boolean array where True indicates that the point is inside the polygon. Example: points = np.array([[0.5, 0.5], [1, 1], [-1, -1]]) polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]) inside = _inside_polygon(points, polygon) print(inside) Source code in moirepy/layers.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def _inside_polygon ( self , points : np . ndarray , polygon : np . ndarray ) -> np . ndarray : \"\"\" Determines if each point is inside a polygon using the ray-casting method. Args: points (np.ndarray): Array of points to check. polygon (np.ndarray): Vertices of the polygon to test against, in counterclockwise order. Returns: np.ndarray: A boolean array where True indicates that the point is inside the polygon. Example: ```python points = np.array([[0.5, 0.5], [1, 1], [-1, -1]]) polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]) inside = _inside_polygon(points, polygon) print(inside) ``` \"\"\" x , y = points [:, 0 ], points [:, 1 ] px , py = polygon [:, 0 ], polygon [:, 1 ] px_next , py_next = np . roll ( px , - 1 ), np . roll ( py , - 1 ) edge_cond = ( y [:, None ] > np . minimum ( py , py_next )) & ( y [:, None ] <= np . maximum ( py , py_next )) with np . errstate ( divide = 'ignore' , invalid = 'ignore' ): xinters = np . where ( py != py_next , ( y [:, None ] - py ) * ( px_next - px ) / ( py_next - py ) + px , np . inf ) ray_crosses = edge_cond & ( x [:, None ] <= xinters ) inside = np . sum ( ray_crosses , axis = 1 ) % 2 == 1 return inside # mask _point_positions ( points , A , B ) Determines the position of each point relative to a parallelogram defined by vectors A and B. Parameters: points ( ndarray ) \u2013 Array of points to be analyzed. A ( ndarray ) \u2013 The first vector of the parallelogram. B ( ndarray ) \u2013 The second vector of the parallelogram. Returns: ndarray \u2013 np.ndarray: An array indicating the position of each point: - (0, 0) for points inside the parallelogram. - (-1, 1) or (1, -1) for points outside on specific sides. left side and right side will give -1 and 1 respectively top side and bottom side will give -1 and 1 respectively Example: points = np.array([[0, 0], [1, 1], [-1, -1]]) A = np.array([1, 0]) B = np.array([0, 1]) positions = _point_positions(points, A, B) print(positions) Source code in moirepy/layers.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def _point_positions ( self , points : np . ndarray , A : np . ndarray , B : np . ndarray ) -> np . ndarray : \"\"\" Determines the position of each point relative to a parallelogram defined by vectors A and B. Args: points (np.ndarray): Array of points to be analyzed. A (np.ndarray): The first vector of the parallelogram. B (np.ndarray): The second vector of the parallelogram. Returns: np.ndarray: An array indicating the position of each point: - (0, 0) for points inside the parallelogram. - (-1, 1) or (1, -1) for points outside on specific sides. left side and right side will give -1 and 1 respectively top side and bottom side will give -1 and 1 respectively Example: ```python points = np.array([[0, 0], [1, 1], [-1, -1]]) A = np.array([1, 0]) B = np.array([0, 1]) positions = _point_positions(points, A, B) print(positions) ``` \"\"\" # Compute determinants for positions relative to OA and BC det_OA = ( points [:, 0 ] * A [ 1 ] - points [:, 1 ] * A [ 0 ]) <= self . toll_scale * 1e-2 det_BC = (( points [:, 0 ] - B [ 0 ]) * A [ 1 ] - ( points [:, 1 ] - B [ 1 ]) * A [ 0 ]) <= self . toll_scale * 1e-2 position_y = det_OA . astype ( float ) + det_BC . astype ( float ) # Compute determinants for positions relative to OB and AC det_OB = ( points [:, 0 ] * B [ 1 ] - points [:, 1 ] * B [ 0 ]) > - self . toll_scale * 1e-2 det_AC = (( points [:, 0 ] - A [ 0 ]) * B [ 1 ] - ( points [:, 1 ] - A [ 1 ]) * B [ 0 ]) > - self . toll_scale * 1e-2 position_x = det_OB . astype ( float ) + det_AC . astype ( float ) return np . column_stack (( position_x , position_y )) - 1 first_nearest_neighbours ( points , types ) Finds the first nearest neighbors for each point in the given array. Args: points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors. types (np.ndarray): An (N,) array of types corresponding to each point in `points`. Returns: tuple: A tuple containing: - distances_list (list): A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. - indices_list (list): A list of lists, where each inner list contains the indices of the nearest neighbors in `self.points`. Raises: AssertionError: If `self.kdtree` is not initialized. AssertionError: If the number of points does not match the number of types. ValueError: If a point type is not defined in `self.neighbours`. ValueError: If PBC is enabled and a distance exceeds the specified tolerance. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> types = np.array([0, 1]) >>> distances, indices = layer.first_nearest_neighbours(points, types) ``` Source code in moirepy/layers.py 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def first_nearest_neighbours ( self , points : np . ndarray , types : np . ndarray ): \"\"\" Finds the first nearest neighbors for each point in the given array. Args: points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors. types (np.ndarray): An (N,) array of types corresponding to each point in `points`. Returns: tuple: A tuple containing: - distances_list (list): A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. - indices_list (list): A list of lists, where each inner list contains the indices of the nearest neighbors in `self.points`. Raises: AssertionError: If `self.kdtree` is not initialized. AssertionError: If the number of points does not match the number of types. ValueError: If a point type is not defined in `self.neighbours`. ValueError: If PBC is enabled and a distance exceeds the specified tolerance. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> types = np.array([0, 1]) >>> distances, indices = layer.first_nearest_neighbours(points, types) ``` \"\"\" assert self . kdtree is not None , \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" assert points . shape [ 0 ] == types . shape [ 0 ], \"Mismatch between number of points and types.\" distances_list , indices_list = [], [] for point , t in zip ( points , types ): if t not in self . neighbours : raise ValueError ( f \"Point type ' { t } ' is not defined in self.neighbours.\" ) relative_neighbours = np . array ( self . neighbours [ t ]) absolute_neighbours = point + relative_neighbours distances , indices = self . kdtree . query ( absolute_neighbours , k = 1 ) filtered_distances , filtered_indices = [], [] for dist , idx in zip ( distances , indices ): if self . pbc : if dist > 1e-2 * self . toll_scale : raise ValueError ( f \"Distance { dist } exceeds tolerance.\" ) filtered_distances . append ( dist ) filtered_indices . append ( self . mappings [ idx ]) else : # if dist > 1e-2 * self.toll_scale: # raise ValueError(f\"Distance {dist} exceeds tolerance.\") filtered_distances . append ( dist ) filtered_indices . append ( idx ) distances_list . append ( filtered_distances ) indices_list . append ( filtered_indices ) return distances_list , indices_list generate_kdtree () Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all atoms). Returns: None ( None ) \u2013 The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError \u2013 If the points in the lattice are not defined. Example: lattice = MoireLattice() lattice.generate_kdtree() kdtree = lattice.kdtree print(kdtree) Source code in moirepy/layers.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 def generate_kdtree ( self ) -> None : \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all atoms). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. Example: ```python lattice = MoireLattice() lattice.generate_kdtree() kdtree = lattice.kdtree print(kdtree) ``` \"\"\" if not self . pbc : # OBC is easy self . kdtree = KDTree ( self . points ) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range ( - 1 , 2 ): for j in range ( - 1 , 2 ): all_points . append ( self . points + i * self . mln1 * self . mlv1 + j * self . mln2 * self . mlv2 ) all_point_names . append ( self . point_types ) all_points = np . vstack ( all_points ) all_point_names = np . hstack ( all_point_names ) v1 = self . mln1 * self . mlv1 v2 = self . mln2 * self . mlv2 neigh_pad_1 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv1 ) / np . linalg . norm ( v1 ) neigh_pad_2 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv2 ) / np . linalg . norm ( v2 ) mask = self . _inside_polygon ( all_points , np . array ([ ( - neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ( - neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ])) print ( mask . shape , mask . dtype ) points = all_points [ mask ] point_names = all_point_names [ mask ] self . bigger_points = points self . bigger_point_types = point_names self . kdtree = KDTree ( points ) # # plot the points but with colours based on the point_positions # # - point_positions = [0, 0] -> black # # - point_positions = [1, 0] -> red # # - do not plot the rest of the points at all # plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], 'k.') # plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], 'r.') # plt.plot(*all_points.T, \"ro\") # plt.plot(*points.T, \"b.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.grid() # plt.show() self . _generate_mapping () generate_points ( mlv1 , mlv2 , mln1 = 1 , mln2 = 1 ) Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Parameters: mlv1 ( array ) \u2013 The first Moir\u00e9 lattice vector. mlv2 ( array ) \u2013 The second Moir\u00e9 lattice vector. mln1 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. Returns: None ( None ) \u2013 The function modifies the object state and None \u2013 stores the generated points and their types. Raises: ValueError \u2013 If the number of unit cells is non-positive. Example: lattice = MoireLattice() lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=3, mln2=2) print(lattice.points) Source code in moirepy/layers.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def generate_points ( self , mlv1 : np . array , mlv2 : np . array , mln1 : int = 1 , mln2 : int = 1 , # bring_to_center = False ) -> None : \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.array): The first Moir\u00e9 lattice vector. mlv2 (np.array): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. Returns: None: The function modifies the object state and stores the generated points and their types. Raises: ValueError: If the number of unit cells is non-positive. Example: ```python lattice = MoireLattice() lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=3, mln2=2) print(lattice.points) ``` \"\"\" self . mlv1 = mlv1 # Moire lattice vector 1 self . mlv2 = mlv2 # Moire lattice vector 2 self . mln1 = mln1 # Number of moire unit cells along mlv1 self . mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the grid resolution points = [ np . array ([ 0 , 0 ]), mlv1 , mlv2 , mlv1 + mlv2 ] max_distance = max ( np . linalg . norm ( points [ 0 ] - points [ 1 ]), np . linalg . norm ( points [ 0 ] - points [ 2 ]), np . linalg . norm ( points [ 0 ] - points [ 3 ]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math . ceil ( max_distance / min ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range ( - n , n + 1 ): # Iterate along mlv1 for j in range ( - n , n + 1 ): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self . lv1 + j * self . lv2 for xpos , ypos , name in self . lattice_points : point = point_o + np . array ([ xpos , ypos ]) step1_points . append ( point ) step1_names . append ( name ) step1_points = np . array ( step1_points ) step1_names = np . array ( step1_names ) # Apply the boundary check method (inside_boundaries) to filter the points mask = self . _inside_boundaries ( step1_points , 1 , 1 ) step1_points = step1_points [ mask ] step1_names = step1_names [ mask ] # Step 3: Copy and translate the unit cell to create the full moire pattern points = [] # List to hold all the moire points names = [] for i in range ( self . mln1 ): # Translate along mlv1 direction for j in range ( self . mln2 ): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points . append ( translated_points ) names . append ( step1_names ) self . points = np . vstack ( points ) self . point_types = np . hstack ( names ) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") self . generate_kdtree () perform_rotation ( rot = None ) Rotates the lattice layer and its components by a specified angle. Parameters: rot ( float , default: None ) \u2013 The rotation angle in radians. Default to None . Returns: None ( None ) \u2013 The function modifies the rotation matrix None \u2013 and updates the lattice points and neighbors in place. Example: layer.perform_rotation(np.pi/4) Source code in moirepy/layers.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def perform_rotation ( self , rot = None ) -> None : \"\"\" Rotates the lattice layer and its components by a specified angle. Args: rot (float): The rotation angle in radians. Default to `None`. Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation(np.pi/4) ``` \"\"\" rot_m = get_rotation_matrix ( rot ) self . rot_m = rot_m # Rotate lv1 and lv2 vectors self . lv1 = rot_m @ self . lv1 self . lv2 = rot_m @ self . lv2 # Rotate lattice_points self . lattice_points = [ [ * ( rot_m @ np . array ([ x , y ])), atom_type ] for x , y , atom_type in self . lattice_points ] # Rotate neighbours self . neighbours = { atom_type : [ rot_m @ np . array ( neighbour ) for neighbour in neighbour_list ] for atom_type , neighbour_list in self . neighbours . items () } plot_lattice ( plot_connections = True , plot_unit_cell = False ) Plots the lattice points and optionally the connections between them and the unit cell structure. Parameters: plot_connections ( bool , default: True ) \u2013 If True, plots the connections between nearest neighbors. Defaults to True. plot_unit_cell ( bool , default: False ) \u2013 If True, overlays the unit cell grid on the lattice. Defaults to False. Behavior Plots all lattice points grouped by atom type. If plot_connections is True, it draws dashed red lines between nearest neighbors. If plot_unit_cell is True, it overlays the unit cell using the lattice vectors lv1 and lv2 . Example: >>> lattice = Lattice() >>> lattice.generate_points() >>> lattice.plot_lattice(plot_connections=True, plot_unit_cell=True) Visualization Details Lattice points are plotted as small dots. Nearest neighbor connections (if enabled) are shown as dashed red lines. The unit cell grid (if enabled) is displayed as dotted black lines with reduced opacity. Source code in moirepy/layers.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 def plot_lattice ( self , plot_connections : bool = True , plot_unit_cell : bool = False ) -> None : \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. plot_unit_cell (bool, optional): If True, overlays the unit cell grid on the lattice. Defaults to False. Behavior: - Plots all lattice points grouped by atom type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. - If `plot_unit_cell` is True, it overlays the unit cell using the lattice vectors `lv1` and `lv2`. Example: ```python >>> lattice = Lattice() >>> lattice.generate_points() >>> lattice.plot_lattice(plot_connections=True, plot_unit_cell=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. - The unit cell grid (if enabled) is displayed as dotted black lines with reduced opacity. \"\"\" # plt.figure(figsize=(8, 8)) for atom_type , atom_points in self . lattice_points . items (): x_coords = [ point [ 0 ] for point in atom_points ] y_coords = [ point [ 1 ] for point in atom_points ] plt . scatter ( x_coords , y_coords , s = 5 ) if plot_connections : for point in atom_points : for neighbor in self . neighbours [ atom_type ]: connection = point + np . array ( neighbor ) plt . plot ( [ point [ 0 ], connection [ 0 ]], [ point [ 1 ], connection [ 1 ]], \"r--\" , alpha = 0.5 , ) if plot_unit_cell : for i in range ( self . ny + 1 ): # line from (lv1*0 + lv2*i) to (lv1*nx + lv2*i) plt . plot ( [ self . lv1 [ 0 ] * 0 + self . lv2 [ 0 ] * i , self . lv1 [ 0 ] * self . nx + self . lv2 [ 0 ] * i ], [ self . lv1 [ 1 ] * 0 + self . lv2 [ 1 ] * i , self . lv1 [ 1 ] * self . nx + self . lv2 [ 1 ] * i ], \"k:\" , alpha = 0.3 , ) for i in range ( self . nx + 1 ): # line from (lv1*i + lv2*0) to (lv1*i + lv2*ny) plt . plot ( [ self . lv1 [ 0 ] * i + self . lv2 [ 0 ] * 0 , self . lv1 [ 0 ] * i + self . lv2 [ 0 ] * self . ny ], [ self . lv1 [ 1 ] * i + self . lv2 [ 1 ] * 0 , self . lv1 [ 1 ] * i + self . lv2 [ 1 ] * self . ny ], \"k:\" , alpha = 0.3 , ) plt . title ( \"Lattice Points\" ) plt . xlabel ( \"X Coordinate\" ) plt . ylabel ( \"Y Coordinate\" ) plt . axis ( \"equal\" ) query ( points , k = 1 ) Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Parameters: points ( ndarray ) \u2013 An (N, 2) array of points for which to find the nearest neighbors. k ( int , default: 1 ) \u2013 The number of nearest neighbors to query. Defaults to 1. Returns: Tuple [ ndarray , ndarray ] \u2013 Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in self.points . If PBC is enabled, the indices are remapped using self.mappings . Raises: AssertionError \u2013 If self.kdtree is not initialized. RuntimeError \u2013 If PBC is enabled and the mapping process fails. RuntimeError \u2013 If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior If self.pbc is False, the function returns the nearest neighbors as given by KDTree. If self.pbc is True, the function applies self.mappings to remap indices according to periodic boundary conditions. Example: >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query(points, k=2) Source code in moirepy/layers.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 def query ( self , points : np . ndarray , k : int = 1 ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query. Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Raises: AssertionError: If `self.kdtree` is not initialized. RuntimeError: If PBC is enabled and the mapping process fails. RuntimeError: If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior: - If `self.pbc` is False, the function returns the nearest neighbors as given by KDTree. - If `self.pbc` is True, the function applies `self.mappings` to remap indices according to periodic boundary conditions. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query(points, k=2) ``` \"\"\" # Step 1: # - get a normal query from KDTree # - distance, index = self.kdtree.query(points, k=k) # - remove all the points farther than (1+0.1*toll_scale) * min distance # - return here just that if OBC # Step 2: it will come here if PBC is True # - for all the points map them using self.mappings # - replace the indices with the mapped indices # - return the mapped indices and distances (distance will be the same) assert self . kdtree is not None , \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" distances , indices = self . kdtree . query ( points , k = k ) # for k=1, it returns squeezed arrays... so we need to unsqueeze them if k == 1 : distances = distances [:, None ] indices = indices [:, None ] distances_list , indices_list = distances . tolist (), indices . tolist () if k > 1 : # Set minimum distance threshold min_distance = distances [:, 1 ] . min () threshold = ( 1 + 1e-2 * self . toll_scale ) * min_distance # print(f\"{min_distance = }, {threshold = }\") # Filter distances and indices based on thresholds for i in range ( len ( distances_list )): while distances_list [ i ] and distances_list [ i ][ - 1 ] > threshold : distances_list [ i ] . pop () indices_list [ i ] . pop () if not self . pbc : return distances_list , indices_list # Convert lists back to numpy arrays for PBC try : distances = np . array ( distances_list ) indices = np . array ( indices_list ) except ValueError as e : raise RuntimeError ( \"FATAL ERROR: Uneven row lengths in PBC.\" ) from e # Apply mappings try : vectorized_fn = np . vectorize ( self . mappings . get ) remapped_indices = vectorized_fn ( indices ) except TypeError as e : raise RuntimeError ( \"FATAL ERROR: Mapping failed during vectorization. Check if all indices are valid.\" ) from e return distances , remapped_indices query_non_self ( points , k = 1 ) Queries the KDTree for the k nearest neighbors of given points, excluding the point itself. Parameters: points ( ndarray ) \u2013 An (N, 2) array of points for which to find the nearest neighbors. k ( int , default: 1 ) \u2013 The number of nearest neighbors to query (excluding the point itself). Defaults to 1. Returns: Tuple [ ndarray , ndarray ] \u2013 Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in self.points . If PBC is enabled, the indices are remapped using self.mappings . Behavior Calls self.query(points, k=k+1) to get k+1 neighbors, including the point itself. Removes the first neighbor (which is the query point itself) from both distances and indices. If self.pbc is False, it processes the lists iteratively. If self.pbc is True, it slices the arrays to exclude the self-point. Example: >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query_non_self(points, k=2) Source code in moirepy/layers.py 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 def query_non_self ( self , points : np . ndarray , k : int = 1 ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Queries the KDTree for the k nearest neighbors of given points, excluding the point itself. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query (excluding the point itself). Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Behavior: - Calls `self.query(points, k=k+1)` to get `k+1` neighbors, including the point itself. - Removes the first neighbor (which is the query point itself) from both distances and indices. - If `self.pbc` is False, it processes the lists iteratively. - If `self.pbc` is True, it slices the arrays to exclude the self-point. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query_non_self(points, k=2) ``` \"\"\" distances , indices = self . query ( points , k = k + 1 ) if self . pbc is False : for i in range ( len ( indices )): indices [ i ] = indices [ i ][ 1 :] distances [ i ] = distances [ i ][ 1 :] else : indices = indices [:, 1 :] distances = distances [:, 1 :] # return distances[:, 1:], indices[:, 1:] return distances , indices","title":"Layers"},{"location":"api/layers/#moirepy.layers.Layer","text":"Source code in moirepy/layers.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 class Layer : # parent class def __init__ ( self , pbc : bool = False , study_proximity : int = 1 ) -> None : \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. Defaults to False. study_proximity (int): Scaling factor for proximity calculations, **enabiling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers without complaining. Defaults to 1. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. Example: ```python layer = Layer(pbc=True, study_proximity=2) Create a Layer object with PBC and study of second nearest neighbours ``` \"\"\" self . toll_scale = max ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ) ) if self . lv1 [ 1 ] != 0 or self . lv2 [ 1 ] < 0 : raise ValueError ( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://example.com \"\"\" # @jabed add link to documentation we will write this ) self . rot_m = np . eye ( 2 ) self . pbc = pbc self . points = None self . kdtree = None self . study_proximity = study_proximity def perform_rotation ( self , rot = None ) -> None : \"\"\" Rotates the lattice layer and its components by a specified angle. Args: rot (float): The rotation angle in radians. Default to `None`. Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation(np.pi/4) ``` \"\"\" rot_m = get_rotation_matrix ( rot ) self . rot_m = rot_m # Rotate lv1 and lv2 vectors self . lv1 = rot_m @ self . lv1 self . lv2 = rot_m @ self . lv2 # Rotate lattice_points self . lattice_points = [ [ * ( rot_m @ np . array ([ x , y ])), atom_type ] for x , y , atom_type in self . lattice_points ] # Rotate neighbours self . neighbours = { atom_type : [ rot_m @ np . array ( neighbour ) for neighbour in neighbour_list ] for atom_type , neighbour_list in self . neighbours . items () } def generate_points ( self , mlv1 : np . array , mlv2 : np . array , mln1 : int = 1 , mln2 : int = 1 , # bring_to_center = False ) -> None : \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.array): The first Moir\u00e9 lattice vector. mlv2 (np.array): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. Returns: None: The function modifies the object state and stores the generated points and their types. Raises: ValueError: If the number of unit cells is non-positive. Example: ```python lattice = MoireLattice() lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=3, mln2=2) print(lattice.points) ``` \"\"\" self . mlv1 = mlv1 # Moire lattice vector 1 self . mlv2 = mlv2 # Moire lattice vector 2 self . mln1 = mln1 # Number of moire unit cells along mlv1 self . mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the grid resolution points = [ np . array ([ 0 , 0 ]), mlv1 , mlv2 , mlv1 + mlv2 ] max_distance = max ( np . linalg . norm ( points [ 0 ] - points [ 1 ]), np . linalg . norm ( points [ 0 ] - points [ 2 ]), np . linalg . norm ( points [ 0 ] - points [ 3 ]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math . ceil ( max_distance / min ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range ( - n , n + 1 ): # Iterate along mlv1 for j in range ( - n , n + 1 ): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self . lv1 + j * self . lv2 for xpos , ypos , name in self . lattice_points : point = point_o + np . array ([ xpos , ypos ]) step1_points . append ( point ) step1_names . append ( name ) step1_points = np . array ( step1_points ) step1_names = np . array ( step1_names ) # Apply the boundary check method (inside_boundaries) to filter the points mask = self . _inside_boundaries ( step1_points , 1 , 1 ) step1_points = step1_points [ mask ] step1_names = step1_names [ mask ] # Step 3: Copy and translate the unit cell to create the full moire pattern points = [] # List to hold all the moire points names = [] for i in range ( self . mln1 ): # Translate along mlv1 direction for j in range ( self . mln2 ): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points . append ( translated_points ) names . append ( step1_names ) self . points = np . vstack ( points ) self . point_types = np . hstack ( names ) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") self . generate_kdtree () def _point_positions ( self , points : np . ndarray , A : np . ndarray , B : np . ndarray ) -> np . ndarray : \"\"\" Determines the position of each point relative to a parallelogram defined by vectors A and B. Args: points (np.ndarray): Array of points to be analyzed. A (np.ndarray): The first vector of the parallelogram. B (np.ndarray): The second vector of the parallelogram. Returns: np.ndarray: An array indicating the position of each point: - (0, 0) for points inside the parallelogram. - (-1, 1) or (1, -1) for points outside on specific sides. left side and right side will give -1 and 1 respectively top side and bottom side will give -1 and 1 respectively Example: ```python points = np.array([[0, 0], [1, 1], [-1, -1]]) A = np.array([1, 0]) B = np.array([0, 1]) positions = _point_positions(points, A, B) print(positions) ``` \"\"\" # Compute determinants for positions relative to OA and BC det_OA = ( points [:, 0 ] * A [ 1 ] - points [:, 1 ] * A [ 0 ]) <= self . toll_scale * 1e-2 det_BC = (( points [:, 0 ] - B [ 0 ]) * A [ 1 ] - ( points [:, 1 ] - B [ 1 ]) * A [ 0 ]) <= self . toll_scale * 1e-2 position_y = det_OA . astype ( float ) + det_BC . astype ( float ) # Compute determinants for positions relative to OB and AC det_OB = ( points [:, 0 ] * B [ 1 ] - points [:, 1 ] * B [ 0 ]) > - self . toll_scale * 1e-2 det_AC = (( points [:, 0 ] - A [ 0 ]) * B [ 1 ] - ( points [:, 1 ] - A [ 1 ]) * B [ 0 ]) > - self . toll_scale * 1e-2 position_x = det_OB . astype ( float ) + det_AC . astype ( float ) return np . column_stack (( position_x , position_y )) - 1 def _inside_polygon ( self , points : np . ndarray , polygon : np . ndarray ) -> np . ndarray : \"\"\" Determines if each point is inside a polygon using the ray-casting method. Args: points (np.ndarray): Array of points to check. polygon (np.ndarray): Vertices of the polygon to test against, in counterclockwise order. Returns: np.ndarray: A boolean array where True indicates that the point is inside the polygon. Example: ```python points = np.array([[0.5, 0.5], [1, 1], [-1, -1]]) polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]) inside = _inside_polygon(points, polygon) print(inside) ``` \"\"\" x , y = points [:, 0 ], points [:, 1 ] px , py = polygon [:, 0 ], polygon [:, 1 ] px_next , py_next = np . roll ( px , - 1 ), np . roll ( py , - 1 ) edge_cond = ( y [:, None ] > np . minimum ( py , py_next )) & ( y [:, None ] <= np . maximum ( py , py_next )) with np . errstate ( divide = 'ignore' , invalid = 'ignore' ): xinters = np . where ( py != py_next , ( y [:, None ] - py ) * ( px_next - px ) / ( py_next - py ) + px , np . inf ) ray_crosses = edge_cond & ( x [:, None ] <= xinters ) inside = np . sum ( ray_crosses , axis = 1 ) % 2 == 1 return inside # mask def _inside_boundaries ( self , points : np . ndarray , mln1 = None , mln2 = None ) -> np . ndarray : \"\"\" Determines if the given points lie within the boundaries of the Moir\u00e9 lattice pattern. Args: points (np.ndarray): Array of points to check. mln1 (int, optional): The number of unit cells along the first direction. Defaults to the object's current value. mln2 (int, optional): The number of unit cells along the second direction. Defaults to the object's current value. Returns: np.ndarray: A boolean array where True indicates that the point is within the boundaries of the lattice. Raises: ValueError: If the points array has an invalid shape. Example: ```python points = np.array([[0.5, 0.5], [2, 2], [-1, -1]]) lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3) print(lattice_boundaries) ``` \"\"\" v1 = ( mln1 if mln1 else self . mln1 ) * self . mlv1 v2 = ( mln2 if mln2 else self . mln2 ) * self . mlv2 p1 = np . array ([ 0 , 0 ]) p2 = np . array ([ v1 [ 0 ], v1 [ 1 ]]) p3 = np . array ([ v2 [ 0 ], v2 [ 1 ]]) p4 = np . array ([ v1 [ 0 ] + v2 [ 0 ], v1 [ 1 ] + v2 [ 1 ]]) return self . _inside_polygon ( points , np . array ([ p1 , p2 , p4 , p3 ]) - self . toll_scale * 1e-4 ) def generate_kdtree ( self ) -> None : \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all atoms). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. Example: ```python lattice = MoireLattice() lattice.generate_kdtree() kdtree = lattice.kdtree print(kdtree) ``` \"\"\" if not self . pbc : # OBC is easy self . kdtree = KDTree ( self . points ) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range ( - 1 , 2 ): for j in range ( - 1 , 2 ): all_points . append ( self . points + i * self . mln1 * self . mlv1 + j * self . mln2 * self . mlv2 ) all_point_names . append ( self . point_types ) all_points = np . vstack ( all_points ) all_point_names = np . hstack ( all_point_names ) v1 = self . mln1 * self . mlv1 v2 = self . mln2 * self . mlv2 neigh_pad_1 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv1 ) / np . linalg . norm ( v1 ) neigh_pad_2 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv2 ) / np . linalg . norm ( v2 ) mask = self . _inside_polygon ( all_points , np . array ([ ( - neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ( - neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ])) print ( mask . shape , mask . dtype ) points = all_points [ mask ] point_names = all_point_names [ mask ] self . bigger_points = points self . bigger_point_types = point_names self . kdtree = KDTree ( points ) # # plot the points but with colours based on the point_positions # # - point_positions = [0, 0] -> black # # - point_positions = [1, 0] -> red # # - do not plot the rest of the points at all # plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], 'k.') # plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], 'r.') # plt.plot(*all_points.T, \"ro\") # plt.plot(*points.T, \"b.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.grid() # plt.show() self . _generate_mapping () def _generate_mapping ( self ) -> None : \"\"\" Generates a mapping between two sets of points (larger and smaller lattices) based on their positions and computes the distances between corresponding points. If the distance between a point in the larger lattice and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots the lattice points for visualization. This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice. It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points` and values are the corresponding indices in `self.points`. Raises: ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`. Example: ```python my_lattice._generate_mapping() ``` The function performs the following steps: 1. Initializes an empty dictionary `self.mappings`. 2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`). 3. Computes the translation needed for each point based on a lattice scaling factor. 4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points. 5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`. 6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization. Note: - The function assumes `self.points` and `self.bigger_points` are defined as numpy arrays with the coordinates of the points in the lattices. - The translations used in the function are calculated based on `mln1`, `mln2`, `mlv1`, and `mlv2`, which define the lattice scaling and vectors. \"\"\" self . mappings = {} tree = KDTree ( self . points ) translations = self . _point_positions ( self . bigger_points , self . mln1 * self . mlv1 , self . mln2 * self . mlv2 ) for i , ( dx , dy ) in enumerate ( translations ): point = self . bigger_points [ i ] - ( dx * self . mlv1 * self . mln1 + dy * self . mlv2 * self . mln2 ) distance , index = tree . query ( point ) if distance >= self . toll_scale * 1e-3 : print ( f \"Distance { distance } exceeds tolerance for point { i } at location { point } with translation ( { dx } , { dy } ).\" ) plt . plot ( * self . bigger_points . T , \"ko\" , alpha = 0.3 ) plt . plot ( * self . points . T , \"k.\" ) # plt.plot(*self.bigger_points[i], \"b.\") # plt.plot(*point, \"r.\") # plt.plot(*self.points[index], \"g.\") # parallellogram around the whole lattice plt . plot ([ 0 , self . mln1 * self . mlv1 [ 0 ]], [ 0 , self . mln1 * self . mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , self . mln2 * self . mlv2 [ 0 ]], [ 0 , self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mln1 * self . mlv1 [ 0 ], self . mln1 * self . mlv1 [ 0 ] + self . mln2 * self . mlv2 [ 0 ]], [ self . mln1 * self . mlv1 [ 1 ], self . mln1 * self . mlv1 [ 1 ] + self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mln2 * self . mlv2 [ 0 ], self . mln1 * self . mlv1 [ 0 ] + self . mln2 * self . mlv2 [ 0 ]], [ self . mln2 * self . mlv2 [ 1 ], self . mln1 * self . mlv1 [ 1 ] + self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) # just plot mlv1 and mlv2 parallellogram plt . plot ([ 0 , self . mlv1 [ 0 ]], [ 0 , self . mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , self . mlv2 [ 0 ]], [ 0 , self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mlv1 [ 0 ], self . mlv1 [ 0 ] + self . mlv2 [ 0 ]], [ self . mlv1 [ 1 ], self . mlv1 [ 1 ] + self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mlv2 [ 0 ], self . mlv1 [ 0 ] + self . mlv2 [ 0 ]], [ self . mlv2 [ 1 ], self . mlv1 [ 1 ] + self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) # for index, point in enumerate(self.bigger_points): # plt.text(*point, f\"{index}\", fontsize=6) plt . gca () . add_patch ( plt . Circle ( point , distance / 2 , color = 'r' , fill = False )) plt . grid () plt . show () raise ValueError ( f \"FATAL ERROR: Distance { distance } exceeds tolerance for point { i } at location { point } .\" ) self . mappings [ i ] = index # point positions... for each point in self.point, point position is a array of length 2 (x, y) # where the elemnts are -1, 0 and 1... this is what their value mean about their position # (-1, 1) | (0, 1) | (1, 1) # ----------------------------- # (-1, 0) | (0, 0) | (1, 0) # ----------------------------- # (-1,-1) | (0,-1) | (1,-1) # ----------------------------- # (0, 0) is our actual lattice part... # do this for all points in self.bigger_points: # all point with point_positions = (x, y) need to be translated by # (-x*self.mlv1*self.mln1 - y*self.mlv2*self.mln2) to get the corresponding point inside the lattice # then you would need to run a query on a newly kdtree of the smaller points... # to the get the index of the corresponding point inside the lattice (distance should be zero, just saying) # now we already know the index of the point in the self.bigger_points... so we can map that to the index of the point in the self.points # then we will store that in `self.mappings`` # self.mapppings will be a dictionary with keys as the indices in the # self.bigger_points (unique) and values as the indices in the self.points (not unique) # def kth_nearest_neighbours(self, points, types, k = 1) -> None: # distance_matrix = self.kdtree.sparse_distance_matrix(self.kdtree, k) def first_nearest_neighbours ( self , points : np . ndarray , types : np . ndarray ): \"\"\" Finds the first nearest neighbors for each point in the given array. Args: points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors. types (np.ndarray): An (N,) array of types corresponding to each point in `points`. Returns: tuple: A tuple containing: - distances_list (list): A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. - indices_list (list): A list of lists, where each inner list contains the indices of the nearest neighbors in `self.points`. Raises: AssertionError: If `self.kdtree` is not initialized. AssertionError: If the number of points does not match the number of types. ValueError: If a point type is not defined in `self.neighbours`. ValueError: If PBC is enabled and a distance exceeds the specified tolerance. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> types = np.array([0, 1]) >>> distances, indices = layer.first_nearest_neighbours(points, types) ``` \"\"\" assert self . kdtree is not None , \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" assert points . shape [ 0 ] == types . shape [ 0 ], \"Mismatch between number of points and types.\" distances_list , indices_list = [], [] for point , t in zip ( points , types ): if t not in self . neighbours : raise ValueError ( f \"Point type ' { t } ' is not defined in self.neighbours.\" ) relative_neighbours = np . array ( self . neighbours [ t ]) absolute_neighbours = point + relative_neighbours distances , indices = self . kdtree . query ( absolute_neighbours , k = 1 ) filtered_distances , filtered_indices = [], [] for dist , idx in zip ( distances , indices ): if self . pbc : if dist > 1e-2 * self . toll_scale : raise ValueError ( f \"Distance { dist } exceeds tolerance.\" ) filtered_distances . append ( dist ) filtered_indices . append ( self . mappings [ idx ]) else : # if dist > 1e-2 * self.toll_scale: # raise ValueError(f\"Distance {dist} exceeds tolerance.\") filtered_distances . append ( dist ) filtered_indices . append ( idx ) distances_list . append ( filtered_distances ) indices_list . append ( filtered_indices ) return distances_list , indices_list def query ( self , points : np . ndarray , k : int = 1 ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query. Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Raises: AssertionError: If `self.kdtree` is not initialized. RuntimeError: If PBC is enabled and the mapping process fails. RuntimeError: If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior: - If `self.pbc` is False, the function returns the nearest neighbors as given by KDTree. - If `self.pbc` is True, the function applies `self.mappings` to remap indices according to periodic boundary conditions. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query(points, k=2) ``` \"\"\" # Step 1: # - get a normal query from KDTree # - distance, index = self.kdtree.query(points, k=k) # - remove all the points farther than (1+0.1*toll_scale) * min distance # - return here just that if OBC # Step 2: it will come here if PBC is True # - for all the points map them using self.mappings # - replace the indices with the mapped indices # - return the mapped indices and distances (distance will be the same) assert self . kdtree is not None , \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" distances , indices = self . kdtree . query ( points , k = k ) # for k=1, it returns squeezed arrays... so we need to unsqueeze them if k == 1 : distances = distances [:, None ] indices = indices [:, None ] distances_list , indices_list = distances . tolist (), indices . tolist () if k > 1 : # Set minimum distance threshold min_distance = distances [:, 1 ] . min () threshold = ( 1 + 1e-2 * self . toll_scale ) * min_distance # print(f\"{min_distance = }, {threshold = }\") # Filter distances and indices based on thresholds for i in range ( len ( distances_list )): while distances_list [ i ] and distances_list [ i ][ - 1 ] > threshold : distances_list [ i ] . pop () indices_list [ i ] . pop () if not self . pbc : return distances_list , indices_list # Convert lists back to numpy arrays for PBC try : distances = np . array ( distances_list ) indices = np . array ( indices_list ) except ValueError as e : raise RuntimeError ( \"FATAL ERROR: Uneven row lengths in PBC.\" ) from e # Apply mappings try : vectorized_fn = np . vectorize ( self . mappings . get ) remapped_indices = vectorized_fn ( indices ) except TypeError as e : raise RuntimeError ( \"FATAL ERROR: Mapping failed during vectorization. Check if all indices are valid.\" ) from e return distances , remapped_indices def query_non_self ( self , points : np . ndarray , k : int = 1 ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Queries the KDTree for the k nearest neighbors of given points, excluding the point itself. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query (excluding the point itself). Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Behavior: - Calls `self.query(points, k=k+1)` to get `k+1` neighbors, including the point itself. - Removes the first neighbor (which is the query point itself) from both distances and indices. - If `self.pbc` is False, it processes the lists iteratively. - If `self.pbc` is True, it slices the arrays to exclude the self-point. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query_non_self(points, k=2) ``` \"\"\" distances , indices = self . query ( points , k = k + 1 ) if self . pbc is False : for i in range ( len ( indices )): indices [ i ] = indices [ i ][ 1 :] distances [ i ] = distances [ i ][ 1 :] else : indices = indices [:, 1 :] distances = distances [:, 1 :] # return distances[:, 1:], indices[:, 1:] return distances , indices def plot_lattice ( self , plot_connections : bool = True , plot_unit_cell : bool = False ) -> None : \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. plot_unit_cell (bool, optional): If True, overlays the unit cell grid on the lattice. Defaults to False. Behavior: - Plots all lattice points grouped by atom type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. - If `plot_unit_cell` is True, it overlays the unit cell using the lattice vectors `lv1` and `lv2`. Example: ```python >>> lattice = Lattice() >>> lattice.generate_points() >>> lattice.plot_lattice(plot_connections=True, plot_unit_cell=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. - The unit cell grid (if enabled) is displayed as dotted black lines with reduced opacity. \"\"\" # plt.figure(figsize=(8, 8)) for atom_type , atom_points in self . lattice_points . items (): x_coords = [ point [ 0 ] for point in atom_points ] y_coords = [ point [ 1 ] for point in atom_points ] plt . scatter ( x_coords , y_coords , s = 5 ) if plot_connections : for point in atom_points : for neighbor in self . neighbours [ atom_type ]: connection = point + np . array ( neighbor ) plt . plot ( [ point [ 0 ], connection [ 0 ]], [ point [ 1 ], connection [ 1 ]], \"r--\" , alpha = 0.5 , ) if plot_unit_cell : for i in range ( self . ny + 1 ): # line from (lv1*0 + lv2*i) to (lv1*nx + lv2*i) plt . plot ( [ self . lv1 [ 0 ] * 0 + self . lv2 [ 0 ] * i , self . lv1 [ 0 ] * self . nx + self . lv2 [ 0 ] * i ], [ self . lv1 [ 1 ] * 0 + self . lv2 [ 1 ] * i , self . lv1 [ 1 ] * self . nx + self . lv2 [ 1 ] * i ], \"k:\" , alpha = 0.3 , ) for i in range ( self . nx + 1 ): # line from (lv1*i + lv2*0) to (lv1*i + lv2*ny) plt . plot ( [ self . lv1 [ 0 ] * i + self . lv2 [ 0 ] * 0 , self . lv1 [ 0 ] * i + self . lv2 [ 0 ] * self . ny ], [ self . lv1 [ 1 ] * i + self . lv2 [ 1 ] * 0 , self . lv1 [ 1 ] * i + self . lv2 [ 1 ] * self . ny ], \"k:\" , alpha = 0.3 , ) plt . title ( \"Lattice Points\" ) plt . xlabel ( \"X Coordinate\" ) plt . ylabel ( \"Y Coordinate\" ) plt . axis ( \"equal\" )","title":"Layer"},{"location":"api/layers/#moirepy.layers.Layer.__init__","text":"Initializes the Layer object Parameters: pbc ( bool , default: False ) \u2013 Flag to indicate if periodic boundary conditions (PBC) are applied. Defaults to False. study_proximity ( int , default: 1 ) \u2013 Scaling factor for proximity calculations, enabiling the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers without complaining. Defaults to 1. Raises: ValueError \u2013 If lv1 is not along the x-axis or if lv2 has a negative y-component. Example: layer = Layer(pbc=True, study_proximity=2) Create a Layer object with PBC and study of second nearest neighbours Source code in moirepy/layers.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , pbc : bool = False , study_proximity : int = 1 ) -> None : \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. Defaults to False. study_proximity (int): Scaling factor for proximity calculations, **enabiling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers without complaining. Defaults to 1. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. Example: ```python layer = Layer(pbc=True, study_proximity=2) Create a Layer object with PBC and study of second nearest neighbours ``` \"\"\" self . toll_scale = max ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ) ) if self . lv1 [ 1 ] != 0 or self . lv2 [ 1 ] < 0 : raise ValueError ( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://example.com \"\"\" # @jabed add link to documentation we will write this ) self . rot_m = np . eye ( 2 ) self . pbc = pbc self . points = None self . kdtree = None self . study_proximity = study_proximity","title":"__init__"},{"location":"api/layers/#moirepy.layers.Layer._generate_mapping","text":"Generates a mapping between two sets of points (larger and smaller lattices) based on their positions and computes the distances between corresponding points. If the distance between a point in the larger lattice and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a ValueError and plots the lattice points for visualization. This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice. It stores the resulting mappings in the self.mappings dictionary, where keys are indices in self.bigger_points and values are the corresponding indices in self.points . Raises: ValueError \u2013 If the distance between a point and its nearest neighbor exceeds the tolerance defined by self.toll_scale . Example: my_lattice._generate_mapping() The function performs the following steps: 1. Initializes an empty dictionary self.mappings . 2. Uses a KDTree to query the neighbors for each point in the larger lattice ( self.bigger_points ). 3. Computes the translation needed for each point based on a lattice scaling factor. 4. If the distance between the corresponding points exceeds the tolerance, it raises a ValueError and plots the points. 5. Stores the index mappings of the larger lattice points to smaller lattice points in self.mappings . 6. The lattice plots show the parallelograms formed by mlv1 and mlv2 vectors for visualization. Note The function assumes self.points and self.bigger_points are defined as numpy arrays with the coordinates of the points in the lattices. The translations used in the function are calculated based on mln1 , mln2 , mlv1 , and mlv2 , which define the lattice scaling and vectors. Source code in moirepy/layers.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def _generate_mapping ( self ) -> None : \"\"\" Generates a mapping between two sets of points (larger and smaller lattices) based on their positions and computes the distances between corresponding points. If the distance between a point in the larger lattice and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots the lattice points for visualization. This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice. It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points` and values are the corresponding indices in `self.points`. Raises: ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`. Example: ```python my_lattice._generate_mapping() ``` The function performs the following steps: 1. Initializes an empty dictionary `self.mappings`. 2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`). 3. Computes the translation needed for each point based on a lattice scaling factor. 4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points. 5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`. 6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization. Note: - The function assumes `self.points` and `self.bigger_points` are defined as numpy arrays with the coordinates of the points in the lattices. - The translations used in the function are calculated based on `mln1`, `mln2`, `mlv1`, and `mlv2`, which define the lattice scaling and vectors. \"\"\" self . mappings = {} tree = KDTree ( self . points ) translations = self . _point_positions ( self . bigger_points , self . mln1 * self . mlv1 , self . mln2 * self . mlv2 ) for i , ( dx , dy ) in enumerate ( translations ): point = self . bigger_points [ i ] - ( dx * self . mlv1 * self . mln1 + dy * self . mlv2 * self . mln2 ) distance , index = tree . query ( point ) if distance >= self . toll_scale * 1e-3 : print ( f \"Distance { distance } exceeds tolerance for point { i } at location { point } with translation ( { dx } , { dy } ).\" ) plt . plot ( * self . bigger_points . T , \"ko\" , alpha = 0.3 ) plt . plot ( * self . points . T , \"k.\" ) # plt.plot(*self.bigger_points[i], \"b.\") # plt.plot(*point, \"r.\") # plt.plot(*self.points[index], \"g.\") # parallellogram around the whole lattice plt . plot ([ 0 , self . mln1 * self . mlv1 [ 0 ]], [ 0 , self . mln1 * self . mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , self . mln2 * self . mlv2 [ 0 ]], [ 0 , self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mln1 * self . mlv1 [ 0 ], self . mln1 * self . mlv1 [ 0 ] + self . mln2 * self . mlv2 [ 0 ]], [ self . mln1 * self . mlv1 [ 1 ], self . mln1 * self . mlv1 [ 1 ] + self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mln2 * self . mlv2 [ 0 ], self . mln1 * self . mlv1 [ 0 ] + self . mln2 * self . mlv2 [ 0 ]], [ self . mln2 * self . mlv2 [ 1 ], self . mln1 * self . mlv1 [ 1 ] + self . mln2 * self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) # just plot mlv1 and mlv2 parallellogram plt . plot ([ 0 , self . mlv1 [ 0 ]], [ 0 , self . mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , self . mlv2 [ 0 ]], [ 0 , self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mlv1 [ 0 ], self . mlv1 [ 0 ] + self . mlv2 [ 0 ]], [ self . mlv1 [ 1 ], self . mlv1 [ 1 ] + self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ self . mlv2 [ 0 ], self . mlv1 [ 0 ] + self . mlv2 [ 0 ]], [ self . mlv2 [ 1 ], self . mlv1 [ 1 ] + self . mlv2 [ 1 ]], 'k' , linewidth = 1 ) # for index, point in enumerate(self.bigger_points): # plt.text(*point, f\"{index}\", fontsize=6) plt . gca () . add_patch ( plt . Circle ( point , distance / 2 , color = 'r' , fill = False )) plt . grid () plt . show () raise ValueError ( f \"FATAL ERROR: Distance { distance } exceeds tolerance for point { i } at location { point } .\" ) self . mappings [ i ] = index","title":"_generate_mapping"},{"location":"api/layers/#moirepy.layers.Layer._inside_boundaries","text":"Determines if the given points lie within the boundaries of the Moir\u00e9 lattice pattern. Parameters: points ( ndarray ) \u2013 Array of points to check. mln1 ( int , default: None ) \u2013 The number of unit cells along the first direction. Defaults to the object's current value. mln2 ( int , default: None ) \u2013 The number of unit cells along the second direction. Defaults to the object's current value. Returns: ndarray \u2013 np.ndarray: A boolean array where True indicates that the point is within the boundaries of the lattice. Raises: ValueError \u2013 If the points array has an invalid shape. Example: points = np.array([[0.5, 0.5], [2, 2], [-1, -1]]) lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3) print(lattice_boundaries) Source code in moirepy/layers.py 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def _inside_boundaries ( self , points : np . ndarray , mln1 = None , mln2 = None ) -> np . ndarray : \"\"\" Determines if the given points lie within the boundaries of the Moir\u00e9 lattice pattern. Args: points (np.ndarray): Array of points to check. mln1 (int, optional): The number of unit cells along the first direction. Defaults to the object's current value. mln2 (int, optional): The number of unit cells along the second direction. Defaults to the object's current value. Returns: np.ndarray: A boolean array where True indicates that the point is within the boundaries of the lattice. Raises: ValueError: If the points array has an invalid shape. Example: ```python points = np.array([[0.5, 0.5], [2, 2], [-1, -1]]) lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3) print(lattice_boundaries) ``` \"\"\" v1 = ( mln1 if mln1 else self . mln1 ) * self . mlv1 v2 = ( mln2 if mln2 else self . mln2 ) * self . mlv2 p1 = np . array ([ 0 , 0 ]) p2 = np . array ([ v1 [ 0 ], v1 [ 1 ]]) p3 = np . array ([ v2 [ 0 ], v2 [ 1 ]]) p4 = np . array ([ v1 [ 0 ] + v2 [ 0 ], v1 [ 1 ] + v2 [ 1 ]]) return self . _inside_polygon ( points , np . array ([ p1 , p2 , p4 , p3 ]) - self . toll_scale * 1e-4 )","title":"_inside_boundaries"},{"location":"api/layers/#moirepy.layers.Layer._inside_polygon","text":"Determines if each point is inside a polygon using the ray-casting method. Parameters: points ( ndarray ) \u2013 Array of points to check. polygon ( ndarray ) \u2013 Vertices of the polygon to test against, in counterclockwise order. Returns: ndarray \u2013 np.ndarray: A boolean array where True indicates that the point is inside the polygon. Example: points = np.array([[0.5, 0.5], [1, 1], [-1, -1]]) polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]) inside = _inside_polygon(points, polygon) print(inside) Source code in moirepy/layers.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def _inside_polygon ( self , points : np . ndarray , polygon : np . ndarray ) -> np . ndarray : \"\"\" Determines if each point is inside a polygon using the ray-casting method. Args: points (np.ndarray): Array of points to check. polygon (np.ndarray): Vertices of the polygon to test against, in counterclockwise order. Returns: np.ndarray: A boolean array where True indicates that the point is inside the polygon. Example: ```python points = np.array([[0.5, 0.5], [1, 1], [-1, -1]]) polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]) inside = _inside_polygon(points, polygon) print(inside) ``` \"\"\" x , y = points [:, 0 ], points [:, 1 ] px , py = polygon [:, 0 ], polygon [:, 1 ] px_next , py_next = np . roll ( px , - 1 ), np . roll ( py , - 1 ) edge_cond = ( y [:, None ] > np . minimum ( py , py_next )) & ( y [:, None ] <= np . maximum ( py , py_next )) with np . errstate ( divide = 'ignore' , invalid = 'ignore' ): xinters = np . where ( py != py_next , ( y [:, None ] - py ) * ( px_next - px ) / ( py_next - py ) + px , np . inf ) ray_crosses = edge_cond & ( x [:, None ] <= xinters ) inside = np . sum ( ray_crosses , axis = 1 ) % 2 == 1 return inside # mask","title":"_inside_polygon"},{"location":"api/layers/#moirepy.layers.Layer._point_positions","text":"Determines the position of each point relative to a parallelogram defined by vectors A and B. Parameters: points ( ndarray ) \u2013 Array of points to be analyzed. A ( ndarray ) \u2013 The first vector of the parallelogram. B ( ndarray ) \u2013 The second vector of the parallelogram. Returns: ndarray \u2013 np.ndarray: An array indicating the position of each point: - (0, 0) for points inside the parallelogram. - (-1, 1) or (1, -1) for points outside on specific sides. left side and right side will give -1 and 1 respectively top side and bottom side will give -1 and 1 respectively Example: points = np.array([[0, 0], [1, 1], [-1, -1]]) A = np.array([1, 0]) B = np.array([0, 1]) positions = _point_positions(points, A, B) print(positions) Source code in moirepy/layers.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def _point_positions ( self , points : np . ndarray , A : np . ndarray , B : np . ndarray ) -> np . ndarray : \"\"\" Determines the position of each point relative to a parallelogram defined by vectors A and B. Args: points (np.ndarray): Array of points to be analyzed. A (np.ndarray): The first vector of the parallelogram. B (np.ndarray): The second vector of the parallelogram. Returns: np.ndarray: An array indicating the position of each point: - (0, 0) for points inside the parallelogram. - (-1, 1) or (1, -1) for points outside on specific sides. left side and right side will give -1 and 1 respectively top side and bottom side will give -1 and 1 respectively Example: ```python points = np.array([[0, 0], [1, 1], [-1, -1]]) A = np.array([1, 0]) B = np.array([0, 1]) positions = _point_positions(points, A, B) print(positions) ``` \"\"\" # Compute determinants for positions relative to OA and BC det_OA = ( points [:, 0 ] * A [ 1 ] - points [:, 1 ] * A [ 0 ]) <= self . toll_scale * 1e-2 det_BC = (( points [:, 0 ] - B [ 0 ]) * A [ 1 ] - ( points [:, 1 ] - B [ 1 ]) * A [ 0 ]) <= self . toll_scale * 1e-2 position_y = det_OA . astype ( float ) + det_BC . astype ( float ) # Compute determinants for positions relative to OB and AC det_OB = ( points [:, 0 ] * B [ 1 ] - points [:, 1 ] * B [ 0 ]) > - self . toll_scale * 1e-2 det_AC = (( points [:, 0 ] - A [ 0 ]) * B [ 1 ] - ( points [:, 1 ] - A [ 1 ]) * B [ 0 ]) > - self . toll_scale * 1e-2 position_x = det_OB . astype ( float ) + det_AC . astype ( float ) return np . column_stack (( position_x , position_y )) - 1","title":"_point_positions"},{"location":"api/layers/#moirepy.layers.Layer.first_nearest_neighbours","text":"Finds the first nearest neighbors for each point in the given array. Args: points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors. types (np.ndarray): An (N,) array of types corresponding to each point in `points`. Returns: tuple: A tuple containing: - distances_list (list): A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. - indices_list (list): A list of lists, where each inner list contains the indices of the nearest neighbors in `self.points`. Raises: AssertionError: If `self.kdtree` is not initialized. AssertionError: If the number of points does not match the number of types. ValueError: If a point type is not defined in `self.neighbours`. ValueError: If PBC is enabled and a distance exceeds the specified tolerance. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> types = np.array([0, 1]) >>> distances, indices = layer.first_nearest_neighbours(points, types) ``` Source code in moirepy/layers.py 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def first_nearest_neighbours ( self , points : np . ndarray , types : np . ndarray ): \"\"\" Finds the first nearest neighbors for each point in the given array. Args: points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors. types (np.ndarray): An (N,) array of types corresponding to each point in `points`. Returns: tuple: A tuple containing: - distances_list (list): A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. - indices_list (list): A list of lists, where each inner list contains the indices of the nearest neighbors in `self.points`. Raises: AssertionError: If `self.kdtree` is not initialized. AssertionError: If the number of points does not match the number of types. ValueError: If a point type is not defined in `self.neighbours`. ValueError: If PBC is enabled and a distance exceeds the specified tolerance. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> types = np.array([0, 1]) >>> distances, indices = layer.first_nearest_neighbours(points, types) ``` \"\"\" assert self . kdtree is not None , \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" assert points . shape [ 0 ] == types . shape [ 0 ], \"Mismatch between number of points and types.\" distances_list , indices_list = [], [] for point , t in zip ( points , types ): if t not in self . neighbours : raise ValueError ( f \"Point type ' { t } ' is not defined in self.neighbours.\" ) relative_neighbours = np . array ( self . neighbours [ t ]) absolute_neighbours = point + relative_neighbours distances , indices = self . kdtree . query ( absolute_neighbours , k = 1 ) filtered_distances , filtered_indices = [], [] for dist , idx in zip ( distances , indices ): if self . pbc : if dist > 1e-2 * self . toll_scale : raise ValueError ( f \"Distance { dist } exceeds tolerance.\" ) filtered_distances . append ( dist ) filtered_indices . append ( self . mappings [ idx ]) else : # if dist > 1e-2 * self.toll_scale: # raise ValueError(f\"Distance {dist} exceeds tolerance.\") filtered_distances . append ( dist ) filtered_indices . append ( idx ) distances_list . append ( filtered_distances ) indices_list . append ( filtered_indices ) return distances_list , indices_list","title":"first_nearest_neighbours"},{"location":"api/layers/#moirepy.layers.Layer.generate_kdtree","text":"Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all atoms). Returns: None ( None ) \u2013 The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError \u2013 If the points in the lattice are not defined. Example: lattice = MoireLattice() lattice.generate_kdtree() kdtree = lattice.kdtree print(kdtree) Source code in moirepy/layers.py 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 def generate_kdtree ( self ) -> None : \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all atoms). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. Example: ```python lattice = MoireLattice() lattice.generate_kdtree() kdtree = lattice.kdtree print(kdtree) ``` \"\"\" if not self . pbc : # OBC is easy self . kdtree = KDTree ( self . points ) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range ( - 1 , 2 ): for j in range ( - 1 , 2 ): all_points . append ( self . points + i * self . mln1 * self . mlv1 + j * self . mln2 * self . mlv2 ) all_point_names . append ( self . point_types ) all_points = np . vstack ( all_points ) all_point_names = np . hstack ( all_point_names ) v1 = self . mln1 * self . mlv1 v2 = self . mln2 * self . mlv2 neigh_pad_1 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv1 ) / np . linalg . norm ( v1 ) neigh_pad_2 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv2 ) / np . linalg . norm ( v2 ) mask = self . _inside_polygon ( all_points , np . array ([ ( - neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ( - neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ])) print ( mask . shape , mask . dtype ) points = all_points [ mask ] point_names = all_point_names [ mask ] self . bigger_points = points self . bigger_point_types = point_names self . kdtree = KDTree ( points ) # # plot the points but with colours based on the point_positions # # - point_positions = [0, 0] -> black # # - point_positions = [1, 0] -> red # # - do not plot the rest of the points at all # plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], 'k.') # plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], 'r.') # plt.plot(*all_points.T, \"ro\") # plt.plot(*points.T, \"b.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.grid() # plt.show() self . _generate_mapping ()","title":"generate_kdtree"},{"location":"api/layers/#moirepy.layers.Layer.generate_points","text":"Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Parameters: mlv1 ( array ) \u2013 The first Moir\u00e9 lattice vector. mlv2 ( array ) \u2013 The second Moir\u00e9 lattice vector. mln1 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. Returns: None ( None ) \u2013 The function modifies the object state and None \u2013 stores the generated points and their types. Raises: ValueError \u2013 If the number of unit cells is non-positive. Example: lattice = MoireLattice() lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=3, mln2=2) print(lattice.points) Source code in moirepy/layers.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def generate_points ( self , mlv1 : np . array , mlv2 : np . array , mln1 : int = 1 , mln2 : int = 1 , # bring_to_center = False ) -> None : \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.array): The first Moir\u00e9 lattice vector. mlv2 (np.array): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. Returns: None: The function modifies the object state and stores the generated points and their types. Raises: ValueError: If the number of unit cells is non-positive. Example: ```python lattice = MoireLattice() lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=3, mln2=2) print(lattice.points) ``` \"\"\" self . mlv1 = mlv1 # Moire lattice vector 1 self . mlv2 = mlv2 # Moire lattice vector 2 self . mln1 = mln1 # Number of moire unit cells along mlv1 self . mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the grid resolution points = [ np . array ([ 0 , 0 ]), mlv1 , mlv2 , mlv1 + mlv2 ] max_distance = max ( np . linalg . norm ( points [ 0 ] - points [ 1 ]), np . linalg . norm ( points [ 0 ] - points [ 2 ]), np . linalg . norm ( points [ 0 ] - points [ 3 ]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math . ceil ( max_distance / min ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range ( - n , n + 1 ): # Iterate along mlv1 for j in range ( - n , n + 1 ): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self . lv1 + j * self . lv2 for xpos , ypos , name in self . lattice_points : point = point_o + np . array ([ xpos , ypos ]) step1_points . append ( point ) step1_names . append ( name ) step1_points = np . array ( step1_points ) step1_names = np . array ( step1_names ) # Apply the boundary check method (inside_boundaries) to filter the points mask = self . _inside_boundaries ( step1_points , 1 , 1 ) step1_points = step1_points [ mask ] step1_names = step1_names [ mask ] # Step 3: Copy and translate the unit cell to create the full moire pattern points = [] # List to hold all the moire points names = [] for i in range ( self . mln1 ): # Translate along mlv1 direction for j in range ( self . mln2 ): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points . append ( translated_points ) names . append ( step1_names ) self . points = np . vstack ( points ) self . point_types = np . hstack ( names ) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") self . generate_kdtree ()","title":"generate_points"},{"location":"api/layers/#moirepy.layers.Layer.perform_rotation","text":"Rotates the lattice layer and its components by a specified angle. Parameters: rot ( float , default: None ) \u2013 The rotation angle in radians. Default to None . Returns: None ( None ) \u2013 The function modifies the rotation matrix None \u2013 and updates the lattice points and neighbors in place. Example: layer.perform_rotation(np.pi/4) Source code in moirepy/layers.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def perform_rotation ( self , rot = None ) -> None : \"\"\" Rotates the lattice layer and its components by a specified angle. Args: rot (float): The rotation angle in radians. Default to `None`. Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation(np.pi/4) ``` \"\"\" rot_m = get_rotation_matrix ( rot ) self . rot_m = rot_m # Rotate lv1 and lv2 vectors self . lv1 = rot_m @ self . lv1 self . lv2 = rot_m @ self . lv2 # Rotate lattice_points self . lattice_points = [ [ * ( rot_m @ np . array ([ x , y ])), atom_type ] for x , y , atom_type in self . lattice_points ] # Rotate neighbours self . neighbours = { atom_type : [ rot_m @ np . array ( neighbour ) for neighbour in neighbour_list ] for atom_type , neighbour_list in self . neighbours . items () }","title":"perform_rotation"},{"location":"api/layers/#moirepy.layers.Layer.plot_lattice","text":"Plots the lattice points and optionally the connections between them and the unit cell structure. Parameters: plot_connections ( bool , default: True ) \u2013 If True, plots the connections between nearest neighbors. Defaults to True. plot_unit_cell ( bool , default: False ) \u2013 If True, overlays the unit cell grid on the lattice. Defaults to False. Behavior Plots all lattice points grouped by atom type. If plot_connections is True, it draws dashed red lines between nearest neighbors. If plot_unit_cell is True, it overlays the unit cell using the lattice vectors lv1 and lv2 . Example: >>> lattice = Lattice() >>> lattice.generate_points() >>> lattice.plot_lattice(plot_connections=True, plot_unit_cell=True) Visualization Details Lattice points are plotted as small dots. Nearest neighbor connections (if enabled) are shown as dashed red lines. The unit cell grid (if enabled) is displayed as dotted black lines with reduced opacity. Source code in moirepy/layers.py 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 def plot_lattice ( self , plot_connections : bool = True , plot_unit_cell : bool = False ) -> None : \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. plot_unit_cell (bool, optional): If True, overlays the unit cell grid on the lattice. Defaults to False. Behavior: - Plots all lattice points grouped by atom type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. - If `plot_unit_cell` is True, it overlays the unit cell using the lattice vectors `lv1` and `lv2`. Example: ```python >>> lattice = Lattice() >>> lattice.generate_points() >>> lattice.plot_lattice(plot_connections=True, plot_unit_cell=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. - The unit cell grid (if enabled) is displayed as dotted black lines with reduced opacity. \"\"\" # plt.figure(figsize=(8, 8)) for atom_type , atom_points in self . lattice_points . items (): x_coords = [ point [ 0 ] for point in atom_points ] y_coords = [ point [ 1 ] for point in atom_points ] plt . scatter ( x_coords , y_coords , s = 5 ) if plot_connections : for point in atom_points : for neighbor in self . neighbours [ atom_type ]: connection = point + np . array ( neighbor ) plt . plot ( [ point [ 0 ], connection [ 0 ]], [ point [ 1 ], connection [ 1 ]], \"r--\" , alpha = 0.5 , ) if plot_unit_cell : for i in range ( self . ny + 1 ): # line from (lv1*0 + lv2*i) to (lv1*nx + lv2*i) plt . plot ( [ self . lv1 [ 0 ] * 0 + self . lv2 [ 0 ] * i , self . lv1 [ 0 ] * self . nx + self . lv2 [ 0 ] * i ], [ self . lv1 [ 1 ] * 0 + self . lv2 [ 1 ] * i , self . lv1 [ 1 ] * self . nx + self . lv2 [ 1 ] * i ], \"k:\" , alpha = 0.3 , ) for i in range ( self . nx + 1 ): # line from (lv1*i + lv2*0) to (lv1*i + lv2*ny) plt . plot ( [ self . lv1 [ 0 ] * i + self . lv2 [ 0 ] * 0 , self . lv1 [ 0 ] * i + self . lv2 [ 0 ] * self . ny ], [ self . lv1 [ 1 ] * i + self . lv2 [ 1 ] * 0 , self . lv1 [ 1 ] * i + self . lv2 [ 1 ] * self . ny ], \"k:\" , alpha = 0.3 , ) plt . title ( \"Lattice Points\" ) plt . xlabel ( \"X Coordinate\" ) plt . ylabel ( \"Y Coordinate\" ) plt . axis ( \"equal\" )","title":"plot_lattice"},{"location":"api/layers/#moirepy.layers.Layer.query","text":"Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Parameters: points ( ndarray ) \u2013 An (N, 2) array of points for which to find the nearest neighbors. k ( int , default: 1 ) \u2013 The number of nearest neighbors to query. Defaults to 1. Returns: Tuple [ ndarray , ndarray ] \u2013 Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in self.points . If PBC is enabled, the indices are remapped using self.mappings . Raises: AssertionError \u2013 If self.kdtree is not initialized. RuntimeError \u2013 If PBC is enabled and the mapping process fails. RuntimeError \u2013 If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior If self.pbc is False, the function returns the nearest neighbors as given by KDTree. If self.pbc is True, the function applies self.mappings to remap indices according to periodic boundary conditions. Example: >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query(points, k=2) Source code in moirepy/layers.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 def query ( self , points : np . ndarray , k : int = 1 ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query. Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Raises: AssertionError: If `self.kdtree` is not initialized. RuntimeError: If PBC is enabled and the mapping process fails. RuntimeError: If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior: - If `self.pbc` is False, the function returns the nearest neighbors as given by KDTree. - If `self.pbc` is True, the function applies `self.mappings` to remap indices according to periodic boundary conditions. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query(points, k=2) ``` \"\"\" # Step 1: # - get a normal query from KDTree # - distance, index = self.kdtree.query(points, k=k) # - remove all the points farther than (1+0.1*toll_scale) * min distance # - return here just that if OBC # Step 2: it will come here if PBC is True # - for all the points map them using self.mappings # - replace the indices with the mapped indices # - return the mapped indices and distances (distance will be the same) assert self . kdtree is not None , \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" distances , indices = self . kdtree . query ( points , k = k ) # for k=1, it returns squeezed arrays... so we need to unsqueeze them if k == 1 : distances = distances [:, None ] indices = indices [:, None ] distances_list , indices_list = distances . tolist (), indices . tolist () if k > 1 : # Set minimum distance threshold min_distance = distances [:, 1 ] . min () threshold = ( 1 + 1e-2 * self . toll_scale ) * min_distance # print(f\"{min_distance = }, {threshold = }\") # Filter distances and indices based on thresholds for i in range ( len ( distances_list )): while distances_list [ i ] and distances_list [ i ][ - 1 ] > threshold : distances_list [ i ] . pop () indices_list [ i ] . pop () if not self . pbc : return distances_list , indices_list # Convert lists back to numpy arrays for PBC try : distances = np . array ( distances_list ) indices = np . array ( indices_list ) except ValueError as e : raise RuntimeError ( \"FATAL ERROR: Uneven row lengths in PBC.\" ) from e # Apply mappings try : vectorized_fn = np . vectorize ( self . mappings . get ) remapped_indices = vectorized_fn ( indices ) except TypeError as e : raise RuntimeError ( \"FATAL ERROR: Mapping failed during vectorization. Check if all indices are valid.\" ) from e return distances , remapped_indices","title":"query"},{"location":"api/layers/#moirepy.layers.Layer.query_non_self","text":"Queries the KDTree for the k nearest neighbors of given points, excluding the point itself. Parameters: points ( ndarray ) \u2013 An (N, 2) array of points for which to find the nearest neighbors. k ( int , default: 1 ) \u2013 The number of nearest neighbors to query (excluding the point itself). Defaults to 1. Returns: Tuple [ ndarray , ndarray ] \u2013 Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in self.points . If PBC is enabled, the indices are remapped using self.mappings . Behavior Calls self.query(points, k=k+1) to get k+1 neighbors, including the point itself. Removes the first neighbor (which is the query point itself) from both distances and indices. If self.pbc is False, it processes the lists iteratively. If self.pbc is True, it slices the arrays to exclude the self-point. Example: >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query_non_self(points, k=2) Source code in moirepy/layers.py 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 def query_non_self ( self , points : np . ndarray , k : int = 1 ) -> Tuple [ np . ndarray , np . ndarray ]: \"\"\" Queries the KDTree for the k nearest neighbors of given points, excluding the point itself. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query (excluding the point itself). Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Behavior: - Calls `self.query(points, k=k+1)` to get `k+1` neighbors, including the point itself. - Removes the first neighbor (which is the query point itself) from both distances and indices. - If `self.pbc` is False, it processes the lists iteratively. - If `self.pbc` is True, it slices the arrays to exclude the self-point. Example: ```python >>> layer = Layer() >>> layer.generate_kdtree() >>> points = np.array([[0.5, 0.5], [1.0, 1.0]]) >>> distances, indices = layer.query_non_self(points, k=2) ``` \"\"\" distances , indices = self . query ( points , k = k + 1 ) if self . pbc is False : for i in range ( len ( indices )): indices [ i ] = indices [ i ][ 1 :] distances [ i ] = distances [ i ][ 1 :] else : indices = indices [:, 1 :] distances = distances [:, 1 :] # return distances[:, 1:], indices[:, 1:] return distances , indices","title":"query_non_self"},{"location":"api/moire/","text":"","title":"Moire"},{"location":"api/utils/","text":"get_rotation_matrix ( theta_rad ) Computes a 2D rotation matrix for a given angle. Parameters: theta_rad ( float ) \u2013 The rotation angle in radians. Returns: array \u2013 np.array: A 2x2 rotation matrix that rotates a point counterclockwise by theta_rad . >>> get_rotation_matrix(np.pi/2) array([[ 6.123234e-17, -1.000000e+00], [ 1.000000e+00, 6.123234e-17]]) Source code in moirepy/utils.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def get_rotation_matrix ( theta_rad : float ) -> np . array : \"\"\" Computes a 2D rotation matrix for a given angle. Args: theta_rad (float): The rotation angle in radians. Returns: np.array: A 2x2 rotation matrix that rotates a point counterclockwise by `theta_rad`. ```python >>> get_rotation_matrix(np.pi/2) array([[ 6.123234e-17, -1.000000e+00], [ 1.000000e+00, 6.123234e-17]]) ``` \"\"\" return np . array ( [ [ np . cos ( theta_rad ), - np . sin ( theta_rad )], [ np . sin ( theta_rad ), np . cos ( theta_rad )] ] )","title":"Utils"},{"location":"api/utils/#moirepy.utils.get_rotation_matrix","text":"Computes a 2D rotation matrix for a given angle. Parameters: theta_rad ( float ) \u2013 The rotation angle in radians. Returns: array \u2013 np.array: A 2x2 rotation matrix that rotates a point counterclockwise by theta_rad . >>> get_rotation_matrix(np.pi/2) array([[ 6.123234e-17, -1.000000e+00], [ 1.000000e+00, 6.123234e-17]]) Source code in moirepy/utils.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def get_rotation_matrix ( theta_rad : float ) -> np . array : \"\"\" Computes a 2D rotation matrix for a given angle. Args: theta_rad (float): The rotation angle in radians. Returns: np.array: A 2x2 rotation matrix that rotates a point counterclockwise by `theta_rad`. ```python >>> get_rotation_matrix(np.pi/2) array([[ 6.123234e-17, -1.000000e+00], [ 1.000000e+00, 6.123234e-17]]) ``` \"\"\" return np . array ( [ [ np . cos ( theta_rad ), - np . sin ( theta_rad )], [ np . sin ( theta_rad ), np . cos ( theta_rad )] ] )","title":"get_rotation_matrix"}]}