{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MoirePy: Twist It, Solve It, Own It! The moir\u00e9 effect is a fascinating visual phenomenon seen in modern art , textile patterns , and even currency anti-counterfeiting techniques , where overlapping periodic structures create intricate interference patterns. But beyond its aesthetic appeal, moir\u00e9 effect has taken centre stage in condensed matter physics , where geometry meets electronics, and simple twists unlock a playground of quantum phenomena. The discovery of emergent phenomena in moir\u00e9 materials \u2014such as superconductivity , correlated insulating states , and topological phases of matter has sparked a revolution in condensed matter physics. These systems, formed by stacking two-dimensional crystals at small twist angles, give rise to rich electronic landscapes governed by long-wavelength moir\u00e9 patterns. As the field rapidly expands, the need for intuitive, efficient, and high-precision computational tools has never been greater. MoirePy is an open source (free) Python package built to support the needs of researchers, theorists, computational and material scientists for the numerical calculation of moir\u00e9 lattices with a focus on commensurate structure. It enables fast, flexible atomistic simulations of commensurate moir\u00e9 lattices , with tools to compute dispersion relation , visualize band structures and density of states , study non-hermitian systems and explore quantum transport phenomena with precision and control. It can simulate metal , topological insulators , quantum hall effect, superconductivity, spintronics , or any combination. Documentation: https://jabed-umar.github.io/MoirePy/ Github Repository: https://github.com/jabed-umar/MoirePy PyPI page: https://pypi.org/project/moirepy/ Features Fast and efficient simulation of 2D bilayer moir\u00e9 lattices. Efficient \\(O(\\log n)\\) time nearest neighbour searches. supports custom lattice definitions with some basic predefined ones: Triangular Square Hexagonal Kagome both real and k-space Hamiltonian generation for tight-binding models with: Nearest-neighbour coupling Nth nearest-neighbour coupling Arbitrary number of orbitals per site All couplings can be real (default), or complex numbers. All couplings can be functions of position of the point(s) and the point type(s) (for example, different coupling for A-A, A-B, B-B sites for hexagonal lattices) Custom Intra and Interlayer Coupling Design. Web based tool makes it convenient to calculate lattice angles before simulation. Extensive Documentation and examples for easy onboarding. Compatible with other related libraries like Kwant (so that you can generate moire Hamiltonian and use it with Kwant for further analysis). Freedom to researcher: We allow you to define your layers and apply whatever couplings you want. If you want the lattice points to have 53 orbitals each\u2014sure, go ahead. As long as you know what you're doing, we won\u2019t stop you. We don't verify whether it's physically possible. Upcoming Features Support for higher-dimensional layers : Extend current 2D-only support to include higher dimensional constituent layers. Multi-layer stacking : Go beyond bilayers; enable simulation of trilayers and complex heterostructures. Non-equilibrium Green's function support (research in progress) : Develop tools for computing Green\u2019s functions efficiently to study non-equilibrium and quantum transport phenomena. <!--## Installation You can install MoirePy via pip: pip install moirepy ## Basic Usage For detailed usage, please refer to our documentation . from moirepy import MoireLattice # this i think we dont need as we have one dedicated installation page. #### u might add a line like cheek here (link inserted) to install the MoirePy ``` --> ## License This project is licensed under the [MIT License](https://opensource.org/licenses/MIT). [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT) ## Cite This Work If you use this software or a modified version in academic or scientific research, please cite: ```BibTeX @misc{MoirePy2025, author = {Aritra Mukhopadhyay, Jabed Umar}, title = {MoirePy: Python package for efficient atomistic simulation of moir\u00e9 lattices}, year = {2025}, url = {https://jabed-umar.github.io/MoirePy/}, }","title":"Home"},{"location":"#moirepy-twist-it-solve-it-own-it","text":"The moir\u00e9 effect is a fascinating visual phenomenon seen in modern art , textile patterns , and even currency anti-counterfeiting techniques , where overlapping periodic structures create intricate interference patterns. But beyond its aesthetic appeal, moir\u00e9 effect has taken centre stage in condensed matter physics , where geometry meets electronics, and simple twists unlock a playground of quantum phenomena. The discovery of emergent phenomena in moir\u00e9 materials \u2014such as superconductivity , correlated insulating states , and topological phases of matter has sparked a revolution in condensed matter physics. These systems, formed by stacking two-dimensional crystals at small twist angles, give rise to rich electronic landscapes governed by long-wavelength moir\u00e9 patterns. As the field rapidly expands, the need for intuitive, efficient, and high-precision computational tools has never been greater. MoirePy is an open source (free) Python package built to support the needs of researchers, theorists, computational and material scientists for the numerical calculation of moir\u00e9 lattices with a focus on commensurate structure. It enables fast, flexible atomistic simulations of commensurate moir\u00e9 lattices , with tools to compute dispersion relation , visualize band structures and density of states , study non-hermitian systems and explore quantum transport phenomena with precision and control. It can simulate metal , topological insulators , quantum hall effect, superconductivity, spintronics , or any combination. Documentation: https://jabed-umar.github.io/MoirePy/ Github Repository: https://github.com/jabed-umar/MoirePy PyPI page: https://pypi.org/project/moirepy/","title":"MoirePy: Twist It, Solve It, Own It!"},{"location":"#features","text":"Fast and efficient simulation of 2D bilayer moir\u00e9 lattices. Efficient \\(O(\\log n)\\) time nearest neighbour searches. supports custom lattice definitions with some basic predefined ones: Triangular Square Hexagonal Kagome both real and k-space Hamiltonian generation for tight-binding models with: Nearest-neighbour coupling Nth nearest-neighbour coupling Arbitrary number of orbitals per site All couplings can be real (default), or complex numbers. All couplings can be functions of position of the point(s) and the point type(s) (for example, different coupling for A-A, A-B, B-B sites for hexagonal lattices) Custom Intra and Interlayer Coupling Design. Web based tool makes it convenient to calculate lattice angles before simulation. Extensive Documentation and examples for easy onboarding. Compatible with other related libraries like Kwant (so that you can generate moire Hamiltonian and use it with Kwant for further analysis). Freedom to researcher: We allow you to define your layers and apply whatever couplings you want. If you want the lattice points to have 53 orbitals each\u2014sure, go ahead. As long as you know what you're doing, we won\u2019t stop you. We don't verify whether it's physically possible.","title":"Features"},{"location":"#upcoming-features","text":"Support for higher-dimensional layers : Extend current 2D-only support to include higher dimensional constituent layers. Multi-layer stacking : Go beyond bilayers; enable simulation of trilayers and complex heterostructures. Non-equilibrium Green's function support (research in progress) : Develop tools for computing Green\u2019s functions efficiently to study non-equilibrium and quantum transport phenomena. <!--## Installation You can install MoirePy via pip: pip install moirepy ## Basic Usage For detailed usage, please refer to our documentation . from moirepy import MoireLattice # this i think we dont need as we have one dedicated installation page. #### u might add a line like cheek here (link inserted) to install the MoirePy ``` --> ## License This project is licensed under the [MIT License](https://opensource.org/licenses/MIT). [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT) ## Cite This Work If you use this software or a modified version in academic or scientific research, please cite: ```BibTeX @misc{MoirePy2025, author = {Aritra Mukhopadhyay, Jabed Umar}, title = {MoirePy: Python package for efficient atomistic simulation of moir\u00e9 lattices}, year = {2025}, url = {https://jabed-umar.github.io/MoirePy/}, }","title":"Upcoming Features"},{"location":"examples/","text":"table.examples-table { table-layout: fixed !important; width: 100% !important; border-collapse: collapse; } table.examples-table th.examples-table-topic, table.examples-table td.examples-table-topic { min-width: 10px !important; max-width: 600px !important; } table.examples-table th.examples-table-links, table.examples-table td.examples-table-links { width: 130px !important; } table.examples-table th, table.examples-table td { overflow-wrap: break-word !important; word-break: break-word !important; white-space: normal !important; } Learning Moire Physics Through Examples Here are a couple of examples to help you get started with Moire physics: Topic Links K-Space Hamiltonian: An example of a Hamiltonian in k-space. Github | Colab Tight Binding Hamiltonian: An example of a tight binding Hamiltonian. Github | Colab Density of States Calculation: An example of a density of states calculation. Github | Colab","title":"EXAMPLE NOTEBOOKS"},{"location":"examples/#learning-moire-physics-through-examples","text":"Here are a couple of examples to help you get started with Moire physics: Topic Links K-Space Hamiltonian: An example of a Hamiltonian in k-space. Github | Colab Tight Binding Hamiltonian: An example of a tight binding Hamiltonian. Github | Colab Density of States Calculation: An example of a density of states calculation. Github | Colab","title":"Learning Moire Physics Through Examples"},{"location":"api/layers/","text":"Layer Source code in moirepy/layers.py class Layer: # parent class def __init__(self, pbc: bool=False, study_proximity: int=1) -> None: \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity (int): Scaling factor for proximity calculations, **enabling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. \"\"\" required_attrs = [\"lv1\", \"lv2\", \"lattice_points\", \"neighbours\"] for attr in required_attrs: if not hasattr(self, attr): raise NotImplementedError(f\"Subclass {self.__class__.__name__} must define '{attr}'\") self.toll_scale = max( np.linalg.norm(self.lv1), np.linalg.norm(self.lv2) ) if self.lv1[1] != 0 or self.lv2[1] < 0: raise ValueError( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://jabed-umar.github.io/MoirePy/find_theta/ \"\"\" ) self.rot_m = np.eye(2) # will be replaced if called perform_rotation self.pbc = pbc self.points = None self.kdtree = None self.study_proximity = study_proximity self.lattice_angle = np.arccos(np.dot(self.lv1, self.lv2) / (np.linalg.norm(self.lv1) * np.linalg.norm(self.lv2))) def perform_rotation_translation(self, rot:float, translation:Tuple[float, float]=(0, 0)) -> None: \"\"\" Rotates and translates the lattice layer and its components. Has to be applied before point generation. Args: rot (float): The rotation angle in radians. Default to `None`. translation (Tuple[float, float]): The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation_translation(np.pi/4, (1, 1)) ``` \"\"\" assert self.points is None, \"Cannot perform rotation and translation after points have been generated.\" rot_m = get_rotation_matrix(rot) self.rot_m = rot_m # Rotate lv1 and lv2 vectors self.lv1 = rot_m @ self.lv1 self.lv2 = rot_m @ self.lv2 # Rotate lattice_points self.lattice_points = [ [*(rot_m @ (np.array([x, y]) + np.array(translation))), point_type] for x, y, point_type in self.lattice_points ] # Rotate neighbours self.neighbours = { point_type: [rot_m @ np.array(neighbour) for neighbour in neighbour_list] for point_type, neighbour_list in self.neighbours.items() } def generate_points( self, mlv1: np.ndarray, mlv2: np.ndarray, mln1: int = 1, mln2: int = 1, test: bool = False, ) -> None: \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.ndarray): The first Moir\u00e9 lattice vector. mlv2 (np.ndarray): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test (bool, optional): If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None: The function modifies the object state and stores the generated points and their types. Raises: AssersionError: If mln1 and mln2 are not positive integers. AssersionError: if test is True and mln1 or mln2 is not 1 Example: ```python >>> lattice = MyLattice() # a class inheriting the Layer class >>> lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1) >>> print(lattice.points) ``` \"\"\" # raise the promised errors: assert isinstance(mln1, int) and mln1 > 0, \"mln1 must be a positive integer.\" assert isinstance(mln2, int) and mln2 > 0, \"mln2 must be a positive integer.\" if test: assert mln1 == 1 and mln2 == 1, \"If test is True, both mln1 and mln2 must be 1.\" self.mlv1 = mlv1 # Moire lattice vector 1 self.mlv2 = mlv2 # Moire lattice vector 2 self.mln1 = mln1 # Number of moire unit cells along mlv1 self.mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the number of points along each direction points = [np.array([0, 0]), mlv1, mlv2, mlv1 + mlv2] max_distance = max( np.linalg.norm(points[0] - points[1]), np.linalg.norm(points[0] - points[2]), np.linalg.norm(points[0] - points[3]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math.ceil(max_distance / min(np.linalg.norm(self.lv1), np.linalg.norm(self.lv2))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range(-n, n + 1): # Iterate along mlv1 for j in range(-n, n + 1): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self.lv1 + j * self.lv2 for xpos, ypos, name in self.lattice_points: point = point_o + np.array([xpos, ypos]) step1_points.append(point) step1_names.append(name) step1_points = np.array(step1_points) step1_names = np.array(step1_names) # Apply the boundary check method (inside_boundaries) to filter the points mask = self._inside_boundaries(step1_points, 1, 1) # generating points only inside the first cell now step1_points = step1_points[mask] step1_names = step1_names[mask] # Step 3: Copy and translate the unit cell to create the full lattice points = [] # List to hold all the moire points names = [] for i in range(self.mln1): # Translate along mlv1 direction for j in range(self.mln2): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points.append(translated_points) names.append(step1_names) self.points = np.vstack(points) self.point_types = np.hstack(names) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") if not test: self.generate_kdtree() def _point_positions(self, points: np.ndarray, A: np.ndarray, B: np.ndarray) -> np.ndarray: \"\"\" Determines the position of each point relative to a parallelogram defined by vectors A and B. Args: points (np.ndarray): Array of points to be analyzed. A (np.ndarray): The first vector of the parallelogram. B (np.ndarray): The second vector of the parallelogram. Returns: np.ndarray: An array indicating the position of each point: - (0, 0) for points inside the parallelogram. - (-1, 1) or (1, -1) for points outside on specific sides. left side and right side will give -1 and 1 respectively top side and bottom side will give -1 and 1 respectively \"\"\" # Compute determinants for positions relative to OA and BC det_OA = (points[:, 0] * A[1] - points[:, 1] * A[0]) <= self.toll_scale * 1e-2 det_BC = ((points[:, 0] - B[0]) * A[1] - (points[:, 1] - B[1]) * A[0]) <= self.toll_scale * 1e-2 position_y = det_OA.astype(float) + det_BC.astype(float) # Compute determinants for positions relative to OB and AC det_OB = (points[:, 0] * B[1] - points[:, 1] * B[0]) > -self.toll_scale * 1e-2 det_AC = ((points[:, 0] - A[0]) * B[1] - (points[:, 1] - A[1]) * B[0]) > -self.toll_scale * 1e-2 position_x = det_OB.astype(float) + det_AC.astype(float) return np.column_stack((position_x, position_y)) - 1 def _inside_polygon(self, points: np.ndarray, polygon: np.ndarray) -> np.ndarray: \"\"\" Determines if each point is inside a polygon using the ray-casting method. Args: points (np.ndarray): Array of points to check. polygon (np.ndarray): Vertices of the polygon to test against, in counterclockwise order. Returns: np.ndarray: A boolean array where True indicates that the point is inside the polygon. Example: ```python points = np.array([[0.5, 0.5], [1, 1], [-1, -1]]) polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]) inside = _inside_polygon(points, polygon) print(inside) ``` \"\"\" x, y = points[:, 0], points[:, 1] px, py = polygon[:, 0], polygon[:, 1] px_next, py_next = np.roll(px, -1), np.roll(py, -1) edge_cond = (y[:, None] > np.minimum(py, py_next)) & (y[:, None] <= np.maximum(py, py_next)) with np.errstate(divide='ignore', invalid='ignore'): xinters = np.where(py != py_next, (y[:, None] - py) * (px_next - px) / (py_next - py) + px, np.inf) ray_crosses = edge_cond & (x[:, None] <= xinters) inside = np.sum(ray_crosses, axis=1) % 2 == 1 return inside # mask def _inside_boundaries(self, points: np.ndarray, mln1=None, mln2=None) -> np.ndarray: \"\"\" Determines if the given points lie within the boundaries of the Moir\u00e9 lattice pattern. Args: points (np.ndarray): Array of points to check. mln1 (int, optional): The number of unit cells along the first direction. Defaults to the object's current value. mln2 (int, optional): The number of unit cells along the second direction. Defaults to the object's current value. Returns: np.ndarray: A boolean array where True indicates that the point is within the boundaries of the lattice. Raises: ValueError: If the points array has an invalid shape. Example: ```python points = np.array([[0.5, 0.5], [2, 2], [-1, -1]]) lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3) print(lattice_boundaries) ``` \"\"\" v1 = (mln1 if mln1 else self.mln1) * self.mlv1 v2 = (mln2 if mln2 else self.mln2) * self.mlv2 p1 = np.array([0, 0]) p2 = np.array([v1[0], v1[1]]) p3 = np.array([v2[0], v2[1]]) p4 = np.array([v1[0] + v2[0], v1[1] + v2[1]]) shift_dir = -(v1 + v2) shift_dir = shift_dir / np.linalg.norm(shift_dir) # normalize shift = shift_dir * self.toll_scale * 1e-4 return self._inside_polygon( points, np.array([p1, p2, p4, p3]) + shift ) def generate_kdtree(self) -> None: \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. \"\"\" if not self.pbc: # OBC is easy self.kdtree = KDTree(self.points) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range(-1, 2): for j in range(-1, 2): all_points.append(self.points + i * self.mln1 * self.mlv1 + j * self.mln2 * self.mlv2) all_point_names.append(self.point_types) all_points = np.vstack(all_points) all_point_names = np.hstack(all_point_names) v1 = self.mln1 * self.mlv1 v2 = self.mln2 * self.mlv2 neigh_pad_1 = (1 + self.study_proximity) * np.linalg.norm(self.lv1) / np.linalg.norm(v1) neigh_pad_2 = (1 + self.study_proximity) * np.linalg.norm(self.lv2) / np.linalg.norm(v2) mask = self._inside_polygon(all_points, np.array([ (-neigh_pad_1) * v1 + (-neigh_pad_2) * v2, (1 + neigh_pad_1) * v1 + (-neigh_pad_2) * v2, (1 + neigh_pad_1) * v1 + (1 + neigh_pad_2) * v2, (-neigh_pad_1) * v1 + (1 + neigh_pad_2) * v2, ])) # print(mask.shape, mask.dtype) points = all_points[mask] point_names = all_point_names[mask] self.bigger_points = points self.bigger_point_types = point_names self.kdtree = KDTree(points) self._generate_mapping() # # plot the points but with colours based on the point_positions # # - point_positions = [0, 0] -> black # # - point_positions = [1, 0] -> red # # - do not plot the rest of the points at all # plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], 'k.') # plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], 'r.') # plt.plot(*all_points.T, \"ro\") # plt.plot(*points.T, \"b.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.grid() # plt.show() def _generate_mapping(self) -> None: \"\"\" Generates a mapping between two sets of points (larger and smaller lattices) based on their positions and computes the distances between corresponding points. If the distance between a point in the larger lattice and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots the lattice points for visualization. This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice. It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points` and values are the corresponding indices in `self.points`. Raises: ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`. Example: ```python my_lattice._generate_mapping() ``` The function performs the following steps: 1. Initializes an empty dictionary `self.mappings`. 2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`). 3. Computes the translation needed for each point based on a lattice scaling factor. 4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points. 5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`. 6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization. Note: - The function assumes `self.points` and `self.bigger_points` are defined as numpy arrays with the coordinates of the points in the lattices. - The translations used in the function are calculated based on `mln1`, `mln2`, `mlv1`, and `mlv2`, which define the lattice scaling and vectors. \"\"\" self.mappings = {} tree = KDTree(self.points) # smaller set translations = self._point_positions( self.bigger_points, self.mln1 * self.mlv1, self.mln2 * self.mlv2 ) for i, (dx, dy) in enumerate(translations): mapped_point = self.bigger_points[i] - (dx * self.mlv1 * self.mln1 + dy * self.mlv2 * self.mln2) distance, index = tree.query(mapped_point) if distance >= self.toll_scale * 1e-3: # print(f\"Distance {distance} exceeds tolerance for {i}th point {self.bigger_points[i]} mapped at location {mapped_point} with translation ({dx}, {dy}).\") # plt.plot(*self.bigger_points.T, \"ko\", alpha=0.3) # plt.plot(*self.points.T, \"k.\") # # plt.plot(*self.bigger_points[i], \"b.\") # # plt.plot(*mapped_point, \"r.\") # # plt.plot(*self.points[index], \"g.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1 * self.mlv1[0]], [0, self.mln1 * self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2 * self.mlv2[0]], [0, self.mln2 * self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1 * self.mlv1[0], self.mln1 * self.mlv1[0] + self.mln2 * self.mlv2[0]], [self.mln1 * self.mlv1[1], self.mln1 * self.mlv1[1] + self.mln2 * self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2 * self.mlv2[0], self.mln1 * self.mlv1[0] + self.mln2 * self.mlv2[0]], [self.mln2 * self.mlv2[1], self.mln1 * self.mlv1[1] + self.mln2 * self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self. mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # # for index, mapped_point in enumerate(self.bigger_points): # # plt.text(*mapped_point, f\"{index}\", fontsize=6) # plt.gca().add_patch(plt.Circle(mapped_point, distance / 2, color='r', fill=False)) # plt.grid() # plt.show() raise ValueError(f\"FATAL ERROR: Distance {distance} exceeds tolerance for {i}th point {self.bigger_points[i]} mapped at location {mapped_point} with translation ({dx}, {dy}).\") self.mappings[i] = index # point positions... for each point in self.point, point position is a array of length 2 (x, y) # where the elemnts are -1, 0 and 1... this is what their value mean about their position # (-1, 1) | (0, 1) | (1, 1) # ----------------------------- # (-1, 0) | (0, 0) | (1, 0) # ----------------------------- # (-1,-1) | (0,-1) | (1,-1) # ----------------------------- # (0, 0) is our actual lattice part... # do this for all points in self.bigger_points: # all point with point_positions = (x, y) need to be translated by # (-x*self.mlv1*self.mln1 - y*self.mlv2*self.mln2) to get the corresponding point inside the lattice # then you would need to run a query on a newly kdtree of the smaller points... # to the get the index of the corresponding point inside the lattice (distance should be zero, just saying) # now we already know the index of the point in the self.bigger_points... so we can map that to the index of the point in the self.points # then we will store that in `self.mappings`` # self.mapppings will be a dictionary with keys as the indices in the # self.bigger_points (unique) and values as the indices in the self.points (not unique) # def kth_nearest_neighbours(self, points, types, k = 1) -> None: # distance_matrix = self.kdtree.sparse_distance_matrix(self.kdtree, k) def first_nearest_neighbours(self, points: np.ndarray, types: np.ndarray): \"\"\" Finds the first nearest neighbors for each point in the given array. Args: points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors. types (np.ndarray): An (N,) array of types corresponding to each point in `points`. Returns: distances (list): A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. indices (list): A list of lists, where each inner list contains the indices of the nearest neighbors in `self.points`. Raises: AssertionError: If `self.kdtree` is not initialized. AssertionError: If the number of points does not match the number of types. ValueError: If a point type is not defined in `self.neighbours`. ValueError: If PBC is enabled and a distance exceeds the specified tolerance. Example: ```python layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) types = np.array([0, 1]) distances, indices = layer.first_nearest_neighbours(points, types) ``` \"\"\" assert self.kdtree is not None, \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" assert points.shape[0] == types.shape[0], \"Mismatch between number of points and types.\" bigger_indices_all, smaller_indices_all, smaller_distances_all = [], [], [] for point, t in zip(points, types): if t not in self.neighbours: raise ValueError(f\"Point type '{t}' is not defined in self.neighbours.\") relative_neighbours = np.array(self.neighbours[t]) absolute_neighbours = point + relative_neighbours distances, indices = self.kdtree.query(absolute_neighbours, k=1) bigger_indices, smaller_distances, smaller_indices = [], [], [] for dist, idx in zip(distances, indices): if self.pbc: if dist > 1e-2 * self.toll_scale: raise ValueError(f\"Distance {dist} exceeds tolerance.\") bigger_indices.append(idx) smaller_indices.append(self.mappings[idx]) smaller_distances.append(dist) else: # if dist > 1e-2 * self.toll_scale: # raise ValueError(f\"Distance {dist} exceeds tolerance.\") bigger_indices.append(idx) smaller_indices.append(idx) smaller_distances.append(dist) bigger_indices_all.append(bigger_indices) smaller_indices_all.append(smaller_indices) smaller_distances_all.append(smaller_distances) return bigger_indices_all, smaller_indices_all, smaller_distances_all def query_one(self, points: np.ndarray) -> Tuple[np.ndarray, np.ndarray]: \"\"\" Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query. Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Raises: AssertionError: If `self.kdtree` is not initialized. RuntimeError: If PBC is enabled and the mapping process fails. RuntimeError: If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior: - If `self.pbc` is False, the function returns the nearest neighbors as given by KDTree. - If `self.pbc` is True, the function applies `self.mappings` to remap indices according to periodic boundary conditions. Example: ```python layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) distances, indices = layer.query(points, k=2) ``` \"\"\" # Step 1: # - get a normal query from KDTree # - distance, index = self.kdtree.query(points, k=k) # - remove all the points farther than (1+0.1*toll_scale) * min distance # - return here just that if OBC # Step 2: it will come here if PBC is True # - for all the points map them using self.mappings # - replace the indices with the mapped indices # - return the mapped indices and distances (distance will be the same) assert self.kdtree is not None, \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" distances, indices = self.kdtree.query(points, k=[1]) # for k=1, it returns squeezed arrays... so we need to unsqueeze them # distances = distances[:, None] # indices = indices[:, None] if not self.pbc: return indices, indices, distances try: vectorized_fn = np.vectorize(self.mappings.get) remapped_indices = vectorized_fn(indices) except TypeError as e: raise RuntimeError(\"FATAL ERROR: Mapping failed during vectorization. Check if all indices are valid.\") from e return indices, remapped_indices, distances # def query_non_self(self, points: np.ndarray, k: int = 1) -> Tuple[np.ndarray, np.ndarray]: # \"\"\" # Queries the KDTree for the k nearest neighbors of given points, excluding the point itself. # Args: # points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. # k (int, optional): The number of nearest neighbors to query (excluding the point itself). # Defaults to 1. # Returns: # Tuple[np.ndarray, np.ndarray]: # - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. # - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors # in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. # Behavior: # - Calls `self.query(points, k=k+1)` to get `k+1` neighbors, including the point itself. # - Removes the first neighbor (which is the query point itself) from both distances and indices. # - If `self.pbc` is False, it processes the lists iteratively. # - If `self.pbc` is True, it slices the arrays to exclude the self-point. # Example: # ```python # layer = Layer() # layer.generate_kdtree() # points = np.array([[0.5, 0.5], [1.0, 1.0]]) # distances, indices = layer.query_non_self(points, k=2) # ``` # \"\"\" # distances, indices = self.query(points, k=k + 1) # if self.pbc is False: # for i in range(len(indices)): # indices[i] = indices[i][1:] # distances[i] = distances[i][1:] # else: # indices = indices[:, 1:] # distances = distances[:, 1:] # # return distances[:, 1:], indices[:, 1:] # return distances, indices def plot_lattice(self, plot_connections: bool = True, colours:list=[\"r\", \"g\", \"b\", \"c\", \"m\", \"y\", \"k\"]) -> None: \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. colours (list, optional): List of matplotlib colours to use for different point types. Behavior: - Plots all lattice points grouped by type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. Example: ```python lattice = MyLattice() lattice.generate_points() lattice.plot_lattice(plot_connections=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. \"\"\" if len(colours) == 1: cols = {t[-1]:colours[0] for i, t, in enumerate(self.lattice_points)} else: cols = {t[-1]:colours[i] for i, t, in enumerate(self.lattice_points)} plt.scatter( [self.points[:, 0]], [self.points[:, 1]], s=10, c=np.vectorize(cols.get)(self.point_types) ) if plot_connections: a = [] for this, point_type in zip(self.points, self.point_types): for delta in self.neighbours[point_type]: a.append([this[0], this[0] + delta[0]]) a.append((this[1], this[1] + delta[1])) a.append(\"k--\") # a = a[:30] # print(a) plt.plot(*a, alpha=0.1) plt.title(\"Lattice Points\") plt.xlabel(\"X Coordinate\") plt.ylabel(\"Y Coordinate\") plt.axis(\"equal\") def __repr__(self): return ( f\"\"\"Layer( lv1 = {self.lv1}, lv2 = {self.lv2}, lattice_points = {self.lattice_points}, study_proximity = {self.study_proximity}, pbc = {self.pbc}, )\"\"\" ) __init__(pbc=False, study_proximity=1) Initializes the Layer object Parameters: pbc ( bool , default: False ) \u2013 Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity ( int , default: 1 ) \u2013 Scaling factor for proximity calculations, enabling the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError \u2013 If lv1 is not along the x-axis or if lv2 has a negative y-component. Source code in moirepy/layers.py def __init__(self, pbc: bool=False, study_proximity: int=1) -> None: \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity (int): Scaling factor for proximity calculations, **enabling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. \"\"\" required_attrs = [\"lv1\", \"lv2\", \"lattice_points\", \"neighbours\"] for attr in required_attrs: if not hasattr(self, attr): raise NotImplementedError(f\"Subclass {self.__class__.__name__} must define '{attr}'\") self.toll_scale = max( np.linalg.norm(self.lv1), np.linalg.norm(self.lv2) ) if self.lv1[1] != 0 or self.lv2[1] < 0: raise ValueError( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://jabed-umar.github.io/MoirePy/find_theta/ \"\"\" ) self.rot_m = np.eye(2) # will be replaced if called perform_rotation self.pbc = pbc self.points = None self.kdtree = None self.study_proximity = study_proximity self.lattice_angle = np.arccos(np.dot(self.lv1, self.lv2) / (np.linalg.norm(self.lv1) * np.linalg.norm(self.lv2))) first_nearest_neighbours(points, types) Finds the first nearest neighbors for each point in the given array. Parameters: points ( ndarray ) \u2013 An (N, 2) array of N points for which to find nearest neighbors. types ( ndarray ) \u2013 An (N,) array of types corresponding to each point in points . Returns: distances ( list ) \u2013 A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. indices ( list ) \u2013 A list of lists, where each inner list contains the indices of the nearest neighbors in self.points . Raises: AssertionError \u2013 If self.kdtree is not initialized. AssertionError \u2013 If the number of points does not match the number of types. ValueError \u2013 If a point type is not defined in self.neighbours . ValueError \u2013 If PBC is enabled and a distance exceeds the specified tolerance. Example: layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) types = np.array([0, 1]) distances, indices = layer.first_nearest_neighbours(points, types) Source code in moirepy/layers.py def first_nearest_neighbours(self, points: np.ndarray, types: np.ndarray): \"\"\" Finds the first nearest neighbors for each point in the given array. Args: points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors. types (np.ndarray): An (N,) array of types corresponding to each point in `points`. Returns: distances (list): A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. indices (list): A list of lists, where each inner list contains the indices of the nearest neighbors in `self.points`. Raises: AssertionError: If `self.kdtree` is not initialized. AssertionError: If the number of points does not match the number of types. ValueError: If a point type is not defined in `self.neighbours`. ValueError: If PBC is enabled and a distance exceeds the specified tolerance. Example: ```python layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) types = np.array([0, 1]) distances, indices = layer.first_nearest_neighbours(points, types) ``` \"\"\" assert self.kdtree is not None, \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" assert points.shape[0] == types.shape[0], \"Mismatch between number of points and types.\" bigger_indices_all, smaller_indices_all, smaller_distances_all = [], [], [] for point, t in zip(points, types): if t not in self.neighbours: raise ValueError(f\"Point type '{t}' is not defined in self.neighbours.\") relative_neighbours = np.array(self.neighbours[t]) absolute_neighbours = point + relative_neighbours distances, indices = self.kdtree.query(absolute_neighbours, k=1) bigger_indices, smaller_distances, smaller_indices = [], [], [] for dist, idx in zip(distances, indices): if self.pbc: if dist > 1e-2 * self.toll_scale: raise ValueError(f\"Distance {dist} exceeds tolerance.\") bigger_indices.append(idx) smaller_indices.append(self.mappings[idx]) smaller_distances.append(dist) else: # if dist > 1e-2 * self.toll_scale: # raise ValueError(f\"Distance {dist} exceeds tolerance.\") bigger_indices.append(idx) smaller_indices.append(idx) smaller_distances.append(dist) bigger_indices_all.append(bigger_indices) smaller_indices_all.append(smaller_indices) smaller_distances_all.append(smaller_distances) return bigger_indices_all, smaller_indices_all, smaller_distances_all generate_kdtree() Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None ( None ) \u2013 The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError \u2013 If the points in the lattice are not defined. Source code in moirepy/layers.py def generate_kdtree(self) -> None: \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. \"\"\" if not self.pbc: # OBC is easy self.kdtree = KDTree(self.points) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range(-1, 2): for j in range(-1, 2): all_points.append(self.points + i * self.mln1 * self.mlv1 + j * self.mln2 * self.mlv2) all_point_names.append(self.point_types) all_points = np.vstack(all_points) all_point_names = np.hstack(all_point_names) v1 = self.mln1 * self.mlv1 v2 = self.mln2 * self.mlv2 neigh_pad_1 = (1 + self.study_proximity) * np.linalg.norm(self.lv1) / np.linalg.norm(v1) neigh_pad_2 = (1 + self.study_proximity) * np.linalg.norm(self.lv2) / np.linalg.norm(v2) mask = self._inside_polygon(all_points, np.array([ (-neigh_pad_1) * v1 + (-neigh_pad_2) * v2, (1 + neigh_pad_1) * v1 + (-neigh_pad_2) * v2, (1 + neigh_pad_1) * v1 + (1 + neigh_pad_2) * v2, (-neigh_pad_1) * v1 + (1 + neigh_pad_2) * v2, ])) # print(mask.shape, mask.dtype) points = all_points[mask] point_names = all_point_names[mask] self.bigger_points = points self.bigger_point_types = point_names self.kdtree = KDTree(points) self._generate_mapping() generate_points(mlv1, mlv2, mln1=1, mln2=1, test=False) Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Parameters: mlv1 ( ndarray ) \u2013 The first Moir\u00e9 lattice vector. mlv2 ( ndarray ) \u2013 The second Moir\u00e9 lattice vector. mln1 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test ( bool , default: False ) \u2013 If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None ( None ) \u2013 The function modifies the object state and None \u2013 stores the generated points and their types. Raises: AssersionError \u2013 If mln1 and mln2 are not positive integers. AssersionError \u2013 if test is True and mln1 or mln2 is not 1 Example: >>> lattice = MyLattice() # a class inheriting the Layer class >>> lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1) >>> print(lattice.points) Source code in moirepy/layers.py def generate_points( self, mlv1: np.ndarray, mlv2: np.ndarray, mln1: int = 1, mln2: int = 1, test: bool = False, ) -> None: \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.ndarray): The first Moir\u00e9 lattice vector. mlv2 (np.ndarray): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test (bool, optional): If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None: The function modifies the object state and stores the generated points and their types. Raises: AssersionError: If mln1 and mln2 are not positive integers. AssersionError: if test is True and mln1 or mln2 is not 1 Example: ```python >>> lattice = MyLattice() # a class inheriting the Layer class >>> lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1) >>> print(lattice.points) ``` \"\"\" # raise the promised errors: assert isinstance(mln1, int) and mln1 > 0, \"mln1 must be a positive integer.\" assert isinstance(mln2, int) and mln2 > 0, \"mln2 must be a positive integer.\" if test: assert mln1 == 1 and mln2 == 1, \"If test is True, both mln1 and mln2 must be 1.\" self.mlv1 = mlv1 # Moire lattice vector 1 self.mlv2 = mlv2 # Moire lattice vector 2 self.mln1 = mln1 # Number of moire unit cells along mlv1 self.mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the number of points along each direction points = [np.array([0, 0]), mlv1, mlv2, mlv1 + mlv2] max_distance = max( np.linalg.norm(points[0] - points[1]), np.linalg.norm(points[0] - points[2]), np.linalg.norm(points[0] - points[3]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math.ceil(max_distance / min(np.linalg.norm(self.lv1), np.linalg.norm(self.lv2))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range(-n, n + 1): # Iterate along mlv1 for j in range(-n, n + 1): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self.lv1 + j * self.lv2 for xpos, ypos, name in self.lattice_points: point = point_o + np.array([xpos, ypos]) step1_points.append(point) step1_names.append(name) step1_points = np.array(step1_points) step1_names = np.array(step1_names) # Apply the boundary check method (inside_boundaries) to filter the points mask = self._inside_boundaries(step1_points, 1, 1) # generating points only inside the first cell now step1_points = step1_points[mask] step1_names = step1_names[mask] # Step 3: Copy and translate the unit cell to create the full lattice points = [] # List to hold all the moire points names = [] for i in range(self.mln1): # Translate along mlv1 direction for j in range(self.mln2): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points.append(translated_points) names.append(step1_names) self.points = np.vstack(points) self.point_types = np.hstack(names) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") if not test: self.generate_kdtree() perform_rotation_translation(rot, translation=(0, 0)) Rotates and translates the lattice layer and its components. Has to be applied before point generation. Parameters: rot ( float ) \u2013 The rotation angle in radians. Default to None . translation ( Tuple [ float , float ] , default: (0, 0) ) \u2013 The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None ( None ) \u2013 The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: layer.perform_rotation_translation(np.pi/4, (1, 1)) Source code in moirepy/layers.py def perform_rotation_translation(self, rot:float, translation:Tuple[float, float]=(0, 0)) -> None: \"\"\" Rotates and translates the lattice layer and its components. Has to be applied before point generation. Args: rot (float): The rotation angle in radians. Default to `None`. translation (Tuple[float, float]): The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation_translation(np.pi/4, (1, 1)) ``` \"\"\" assert self.points is None, \"Cannot perform rotation and translation after points have been generated.\" rot_m = get_rotation_matrix(rot) self.rot_m = rot_m # Rotate lv1 and lv2 vectors self.lv1 = rot_m @ self.lv1 self.lv2 = rot_m @ self.lv2 # Rotate lattice_points self.lattice_points = [ [*(rot_m @ (np.array([x, y]) + np.array(translation))), point_type] for x, y, point_type in self.lattice_points ] # Rotate neighbours self.neighbours = { point_type: [rot_m @ np.array(neighbour) for neighbour in neighbour_list] for point_type, neighbour_list in self.neighbours.items() } plot_lattice(plot_connections=True, colours=['r', 'g', 'b', 'c', 'm', 'y', 'k']) Plots the lattice points and optionally the connections between them and the unit cell structure. Parameters: plot_connections ( bool , default: True ) \u2013 If True, plots the connections between nearest neighbors. Defaults to True. colours ( list , default: ['r', 'g', 'b', 'c', 'm', 'y', 'k'] ) \u2013 List of matplotlib colours to use for different point types. Behavior Plots all lattice points grouped by type. If plot_connections is True, it draws dashed red lines between nearest neighbors. Example: lattice = MyLattice() lattice.generate_points() lattice.plot_lattice(plot_connections=True) Visualization Details Lattice points are plotted as small dots. Nearest neighbor connections (if enabled) are shown as dashed red lines. Source code in moirepy/layers.py def plot_lattice(self, plot_connections: bool = True, colours:list=[\"r\", \"g\", \"b\", \"c\", \"m\", \"y\", \"k\"]) -> None: \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. colours (list, optional): List of matplotlib colours to use for different point types. Behavior: - Plots all lattice points grouped by type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. Example: ```python lattice = MyLattice() lattice.generate_points() lattice.plot_lattice(plot_connections=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. \"\"\" if len(colours) == 1: cols = {t[-1]:colours[0] for i, t, in enumerate(self.lattice_points)} else: cols = {t[-1]:colours[i] for i, t, in enumerate(self.lattice_points)} plt.scatter( [self.points[:, 0]], [self.points[:, 1]], s=10, c=np.vectorize(cols.get)(self.point_types) ) if plot_connections: a = [] for this, point_type in zip(self.points, self.point_types): for delta in self.neighbours[point_type]: a.append([this[0], this[0] + delta[0]]) a.append((this[1], this[1] + delta[1])) a.append(\"k--\") # a = a[:30] # print(a) plt.plot(*a, alpha=0.1) plt.title(\"Lattice Points\") plt.xlabel(\"X Coordinate\") plt.ylabel(\"Y Coordinate\") plt.axis(\"equal\") query_one(points) Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Parameters: points ( ndarray ) \u2013 An (N, 2) array of points for which to find the nearest neighbors. k ( int ) \u2013 The number of nearest neighbors to query. Defaults to 1. Returns: Tuple [ ndarray , ndarray ] \u2013 Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in self.points . If PBC is enabled, the indices are remapped using self.mappings . Raises: AssertionError \u2013 If self.kdtree is not initialized. RuntimeError \u2013 If PBC is enabled and the mapping process fails. RuntimeError \u2013 If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior If self.pbc is False, the function returns the nearest neighbors as given by KDTree. If self.pbc is True, the function applies self.mappings to remap indices according to periodic boundary conditions. Example: layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) distances, indices = layer.query(points, k=2) Source code in moirepy/layers.py def query_one(self, points: np.ndarray) -> Tuple[np.ndarray, np.ndarray]: \"\"\" Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query. Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Raises: AssertionError: If `self.kdtree` is not initialized. RuntimeError: If PBC is enabled and the mapping process fails. RuntimeError: If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior: - If `self.pbc` is False, the function returns the nearest neighbors as given by KDTree. - If `self.pbc` is True, the function applies `self.mappings` to remap indices according to periodic boundary conditions. Example: ```python layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) distances, indices = layer.query(points, k=2) ``` \"\"\" # Step 1: # - get a normal query from KDTree # - distance, index = self.kdtree.query(points, k=k) # - remove all the points farther than (1+0.1*toll_scale) * min distance # - return here just that if OBC # Step 2: it will come here if PBC is True # - for all the points map them using self.mappings # - replace the indices with the mapped indices # - return the mapped indices and distances (distance will be the same) assert self.kdtree is not None, \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" distances, indices = self.kdtree.query(points, k=[1]) # for k=1, it returns squeezed arrays... so we need to unsqueeze them # distances = distances[:, None] # indices = indices[:, None] if not self.pbc: return indices, indices, distances try: vectorized_fn = np.vectorize(self.mappings.get) remapped_indices = vectorized_fn(indices) except TypeError as e: raise RuntimeError(\"FATAL ERROR: Mapping failed during vectorization. Check if all indices are valid.\") from e return indices, remapped_indices, distances","title":"Layers"},{"location":"api/layers/#moirepy.layers.Layer","text":"Source code in moirepy/layers.py class Layer: # parent class def __init__(self, pbc: bool=False, study_proximity: int=1) -> None: \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity (int): Scaling factor for proximity calculations, **enabling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. \"\"\" required_attrs = [\"lv1\", \"lv2\", \"lattice_points\", \"neighbours\"] for attr in required_attrs: if not hasattr(self, attr): raise NotImplementedError(f\"Subclass {self.__class__.__name__} must define '{attr}'\") self.toll_scale = max( np.linalg.norm(self.lv1), np.linalg.norm(self.lv2) ) if self.lv1[1] != 0 or self.lv2[1] < 0: raise ValueError( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://jabed-umar.github.io/MoirePy/find_theta/ \"\"\" ) self.rot_m = np.eye(2) # will be replaced if called perform_rotation self.pbc = pbc self.points = None self.kdtree = None self.study_proximity = study_proximity self.lattice_angle = np.arccos(np.dot(self.lv1, self.lv2) / (np.linalg.norm(self.lv1) * np.linalg.norm(self.lv2))) def perform_rotation_translation(self, rot:float, translation:Tuple[float, float]=(0, 0)) -> None: \"\"\" Rotates and translates the lattice layer and its components. Has to be applied before point generation. Args: rot (float): The rotation angle in radians. Default to `None`. translation (Tuple[float, float]): The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation_translation(np.pi/4, (1, 1)) ``` \"\"\" assert self.points is None, \"Cannot perform rotation and translation after points have been generated.\" rot_m = get_rotation_matrix(rot) self.rot_m = rot_m # Rotate lv1 and lv2 vectors self.lv1 = rot_m @ self.lv1 self.lv2 = rot_m @ self.lv2 # Rotate lattice_points self.lattice_points = [ [*(rot_m @ (np.array([x, y]) + np.array(translation))), point_type] for x, y, point_type in self.lattice_points ] # Rotate neighbours self.neighbours = { point_type: [rot_m @ np.array(neighbour) for neighbour in neighbour_list] for point_type, neighbour_list in self.neighbours.items() } def generate_points( self, mlv1: np.ndarray, mlv2: np.ndarray, mln1: int = 1, mln2: int = 1, test: bool = False, ) -> None: \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.ndarray): The first Moir\u00e9 lattice vector. mlv2 (np.ndarray): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test (bool, optional): If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None: The function modifies the object state and stores the generated points and their types. Raises: AssersionError: If mln1 and mln2 are not positive integers. AssersionError: if test is True and mln1 or mln2 is not 1 Example: ```python >>> lattice = MyLattice() # a class inheriting the Layer class >>> lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1) >>> print(lattice.points) ``` \"\"\" # raise the promised errors: assert isinstance(mln1, int) and mln1 > 0, \"mln1 must be a positive integer.\" assert isinstance(mln2, int) and mln2 > 0, \"mln2 must be a positive integer.\" if test: assert mln1 == 1 and mln2 == 1, \"If test is True, both mln1 and mln2 must be 1.\" self.mlv1 = mlv1 # Moire lattice vector 1 self.mlv2 = mlv2 # Moire lattice vector 2 self.mln1 = mln1 # Number of moire unit cells along mlv1 self.mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the number of points along each direction points = [np.array([0, 0]), mlv1, mlv2, mlv1 + mlv2] max_distance = max( np.linalg.norm(points[0] - points[1]), np.linalg.norm(points[0] - points[2]), np.linalg.norm(points[0] - points[3]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math.ceil(max_distance / min(np.linalg.norm(self.lv1), np.linalg.norm(self.lv2))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range(-n, n + 1): # Iterate along mlv1 for j in range(-n, n + 1): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self.lv1 + j * self.lv2 for xpos, ypos, name in self.lattice_points: point = point_o + np.array([xpos, ypos]) step1_points.append(point) step1_names.append(name) step1_points = np.array(step1_points) step1_names = np.array(step1_names) # Apply the boundary check method (inside_boundaries) to filter the points mask = self._inside_boundaries(step1_points, 1, 1) # generating points only inside the first cell now step1_points = step1_points[mask] step1_names = step1_names[mask] # Step 3: Copy and translate the unit cell to create the full lattice points = [] # List to hold all the moire points names = [] for i in range(self.mln1): # Translate along mlv1 direction for j in range(self.mln2): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points.append(translated_points) names.append(step1_names) self.points = np.vstack(points) self.point_types = np.hstack(names) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") if not test: self.generate_kdtree() def _point_positions(self, points: np.ndarray, A: np.ndarray, B: np.ndarray) -> np.ndarray: \"\"\" Determines the position of each point relative to a parallelogram defined by vectors A and B. Args: points (np.ndarray): Array of points to be analyzed. A (np.ndarray): The first vector of the parallelogram. B (np.ndarray): The second vector of the parallelogram. Returns: np.ndarray: An array indicating the position of each point: - (0, 0) for points inside the parallelogram. - (-1, 1) or (1, -1) for points outside on specific sides. left side and right side will give -1 and 1 respectively top side and bottom side will give -1 and 1 respectively \"\"\" # Compute determinants for positions relative to OA and BC det_OA = (points[:, 0] * A[1] - points[:, 1] * A[0]) <= self.toll_scale * 1e-2 det_BC = ((points[:, 0] - B[0]) * A[1] - (points[:, 1] - B[1]) * A[0]) <= self.toll_scale * 1e-2 position_y = det_OA.astype(float) + det_BC.astype(float) # Compute determinants for positions relative to OB and AC det_OB = (points[:, 0] * B[1] - points[:, 1] * B[0]) > -self.toll_scale * 1e-2 det_AC = ((points[:, 0] - A[0]) * B[1] - (points[:, 1] - A[1]) * B[0]) > -self.toll_scale * 1e-2 position_x = det_OB.astype(float) + det_AC.astype(float) return np.column_stack((position_x, position_y)) - 1 def _inside_polygon(self, points: np.ndarray, polygon: np.ndarray) -> np.ndarray: \"\"\" Determines if each point is inside a polygon using the ray-casting method. Args: points (np.ndarray): Array of points to check. polygon (np.ndarray): Vertices of the polygon to test against, in counterclockwise order. Returns: np.ndarray: A boolean array where True indicates that the point is inside the polygon. Example: ```python points = np.array([[0.5, 0.5], [1, 1], [-1, -1]]) polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]) inside = _inside_polygon(points, polygon) print(inside) ``` \"\"\" x, y = points[:, 0], points[:, 1] px, py = polygon[:, 0], polygon[:, 1] px_next, py_next = np.roll(px, -1), np.roll(py, -1) edge_cond = (y[:, None] > np.minimum(py, py_next)) & (y[:, None] <= np.maximum(py, py_next)) with np.errstate(divide='ignore', invalid='ignore'): xinters = np.where(py != py_next, (y[:, None] - py) * (px_next - px) / (py_next - py) + px, np.inf) ray_crosses = edge_cond & (x[:, None] <= xinters) inside = np.sum(ray_crosses, axis=1) % 2 == 1 return inside # mask def _inside_boundaries(self, points: np.ndarray, mln1=None, mln2=None) -> np.ndarray: \"\"\" Determines if the given points lie within the boundaries of the Moir\u00e9 lattice pattern. Args: points (np.ndarray): Array of points to check. mln1 (int, optional): The number of unit cells along the first direction. Defaults to the object's current value. mln2 (int, optional): The number of unit cells along the second direction. Defaults to the object's current value. Returns: np.ndarray: A boolean array where True indicates that the point is within the boundaries of the lattice. Raises: ValueError: If the points array has an invalid shape. Example: ```python points = np.array([[0.5, 0.5], [2, 2], [-1, -1]]) lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3) print(lattice_boundaries) ``` \"\"\" v1 = (mln1 if mln1 else self.mln1) * self.mlv1 v2 = (mln2 if mln2 else self.mln2) * self.mlv2 p1 = np.array([0, 0]) p2 = np.array([v1[0], v1[1]]) p3 = np.array([v2[0], v2[1]]) p4 = np.array([v1[0] + v2[0], v1[1] + v2[1]]) shift_dir = -(v1 + v2) shift_dir = shift_dir / np.linalg.norm(shift_dir) # normalize shift = shift_dir * self.toll_scale * 1e-4 return self._inside_polygon( points, np.array([p1, p2, p4, p3]) + shift ) def generate_kdtree(self) -> None: \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. \"\"\" if not self.pbc: # OBC is easy self.kdtree = KDTree(self.points) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range(-1, 2): for j in range(-1, 2): all_points.append(self.points + i * self.mln1 * self.mlv1 + j * self.mln2 * self.mlv2) all_point_names.append(self.point_types) all_points = np.vstack(all_points) all_point_names = np.hstack(all_point_names) v1 = self.mln1 * self.mlv1 v2 = self.mln2 * self.mlv2 neigh_pad_1 = (1 + self.study_proximity) * np.linalg.norm(self.lv1) / np.linalg.norm(v1) neigh_pad_2 = (1 + self.study_proximity) * np.linalg.norm(self.lv2) / np.linalg.norm(v2) mask = self._inside_polygon(all_points, np.array([ (-neigh_pad_1) * v1 + (-neigh_pad_2) * v2, (1 + neigh_pad_1) * v1 + (-neigh_pad_2) * v2, (1 + neigh_pad_1) * v1 + (1 + neigh_pad_2) * v2, (-neigh_pad_1) * v1 + (1 + neigh_pad_2) * v2, ])) # print(mask.shape, mask.dtype) points = all_points[mask] point_names = all_point_names[mask] self.bigger_points = points self.bigger_point_types = point_names self.kdtree = KDTree(points) self._generate_mapping() # # plot the points but with colours based on the point_positions # # - point_positions = [0, 0] -> black # # - point_positions = [1, 0] -> red # # - do not plot the rest of the points at all # plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], 'k.') # plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], 'r.') # plt.plot(*all_points.T, \"ro\") # plt.plot(*points.T, \"b.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.grid() # plt.show() def _generate_mapping(self) -> None: \"\"\" Generates a mapping between two sets of points (larger and smaller lattices) based on their positions and computes the distances between corresponding points. If the distance between a point in the larger lattice and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots the lattice points for visualization. This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice. It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points` and values are the corresponding indices in `self.points`. Raises: ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`. Example: ```python my_lattice._generate_mapping() ``` The function performs the following steps: 1. Initializes an empty dictionary `self.mappings`. 2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`). 3. Computes the translation needed for each point based on a lattice scaling factor. 4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points. 5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`. 6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization. Note: - The function assumes `self.points` and `self.bigger_points` are defined as numpy arrays with the coordinates of the points in the lattices. - The translations used in the function are calculated based on `mln1`, `mln2`, `mlv1`, and `mlv2`, which define the lattice scaling and vectors. \"\"\" self.mappings = {} tree = KDTree(self.points) # smaller set translations = self._point_positions( self.bigger_points, self.mln1 * self.mlv1, self.mln2 * self.mlv2 ) for i, (dx, dy) in enumerate(translations): mapped_point = self.bigger_points[i] - (dx * self.mlv1 * self.mln1 + dy * self.mlv2 * self.mln2) distance, index = tree.query(mapped_point) if distance >= self.toll_scale * 1e-3: # print(f\"Distance {distance} exceeds tolerance for {i}th point {self.bigger_points[i]} mapped at location {mapped_point} with translation ({dx}, {dy}).\") # plt.plot(*self.bigger_points.T, \"ko\", alpha=0.3) # plt.plot(*self.points.T, \"k.\") # # plt.plot(*self.bigger_points[i], \"b.\") # # plt.plot(*mapped_point, \"r.\") # # plt.plot(*self.points[index], \"g.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1 * self.mlv1[0]], [0, self.mln1 * self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2 * self.mlv2[0]], [0, self.mln2 * self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1 * self.mlv1[0], self.mln1 * self.mlv1[0] + self.mln2 * self.mlv2[0]], [self.mln1 * self.mlv1[1], self.mln1 * self.mlv1[1] + self.mln2 * self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2 * self.mlv2[0], self.mln1 * self.mlv1[0] + self.mln2 * self.mlv2[0]], [self.mln2 * self.mlv2[1], self.mln1 * self.mlv1[1] + self.mln2 * self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self. mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # # for index, mapped_point in enumerate(self.bigger_points): # # plt.text(*mapped_point, f\"{index}\", fontsize=6) # plt.gca().add_patch(plt.Circle(mapped_point, distance / 2, color='r', fill=False)) # plt.grid() # plt.show() raise ValueError(f\"FATAL ERROR: Distance {distance} exceeds tolerance for {i}th point {self.bigger_points[i]} mapped at location {mapped_point} with translation ({dx}, {dy}).\") self.mappings[i] = index # point positions... for each point in self.point, point position is a array of length 2 (x, y) # where the elemnts are -1, 0 and 1... this is what their value mean about their position # (-1, 1) | (0, 1) | (1, 1) # ----------------------------- # (-1, 0) | (0, 0) | (1, 0) # ----------------------------- # (-1,-1) | (0,-1) | (1,-1) # ----------------------------- # (0, 0) is our actual lattice part... # do this for all points in self.bigger_points: # all point with point_positions = (x, y) need to be translated by # (-x*self.mlv1*self.mln1 - y*self.mlv2*self.mln2) to get the corresponding point inside the lattice # then you would need to run a query on a newly kdtree of the smaller points... # to the get the index of the corresponding point inside the lattice (distance should be zero, just saying) # now we already know the index of the point in the self.bigger_points... so we can map that to the index of the point in the self.points # then we will store that in `self.mappings`` # self.mapppings will be a dictionary with keys as the indices in the # self.bigger_points (unique) and values as the indices in the self.points (not unique) # def kth_nearest_neighbours(self, points, types, k = 1) -> None: # distance_matrix = self.kdtree.sparse_distance_matrix(self.kdtree, k) def first_nearest_neighbours(self, points: np.ndarray, types: np.ndarray): \"\"\" Finds the first nearest neighbors for each point in the given array. Args: points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors. types (np.ndarray): An (N,) array of types corresponding to each point in `points`. Returns: distances (list): A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. indices (list): A list of lists, where each inner list contains the indices of the nearest neighbors in `self.points`. Raises: AssertionError: If `self.kdtree` is not initialized. AssertionError: If the number of points does not match the number of types. ValueError: If a point type is not defined in `self.neighbours`. ValueError: If PBC is enabled and a distance exceeds the specified tolerance. Example: ```python layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) types = np.array([0, 1]) distances, indices = layer.first_nearest_neighbours(points, types) ``` \"\"\" assert self.kdtree is not None, \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" assert points.shape[0] == types.shape[0], \"Mismatch between number of points and types.\" bigger_indices_all, smaller_indices_all, smaller_distances_all = [], [], [] for point, t in zip(points, types): if t not in self.neighbours: raise ValueError(f\"Point type '{t}' is not defined in self.neighbours.\") relative_neighbours = np.array(self.neighbours[t]) absolute_neighbours = point + relative_neighbours distances, indices = self.kdtree.query(absolute_neighbours, k=1) bigger_indices, smaller_distances, smaller_indices = [], [], [] for dist, idx in zip(distances, indices): if self.pbc: if dist > 1e-2 * self.toll_scale: raise ValueError(f\"Distance {dist} exceeds tolerance.\") bigger_indices.append(idx) smaller_indices.append(self.mappings[idx]) smaller_distances.append(dist) else: # if dist > 1e-2 * self.toll_scale: # raise ValueError(f\"Distance {dist} exceeds tolerance.\") bigger_indices.append(idx) smaller_indices.append(idx) smaller_distances.append(dist) bigger_indices_all.append(bigger_indices) smaller_indices_all.append(smaller_indices) smaller_distances_all.append(smaller_distances) return bigger_indices_all, smaller_indices_all, smaller_distances_all def query_one(self, points: np.ndarray) -> Tuple[np.ndarray, np.ndarray]: \"\"\" Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query. Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Raises: AssertionError: If `self.kdtree` is not initialized. RuntimeError: If PBC is enabled and the mapping process fails. RuntimeError: If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior: - If `self.pbc` is False, the function returns the nearest neighbors as given by KDTree. - If `self.pbc` is True, the function applies `self.mappings` to remap indices according to periodic boundary conditions. Example: ```python layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) distances, indices = layer.query(points, k=2) ``` \"\"\" # Step 1: # - get a normal query from KDTree # - distance, index = self.kdtree.query(points, k=k) # - remove all the points farther than (1+0.1*toll_scale) * min distance # - return here just that if OBC # Step 2: it will come here if PBC is True # - for all the points map them using self.mappings # - replace the indices with the mapped indices # - return the mapped indices and distances (distance will be the same) assert self.kdtree is not None, \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" distances, indices = self.kdtree.query(points, k=[1]) # for k=1, it returns squeezed arrays... so we need to unsqueeze them # distances = distances[:, None] # indices = indices[:, None] if not self.pbc: return indices, indices, distances try: vectorized_fn = np.vectorize(self.mappings.get) remapped_indices = vectorized_fn(indices) except TypeError as e: raise RuntimeError(\"FATAL ERROR: Mapping failed during vectorization. Check if all indices are valid.\") from e return indices, remapped_indices, distances # def query_non_self(self, points: np.ndarray, k: int = 1) -> Tuple[np.ndarray, np.ndarray]: # \"\"\" # Queries the KDTree for the k nearest neighbors of given points, excluding the point itself. # Args: # points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. # k (int, optional): The number of nearest neighbors to query (excluding the point itself). # Defaults to 1. # Returns: # Tuple[np.ndarray, np.ndarray]: # - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. # - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors # in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. # Behavior: # - Calls `self.query(points, k=k+1)` to get `k+1` neighbors, including the point itself. # - Removes the first neighbor (which is the query point itself) from both distances and indices. # - If `self.pbc` is False, it processes the lists iteratively. # - If `self.pbc` is True, it slices the arrays to exclude the self-point. # Example: # ```python # layer = Layer() # layer.generate_kdtree() # points = np.array([[0.5, 0.5], [1.0, 1.0]]) # distances, indices = layer.query_non_self(points, k=2) # ``` # \"\"\" # distances, indices = self.query(points, k=k + 1) # if self.pbc is False: # for i in range(len(indices)): # indices[i] = indices[i][1:] # distances[i] = distances[i][1:] # else: # indices = indices[:, 1:] # distances = distances[:, 1:] # # return distances[:, 1:], indices[:, 1:] # return distances, indices def plot_lattice(self, plot_connections: bool = True, colours:list=[\"r\", \"g\", \"b\", \"c\", \"m\", \"y\", \"k\"]) -> None: \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. colours (list, optional): List of matplotlib colours to use for different point types. Behavior: - Plots all lattice points grouped by type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. Example: ```python lattice = MyLattice() lattice.generate_points() lattice.plot_lattice(plot_connections=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. \"\"\" if len(colours) == 1: cols = {t[-1]:colours[0] for i, t, in enumerate(self.lattice_points)} else: cols = {t[-1]:colours[i] for i, t, in enumerate(self.lattice_points)} plt.scatter( [self.points[:, 0]], [self.points[:, 1]], s=10, c=np.vectorize(cols.get)(self.point_types) ) if plot_connections: a = [] for this, point_type in zip(self.points, self.point_types): for delta in self.neighbours[point_type]: a.append([this[0], this[0] + delta[0]]) a.append((this[1], this[1] + delta[1])) a.append(\"k--\") # a = a[:30] # print(a) plt.plot(*a, alpha=0.1) plt.title(\"Lattice Points\") plt.xlabel(\"X Coordinate\") plt.ylabel(\"Y Coordinate\") plt.axis(\"equal\") def __repr__(self): return ( f\"\"\"Layer( lv1 = {self.lv1}, lv2 = {self.lv2}, lattice_points = {self.lattice_points}, study_proximity = {self.study_proximity}, pbc = {self.pbc}, )\"\"\" )","title":"Layer"},{"location":"api/layers/#moirepy.layers.Layer.__init__","text":"Initializes the Layer object Parameters: pbc ( bool , default: False ) \u2013 Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity ( int , default: 1 ) \u2013 Scaling factor for proximity calculations, enabling the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError \u2013 If lv1 is not along the x-axis or if lv2 has a negative y-component. Source code in moirepy/layers.py def __init__(self, pbc: bool=False, study_proximity: int=1) -> None: \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity (int): Scaling factor for proximity calculations, **enabling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. \"\"\" required_attrs = [\"lv1\", \"lv2\", \"lattice_points\", \"neighbours\"] for attr in required_attrs: if not hasattr(self, attr): raise NotImplementedError(f\"Subclass {self.__class__.__name__} must define '{attr}'\") self.toll_scale = max( np.linalg.norm(self.lv1), np.linalg.norm(self.lv2) ) if self.lv1[1] != 0 or self.lv2[1] < 0: raise ValueError( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://jabed-umar.github.io/MoirePy/find_theta/ \"\"\" ) self.rot_m = np.eye(2) # will be replaced if called perform_rotation self.pbc = pbc self.points = None self.kdtree = None self.study_proximity = study_proximity self.lattice_angle = np.arccos(np.dot(self.lv1, self.lv2) / (np.linalg.norm(self.lv1) * np.linalg.norm(self.lv2)))","title":"__init__"},{"location":"api/layers/#moirepy.layers.Layer.first_nearest_neighbours","text":"Finds the first nearest neighbors for each point in the given array. Parameters: points ( ndarray ) \u2013 An (N, 2) array of N points for which to find nearest neighbors. types ( ndarray ) \u2013 An (N,) array of types corresponding to each point in points . Returns: distances ( list ) \u2013 A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. indices ( list ) \u2013 A list of lists, where each inner list contains the indices of the nearest neighbors in self.points . Raises: AssertionError \u2013 If self.kdtree is not initialized. AssertionError \u2013 If the number of points does not match the number of types. ValueError \u2013 If a point type is not defined in self.neighbours . ValueError \u2013 If PBC is enabled and a distance exceeds the specified tolerance. Example: layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) types = np.array([0, 1]) distances, indices = layer.first_nearest_neighbours(points, types) Source code in moirepy/layers.py def first_nearest_neighbours(self, points: np.ndarray, types: np.ndarray): \"\"\" Finds the first nearest neighbors for each point in the given array. Args: points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors. types (np.ndarray): An (N,) array of types corresponding to each point in `points`. Returns: distances (list): A list of lists, where each inner list contains the distances to the nearest neighbors for the corresponding point. indices (list): A list of lists, where each inner list contains the indices of the nearest neighbors in `self.points`. Raises: AssertionError: If `self.kdtree` is not initialized. AssertionError: If the number of points does not match the number of types. ValueError: If a point type is not defined in `self.neighbours`. ValueError: If PBC is enabled and a distance exceeds the specified tolerance. Example: ```python layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) types = np.array([0, 1]) distances, indices = layer.first_nearest_neighbours(points, types) ``` \"\"\" assert self.kdtree is not None, \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" assert points.shape[0] == types.shape[0], \"Mismatch between number of points and types.\" bigger_indices_all, smaller_indices_all, smaller_distances_all = [], [], [] for point, t in zip(points, types): if t not in self.neighbours: raise ValueError(f\"Point type '{t}' is not defined in self.neighbours.\") relative_neighbours = np.array(self.neighbours[t]) absolute_neighbours = point + relative_neighbours distances, indices = self.kdtree.query(absolute_neighbours, k=1) bigger_indices, smaller_distances, smaller_indices = [], [], [] for dist, idx in zip(distances, indices): if self.pbc: if dist > 1e-2 * self.toll_scale: raise ValueError(f\"Distance {dist} exceeds tolerance.\") bigger_indices.append(idx) smaller_indices.append(self.mappings[idx]) smaller_distances.append(dist) else: # if dist > 1e-2 * self.toll_scale: # raise ValueError(f\"Distance {dist} exceeds tolerance.\") bigger_indices.append(idx) smaller_indices.append(idx) smaller_distances.append(dist) bigger_indices_all.append(bigger_indices) smaller_indices_all.append(smaller_indices) smaller_distances_all.append(smaller_distances) return bigger_indices_all, smaller_indices_all, smaller_distances_all","title":"first_nearest_neighbours"},{"location":"api/layers/#moirepy.layers.Layer.generate_kdtree","text":"Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None ( None ) \u2013 The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError \u2013 If the points in the lattice are not defined. Source code in moirepy/layers.py def generate_kdtree(self) -> None: \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. \"\"\" if not self.pbc: # OBC is easy self.kdtree = KDTree(self.points) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range(-1, 2): for j in range(-1, 2): all_points.append(self.points + i * self.mln1 * self.mlv1 + j * self.mln2 * self.mlv2) all_point_names.append(self.point_types) all_points = np.vstack(all_points) all_point_names = np.hstack(all_point_names) v1 = self.mln1 * self.mlv1 v2 = self.mln2 * self.mlv2 neigh_pad_1 = (1 + self.study_proximity) * np.linalg.norm(self.lv1) / np.linalg.norm(v1) neigh_pad_2 = (1 + self.study_proximity) * np.linalg.norm(self.lv2) / np.linalg.norm(v2) mask = self._inside_polygon(all_points, np.array([ (-neigh_pad_1) * v1 + (-neigh_pad_2) * v2, (1 + neigh_pad_1) * v1 + (-neigh_pad_2) * v2, (1 + neigh_pad_1) * v1 + (1 + neigh_pad_2) * v2, (-neigh_pad_1) * v1 + (1 + neigh_pad_2) * v2, ])) # print(mask.shape, mask.dtype) points = all_points[mask] point_names = all_point_names[mask] self.bigger_points = points self.bigger_point_types = point_names self.kdtree = KDTree(points) self._generate_mapping()","title":"generate_kdtree"},{"location":"api/layers/#moirepy.layers.Layer.generate_points","text":"Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Parameters: mlv1 ( ndarray ) \u2013 The first Moir\u00e9 lattice vector. mlv2 ( ndarray ) \u2013 The second Moir\u00e9 lattice vector. mln1 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test ( bool , default: False ) \u2013 If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None ( None ) \u2013 The function modifies the object state and None \u2013 stores the generated points and their types. Raises: AssersionError \u2013 If mln1 and mln2 are not positive integers. AssersionError \u2013 if test is True and mln1 or mln2 is not 1 Example: >>> lattice = MyLattice() # a class inheriting the Layer class >>> lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1) >>> print(lattice.points) Source code in moirepy/layers.py def generate_points( self, mlv1: np.ndarray, mlv2: np.ndarray, mln1: int = 1, mln2: int = 1, test: bool = False, ) -> None: \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.ndarray): The first Moir\u00e9 lattice vector. mlv2 (np.ndarray): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test (bool, optional): If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None: The function modifies the object state and stores the generated points and their types. Raises: AssersionError: If mln1 and mln2 are not positive integers. AssersionError: if test is True and mln1 or mln2 is not 1 Example: ```python >>> lattice = MyLattice() # a class inheriting the Layer class >>> lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1) >>> print(lattice.points) ``` \"\"\" # raise the promised errors: assert isinstance(mln1, int) and mln1 > 0, \"mln1 must be a positive integer.\" assert isinstance(mln2, int) and mln2 > 0, \"mln2 must be a positive integer.\" if test: assert mln1 == 1 and mln2 == 1, \"If test is True, both mln1 and mln2 must be 1.\" self.mlv1 = mlv1 # Moire lattice vector 1 self.mlv2 = mlv2 # Moire lattice vector 2 self.mln1 = mln1 # Number of moire unit cells along mlv1 self.mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the number of points along each direction points = [np.array([0, 0]), mlv1, mlv2, mlv1 + mlv2] max_distance = max( np.linalg.norm(points[0] - points[1]), np.linalg.norm(points[0] - points[2]), np.linalg.norm(points[0] - points[3]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math.ceil(max_distance / min(np.linalg.norm(self.lv1), np.linalg.norm(self.lv2))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range(-n, n + 1): # Iterate along mlv1 for j in range(-n, n + 1): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self.lv1 + j * self.lv2 for xpos, ypos, name in self.lattice_points: point = point_o + np.array([xpos, ypos]) step1_points.append(point) step1_names.append(name) step1_points = np.array(step1_points) step1_names = np.array(step1_names) # Apply the boundary check method (inside_boundaries) to filter the points mask = self._inside_boundaries(step1_points, 1, 1) # generating points only inside the first cell now step1_points = step1_points[mask] step1_names = step1_names[mask] # Step 3: Copy and translate the unit cell to create the full lattice points = [] # List to hold all the moire points names = [] for i in range(self.mln1): # Translate along mlv1 direction for j in range(self.mln2): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points.append(translated_points) names.append(step1_names) self.points = np.vstack(points) self.point_types = np.hstack(names) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") if not test: self.generate_kdtree()","title":"generate_points"},{"location":"api/layers/#moirepy.layers.Layer.perform_rotation_translation","text":"Rotates and translates the lattice layer and its components. Has to be applied before point generation. Parameters: rot ( float ) \u2013 The rotation angle in radians. Default to None . translation ( Tuple [ float , float ] , default: (0, 0) ) \u2013 The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None ( None ) \u2013 The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: layer.perform_rotation_translation(np.pi/4, (1, 1)) Source code in moirepy/layers.py def perform_rotation_translation(self, rot:float, translation:Tuple[float, float]=(0, 0)) -> None: \"\"\" Rotates and translates the lattice layer and its components. Has to be applied before point generation. Args: rot (float): The rotation angle in radians. Default to `None`. translation (Tuple[float, float]): The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation_translation(np.pi/4, (1, 1)) ``` \"\"\" assert self.points is None, \"Cannot perform rotation and translation after points have been generated.\" rot_m = get_rotation_matrix(rot) self.rot_m = rot_m # Rotate lv1 and lv2 vectors self.lv1 = rot_m @ self.lv1 self.lv2 = rot_m @ self.lv2 # Rotate lattice_points self.lattice_points = [ [*(rot_m @ (np.array([x, y]) + np.array(translation))), point_type] for x, y, point_type in self.lattice_points ] # Rotate neighbours self.neighbours = { point_type: [rot_m @ np.array(neighbour) for neighbour in neighbour_list] for point_type, neighbour_list in self.neighbours.items() }","title":"perform_rotation_translation"},{"location":"api/layers/#moirepy.layers.Layer.plot_lattice","text":"Plots the lattice points and optionally the connections between them and the unit cell structure. Parameters: plot_connections ( bool , default: True ) \u2013 If True, plots the connections between nearest neighbors. Defaults to True. colours ( list , default: ['r', 'g', 'b', 'c', 'm', 'y', 'k'] ) \u2013 List of matplotlib colours to use for different point types. Behavior Plots all lattice points grouped by type. If plot_connections is True, it draws dashed red lines between nearest neighbors. Example: lattice = MyLattice() lattice.generate_points() lattice.plot_lattice(plot_connections=True) Visualization Details Lattice points are plotted as small dots. Nearest neighbor connections (if enabled) are shown as dashed red lines. Source code in moirepy/layers.py def plot_lattice(self, plot_connections: bool = True, colours:list=[\"r\", \"g\", \"b\", \"c\", \"m\", \"y\", \"k\"]) -> None: \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. colours (list, optional): List of matplotlib colours to use for different point types. Behavior: - Plots all lattice points grouped by type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. Example: ```python lattice = MyLattice() lattice.generate_points() lattice.plot_lattice(plot_connections=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. \"\"\" if len(colours) == 1: cols = {t[-1]:colours[0] for i, t, in enumerate(self.lattice_points)} else: cols = {t[-1]:colours[i] for i, t, in enumerate(self.lattice_points)} plt.scatter( [self.points[:, 0]], [self.points[:, 1]], s=10, c=np.vectorize(cols.get)(self.point_types) ) if plot_connections: a = [] for this, point_type in zip(self.points, self.point_types): for delta in self.neighbours[point_type]: a.append([this[0], this[0] + delta[0]]) a.append((this[1], this[1] + delta[1])) a.append(\"k--\") # a = a[:30] # print(a) plt.plot(*a, alpha=0.1) plt.title(\"Lattice Points\") plt.xlabel(\"X Coordinate\") plt.ylabel(\"Y Coordinate\") plt.axis(\"equal\")","title":"plot_lattice"},{"location":"api/layers/#moirepy.layers.Layer.query_one","text":"Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Parameters: points ( ndarray ) \u2013 An (N, 2) array of points for which to find the nearest neighbors. k ( int ) \u2013 The number of nearest neighbors to query. Defaults to 1. Returns: Tuple [ ndarray , ndarray ] \u2013 Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in self.points . If PBC is enabled, the indices are remapped using self.mappings . Raises: AssertionError \u2013 If self.kdtree is not initialized. RuntimeError \u2013 If PBC is enabled and the mapping process fails. RuntimeError \u2013 If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior If self.pbc is False, the function returns the nearest neighbors as given by KDTree. If self.pbc is True, the function applies self.mappings to remap indices according to periodic boundary conditions. Example: layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) distances, indices = layer.query(points, k=2) Source code in moirepy/layers.py def query_one(self, points: np.ndarray) -> Tuple[np.ndarray, np.ndarray]: \"\"\" Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled. Args: points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors. k (int, optional): The number of nearest neighbors to query. Defaults to 1. Returns: Tuple[np.ndarray, np.ndarray]: - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors. - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`. Raises: AssertionError: If `self.kdtree` is not initialized. RuntimeError: If PBC is enabled and the mapping process fails. RuntimeError: If there are uneven row lengths in the returned arrays due to inconsistent filtering. Behavior: - If `self.pbc` is False, the function returns the nearest neighbors as given by KDTree. - If `self.pbc` is True, the function applies `self.mappings` to remap indices according to periodic boundary conditions. Example: ```python layer = Layer() layer.generate_kdtree() points = np.array([[0.5, 0.5], [1.0, 1.0]]) distances, indices = layer.query(points, k=2) ``` \"\"\" # Step 1: # - get a normal query from KDTree # - distance, index = self.kdtree.query(points, k=k) # - remove all the points farther than (1+0.1*toll_scale) * min distance # - return here just that if OBC # Step 2: it will come here if PBC is True # - for all the points map them using self.mappings # - replace the indices with the mapped indices # - return the mapped indices and distances (distance will be the same) assert self.kdtree is not None, \"Generate the KDTree first by calling `Layer.generate_kdtree()`.\" distances, indices = self.kdtree.query(points, k=[1]) # for k=1, it returns squeezed arrays... so we need to unsqueeze them # distances = distances[:, None] # indices = indices[:, None] if not self.pbc: return indices, indices, distances try: vectorized_fn = np.vectorize(self.mappings.get) remapped_indices = vectorized_fn(indices) except TypeError as e: raise RuntimeError(\"FATAL ERROR: Mapping failed during vectorization. Check if all indices are valid.\") from e return indices, remapped_indices, distances","title":"query_one"},{"location":"api/moire/","text":"BilayerMoireLattice Source code in moirepy/moire.py class BilayerMoireLattice: # both layers same, only one point in one unit cell def __init__( self, latticetype: Layer, ll1:int, ll2:int, # lower lattice ul1:int, ul2:int, # upper lattice n1:int=1, n2:int=1, translate_upper=(0, 0), pbc:bool=True, k:int=1, # number of orbitals ): \"\"\" Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Args: latticetype (Layer): A subclass of the `Layer` class representing the lattice type used for both layers. ll1, ll2, ul1, ul2 (int): Values select from the [AVC tool](https://jabed-umar.github.io/MoirePy/theory/avc/). n1 (int, optional): Number of moir\u00e9 cells along the first lattice vector. n2 (int, optional): Number of moir\u00e9 cells along the second lattice vector. translate_upper (tuple, optional): Translation vector (dx, dy) applied to the upper layer before rotation. pbc (bool, optional): Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k (int, optional): Number of orbitals on each lattice point. \"\"\" # study_proximity = 1 means only studying nearest neighbours will be enabled, # 2 means study of next nearest neighbours will be enabled too and so on, # always better to keep this value 1 or two more than what you will actually need. lower_lattice = latticetype(pbc=pbc) upper_lattice = latticetype(pbc=pbc) lv1, lv2 = lower_lattice.lv1, lower_lattice.lv2 # c = cos(theta) between lv1 and lv2 (60 degree for triangular, 90 for square and so on) c = np.dot(lv1, lv2) / (np.linalg.norm(lv1) * np.linalg.norm(lv2)) beta = np.arccos(c) mlv1 = ll1*lv1 + ll2*lv2 # because lower latice is fixed mlv2 = get_rotation_matrix(beta).dot(mlv1) # calculating the moire twist angle one = ll1*lv1 + ll2*lv2 # the coords of overlapping point in the lower lattice two = ul1*lv1 + ul2*lv2 # the coords of overlapping point in the upper lattice assert np.isclose(np.linalg.norm(one), np.linalg.norm(two)), \"INPUT ERROR: the two points are not overlapping, check ll1, ll2, ul1, ul2 values\" c = np.dot(one, two) / (np.linalg.norm(one) * np.linalg.norm(two)) theta = np.arccos(c) # in radians print(f\"twist angle = {theta:.4f} rad ({np.rad2deg(theta):.4f} deg)\") upper_lattice.perform_rotation_translation(theta, translate_upper) assert ( are_coeffs_integers(lower_lattice.lv1, lower_lattice.lv2, mlv1) and are_coeffs_integers(upper_lattice.lv1, upper_lattice.lv2, mlv1) ), \"FATAL ERROR: calculated mlv2 is incorrect\" lower_lattice.generate_points(mlv1, mlv2, n1, n2) upper_lattice.generate_points(mlv1, mlv2, n1, n2) # print(f\"{mlv1 = }\") # print(f\"{mlv2 = }\") self.ll1 = ll1 self.ll2 = ll2 self.ul1 = ul1 self.ul2 = ul2 self.n1 = n1 self.n2 = n2 self.translate_upper = translate_upper self.lower_lattice = lower_lattice self.upper_lattice = upper_lattice self.theta = theta self.mlv1 = mlv1 self.mlv2 = mlv2 self.pbc = pbc self.orbitals = k self.ham = None print(f\"{len(self.lower_lattice.points)} points in lower lattice\") print(f\"{len(self.upper_lattice.points)} points in upper lattice\") assert len(self.lower_lattice.points) == len(self.upper_lattice.points), \"FATAL ERROR: number of points in lower and upper lattice are not equal, take different ll1, ll2, ul1, ul2 values\" # self.plot_lattice() def plot_lattice(self): mlv1 = self.mlv1 mlv2 = self.mlv2 n1 = self.n1 n2 = self.n2 # plt.plot(*zip(*self.lower_lattice.points), 'r.', markersize=2) # plt.plot(*zip(*self.upper_lattice.points), 'b.', markersize=2) self.lower_lattice.plot_lattice(colours=[\"b\"], plot_connections=True) self.upper_lattice.plot_lattice(colours=[\"r\"], plot_connections=True) # parallellogram around the whole lattice plt.plot([0, n1*mlv1[0]], [0, n1*mlv1[1]], 'k', linewidth=1) plt.plot([0, n2*mlv2[0]], [0, n2*mlv2[1]], 'k', linewidth=1) plt.plot([n1*mlv1[0], n1*mlv1[0] + n2*mlv2[0]], [n1*mlv1[1], n1*mlv1[1] + n2*mlv2[1]], 'k', linewidth=1) plt.plot([n2*mlv2[0], n1*mlv1[0] + n2*mlv2[0]], [n2*mlv2[1], n1*mlv1[1] + n2*mlv2[1]], 'k', linewidth=1) # just plot mlv1 and mlv2 parallellogram plt.plot([0, mlv1[0]], [0, mlv1[1]], 'k', linewidth=1) plt.plot([0, mlv2[0]], [0, mlv2[1]], 'k', linewidth=1) plt.plot([mlv1[0], mlv1[0] + mlv2[0]], [mlv1[1], mlv1[1] + mlv2[1]], 'k', linewidth=1) plt.plot([mlv2[0], mlv1[0] + mlv2[0]], [mlv2[1], mlv1[1] + mlv2[1]], 'k', linewidth=1) # set equal aspect ratio plt.gca().set_aspect('equal', adjustable='box') # plt.grid() # plt.show() # plt.savefig(\"moire.pdf\", bbox_inches='tight') def _validate_input1(self, a, name): if a is None: a = 0 print(f\"WARNING: {name} is not set, setting it to 0\") if callable(a): return a return lambda this_coo, neigh_coo, this_type, neigh_type: a def _validate_input2(self, a, name): if a is None: a = 0 print(f\"WARNING: {name} is not set, setting it to 0\") if callable(a): return a return lambda this_coo, this_type: a def generate_hamiltonian( self, tll: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tuu: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tlu: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tul: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tuself: Union[float, int, Callable[[Sequence[float], str], float]] = None, tlself: Union[float, int, Callable[[Sequence[float], str], float]] = None, data_type: np.dtype = np.float64, # set to np.complex128 if you want complex numbers ): k = self.orbitals if tll is None or isinstance(tll, int) or isinstance(tll, float): tll = self._validate_input1(tll, \"tll\") if tuu is None or isinstance(tuu, int) or isinstance(tuu, float): tuu = self._validate_input1(tuu, \"tuu\") if tlu is None or isinstance(tlu, int) or isinstance(tlu, float): tlu = self._validate_input1(tlu, \"tlu\") if tul is None or isinstance(tul, int) or isinstance(tul, float): tul = self._validate_input1(tul, \"tul\") if tuself is None or isinstance(tuself, int) or isinstance(tuself, float): tuself = self._validate_input2(tuself, \"tuself\") if tlself is None or isinstance(tlself, int) or isinstance(tlself, float): tlself = self._validate_input2(tlself, \"tlself\") assert ( callable(tll) and callable(tuu) and callable(tlu) and callable(tul) and callable(tuself) and callable(tlself) ), \"tuu, tll, tlu, tul, tuself and tlself must be floats, ints or callable objects like functions\" # self.plot_lattice() # 1. interaction inside the lower lattice ham_ll = np.zeros((len(self.lower_lattice.points)*k, len(self.lower_lattice.points)*k), dtype=data_type) for i in range(len(self.lower_lattice.points)): # self interactions ham_ll[i*k:(i+1)*k, i*k:(i+1)*k] += tlself( self.lower_lattice.points[i], self.lower_lattice.point_types[i] ) bigger_indices, indices, _ = self.lower_lattice.first_nearest_neighbours(self.lower_lattice.points, self.lower_lattice.point_types) for this_i in range(len(self.lower_lattice.points)): # neighbour interactions this_coo = self.lower_lattice.points[this_i] this_type = self.lower_lattice.point_types[this_i] for phantom_neigh_i, neigh_i in zip(bigger_indices[this_i], indices[this_i]): if self.pbc: neigh_coo = self.lower_lattice.bigger_points[phantom_neigh_i] else: neigh_coo = self.lower_lattice.points[neigh_i] neigh_type = self.lower_lattice.point_types[neigh_i] ham_ll[this_i*k:(this_i+1)*k, neigh_i*k:(neigh_i+1)*k] += tll(this_coo, neigh_coo, this_type, neigh_type) # 2. interaction inside the upper lattice ham_uu = np.zeros((len(self.upper_lattice.points)*k, len(self.upper_lattice.points)*k), dtype=data_type) for i in range(len(self.upper_lattice.points)): # self interactions ham_uu[i*k:(i+1)*k, i*k:(i+1)*k] += tuself( self.upper_lattice.points[i], self.upper_lattice.point_types[i] ) bigger_indices, indices, _ = self.upper_lattice.first_nearest_neighbours(self.upper_lattice.points, self.upper_lattice.point_types) for this_i in range(len(self.upper_lattice.points)): # neighbour interactions this_coo = self.upper_lattice.points[this_i] this_type = self.upper_lattice.point_types[this_i] # for neigh_i in indices[this_i]: for phantom_neigh_i, neigh_i in zip(bigger_indices[this_i], indices[this_i]): if self.pbc: neigh_coo = self.lower_lattice.bigger_points[phantom_neigh_i] else: neigh_coo = self.lower_lattice.points[neigh_i] neigh_type = self.upper_lattice.point_types[neigh_i] ham_uu[this_i*k:(this_i+1)*k, neigh_i*k:(neigh_i+1)*k] += tuu(this_coo, neigh_coo, this_type, neigh_type) # 3. interaction from the lower to the upper lattice ham_lu = np.zeros((len(self.lower_lattice.points)*k, len(self.upper_lattice.points)*k), dtype=data_type) bigger_indices, indices, _ = self.upper_lattice.query_one(self.lower_lattice.points) for this_i in range(len(self.lower_lattice.points)): neigh_i = indices[this_i, 0] phantom_neigh_i = bigger_indices[this_i, 0] ham_lu[this_i*k:(this_i+1)*k, neigh_i*k:(neigh_i+1)*k] += tlu( self.lower_lattice.points[this_i], self.upper_lattice.bigger_points[phantom_neigh_i] if self.pbc else self.upper_lattice.points[neigh_i], self.lower_lattice.point_types[this_i], self.upper_lattice.point_types[neigh_i], ) # 4. interaction from the upper to the lower lattice ham_ul = np.zeros((len(self.upper_lattice.points)*k, len(self.lower_lattice.points)*k), dtype=data_type) bigger_indices, indices, _ = self.lower_lattice.query_one(self.upper_lattice.points) for this_i in range(len(self.upper_lattice.points)): neigh_i = indices[this_i, 0] phantom_neigh_i = bigger_indices[this_i, 0] ham_ul[this_i*k:(this_i+1)*k, neigh_i*k:(neigh_i+1)*k] += tul( self.upper_lattice.points[this_i], self.lower_lattice.bigger_points[phantom_neigh_i] if self.pbc else self.lower_lattice.points[neigh_i], self.upper_lattice.point_types[this_i], self.lower_lattice.point_types[neigh_i], ) # # in ham_ll and ham_uu, check sum of all the rows... # # for constant t it should represent the number of neighbours for each point # print(f\"unique sums in ham_ll: {np.unique(np.sum(ham_ll, axis=1))}\") # print(f\"unique sums in ham_uu: {np.unique(np.sum(ham_uu, axis=1))}\") # print(f\"unique sums in ham_lu: {np.unique(np.sum(ham_lu, axis=1))}\") # print(f\"unique sums in ham_ul: {np.unique(np.sum(ham_ul, axis=1))}\") # combine the hamiltonians self.ham = np.block([ [ham_ll, ham_lu], [ham_ul, ham_uu] ]) return self.ham def generate_k_space_hamiltonian( self, k: np.ndarray, tll: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tuu: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tlu: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tul: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tuself: Union[float, int, Callable[[Sequence[float], str], float]] = None, tlself: Union[float, int, Callable[[Sequence[float], str], float]] = None, suppress_nxny_warning: bool = False, ): if suppress_nxny_warning is False and (self.n1 != 1 or self.n2 != 1): print(\"WARNING: atleast one of n1 and n2 are not 1, are you sure you want to use generate_k_space_hamiltonian with this lattice?\") if tll is None or isinstance(tll, int) or isinstance(tll, float): tll = self._validate_input1(tll, \"tll\") if tuu is None or isinstance(tuu, int) or isinstance(tuu, float): tuu = self._validate_input1(tuu, \"tuu\") if tlu is None or isinstance(tlu, int) or isinstance(tlu, float): tlu = self._validate_input1(tlu, \"tlu\") if tul is None or isinstance(tul, int) or isinstance(tul, float): tul = self._validate_input1(tul, \"tul\") if tuself is None or isinstance(tuself, int) or isinstance(tuself, float): tuself = self._validate_input2(tuself, \"tuself\") if tlself is None or isinstance(tlself, int) or isinstance(tlself, float): tlself = self._validate_input2(tlself, \"tlself\") assert ( callable(tll) and callable(tuu) and callable(tlu) and callable(tul) and callable(tuself) and callable(tlself) ), \"tuu, tll, tlu, tul, tuself and tlself must be floats, ints or callable objects like functions\" part = lambda k, this_coo, neigh_coo: np.exp(1j * (k @ (this_coo.squeeze() - neigh_coo.squeeze()))) return self.generate_hamiltonian( lambda this_coo, neigh_coo, this_type, neigh_type: tll(this_coo, neigh_coo, this_type, neigh_type) * part(k, this_coo, neigh_coo), lambda this_coo, neigh_coo, this_type, neigh_type: tuu(this_coo, neigh_coo, this_type, neigh_type) * part(k, this_coo, neigh_coo), lambda this_coo, neigh_coo, this_type, neigh_type: tlu(this_coo, neigh_coo, this_type, neigh_type) * part(k, this_coo, neigh_coo), lambda this_coo, neigh_coo, this_type, neigh_type: tul(this_coo, neigh_coo, this_type, neigh_type) * part(k, this_coo, neigh_coo), tuself, tlself, data_type=np.complex128 ) __init__(latticetype, ll1, ll2, ul1, ul2, n1=1, n2=1, translate_upper=(0, 0), pbc=True, k=1) Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Parameters: latticetype ( Layer ) \u2013 A subclass of the Layer class representing the lattice type used for both layers. ll1, ( ll2, ul1, ul2 (int ) \u2013 Values select from the AVC tool . n1 ( int , default: 1 ) \u2013 Number of moir\u00e9 cells along the first lattice vector. n2 ( int , default: 1 ) \u2013 Number of moir\u00e9 cells along the second lattice vector. translate_upper ( tuple , default: (0, 0) ) \u2013 Translation vector (dx, dy) applied to the upper layer before rotation. pbc ( bool , default: True ) \u2013 Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k ( int , default: 1 ) \u2013 Number of orbitals on each lattice point. Source code in moirepy/moire.py def __init__( self, latticetype: Layer, ll1:int, ll2:int, # lower lattice ul1:int, ul2:int, # upper lattice n1:int=1, n2:int=1, translate_upper=(0, 0), pbc:bool=True, k:int=1, # number of orbitals ): \"\"\" Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Args: latticetype (Layer): A subclass of the `Layer` class representing the lattice type used for both layers. ll1, ll2, ul1, ul2 (int): Values select from the [AVC tool](https://jabed-umar.github.io/MoirePy/theory/avc/). n1 (int, optional): Number of moir\u00e9 cells along the first lattice vector. n2 (int, optional): Number of moir\u00e9 cells along the second lattice vector. translate_upper (tuple, optional): Translation vector (dx, dy) applied to the upper layer before rotation. pbc (bool, optional): Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k (int, optional): Number of orbitals on each lattice point. \"\"\" # study_proximity = 1 means only studying nearest neighbours will be enabled, # 2 means study of next nearest neighbours will be enabled too and so on, # always better to keep this value 1 or two more than what you will actually need. lower_lattice = latticetype(pbc=pbc) upper_lattice = latticetype(pbc=pbc) lv1, lv2 = lower_lattice.lv1, lower_lattice.lv2 # c = cos(theta) between lv1 and lv2 (60 degree for triangular, 90 for square and so on) c = np.dot(lv1, lv2) / (np.linalg.norm(lv1) * np.linalg.norm(lv2)) beta = np.arccos(c) mlv1 = ll1*lv1 + ll2*lv2 # because lower latice is fixed mlv2 = get_rotation_matrix(beta).dot(mlv1) # calculating the moire twist angle one = ll1*lv1 + ll2*lv2 # the coords of overlapping point in the lower lattice two = ul1*lv1 + ul2*lv2 # the coords of overlapping point in the upper lattice assert np.isclose(np.linalg.norm(one), np.linalg.norm(two)), \"INPUT ERROR: the two points are not overlapping, check ll1, ll2, ul1, ul2 values\" c = np.dot(one, two) / (np.linalg.norm(one) * np.linalg.norm(two)) theta = np.arccos(c) # in radians print(f\"twist angle = {theta:.4f} rad ({np.rad2deg(theta):.4f} deg)\") upper_lattice.perform_rotation_translation(theta, translate_upper) assert ( are_coeffs_integers(lower_lattice.lv1, lower_lattice.lv2, mlv1) and are_coeffs_integers(upper_lattice.lv1, upper_lattice.lv2, mlv1) ), \"FATAL ERROR: calculated mlv2 is incorrect\" lower_lattice.generate_points(mlv1, mlv2, n1, n2) upper_lattice.generate_points(mlv1, mlv2, n1, n2) # print(f\"{mlv1 = }\") # print(f\"{mlv2 = }\") self.ll1 = ll1 self.ll2 = ll2 self.ul1 = ul1 self.ul2 = ul2 self.n1 = n1 self.n2 = n2 self.translate_upper = translate_upper self.lower_lattice = lower_lattice self.upper_lattice = upper_lattice self.theta = theta self.mlv1 = mlv1 self.mlv2 = mlv2 self.pbc = pbc self.orbitals = k self.ham = None print(f\"{len(self.lower_lattice.points)} points in lower lattice\") print(f\"{len(self.upper_lattice.points)} points in upper lattice\") assert len(self.lower_lattice.points) == len(self.upper_lattice.points), \"FATAL ERROR: number of points in lower and upper lattice are not equal, take different ll1, ll2, ul1, ul2 values\"","title":"Moire"},{"location":"api/moire/#moirepy.moire.BilayerMoireLattice","text":"Source code in moirepy/moire.py class BilayerMoireLattice: # both layers same, only one point in one unit cell def __init__( self, latticetype: Layer, ll1:int, ll2:int, # lower lattice ul1:int, ul2:int, # upper lattice n1:int=1, n2:int=1, translate_upper=(0, 0), pbc:bool=True, k:int=1, # number of orbitals ): \"\"\" Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Args: latticetype (Layer): A subclass of the `Layer` class representing the lattice type used for both layers. ll1, ll2, ul1, ul2 (int): Values select from the [AVC tool](https://jabed-umar.github.io/MoirePy/theory/avc/). n1 (int, optional): Number of moir\u00e9 cells along the first lattice vector. n2 (int, optional): Number of moir\u00e9 cells along the second lattice vector. translate_upper (tuple, optional): Translation vector (dx, dy) applied to the upper layer before rotation. pbc (bool, optional): Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k (int, optional): Number of orbitals on each lattice point. \"\"\" # study_proximity = 1 means only studying nearest neighbours will be enabled, # 2 means study of next nearest neighbours will be enabled too and so on, # always better to keep this value 1 or two more than what you will actually need. lower_lattice = latticetype(pbc=pbc) upper_lattice = latticetype(pbc=pbc) lv1, lv2 = lower_lattice.lv1, lower_lattice.lv2 # c = cos(theta) between lv1 and lv2 (60 degree for triangular, 90 for square and so on) c = np.dot(lv1, lv2) / (np.linalg.norm(lv1) * np.linalg.norm(lv2)) beta = np.arccos(c) mlv1 = ll1*lv1 + ll2*lv2 # because lower latice is fixed mlv2 = get_rotation_matrix(beta).dot(mlv1) # calculating the moire twist angle one = ll1*lv1 + ll2*lv2 # the coords of overlapping point in the lower lattice two = ul1*lv1 + ul2*lv2 # the coords of overlapping point in the upper lattice assert np.isclose(np.linalg.norm(one), np.linalg.norm(two)), \"INPUT ERROR: the two points are not overlapping, check ll1, ll2, ul1, ul2 values\" c = np.dot(one, two) / (np.linalg.norm(one) * np.linalg.norm(two)) theta = np.arccos(c) # in radians print(f\"twist angle = {theta:.4f} rad ({np.rad2deg(theta):.4f} deg)\") upper_lattice.perform_rotation_translation(theta, translate_upper) assert ( are_coeffs_integers(lower_lattice.lv1, lower_lattice.lv2, mlv1) and are_coeffs_integers(upper_lattice.lv1, upper_lattice.lv2, mlv1) ), \"FATAL ERROR: calculated mlv2 is incorrect\" lower_lattice.generate_points(mlv1, mlv2, n1, n2) upper_lattice.generate_points(mlv1, mlv2, n1, n2) # print(f\"{mlv1 = }\") # print(f\"{mlv2 = }\") self.ll1 = ll1 self.ll2 = ll2 self.ul1 = ul1 self.ul2 = ul2 self.n1 = n1 self.n2 = n2 self.translate_upper = translate_upper self.lower_lattice = lower_lattice self.upper_lattice = upper_lattice self.theta = theta self.mlv1 = mlv1 self.mlv2 = mlv2 self.pbc = pbc self.orbitals = k self.ham = None print(f\"{len(self.lower_lattice.points)} points in lower lattice\") print(f\"{len(self.upper_lattice.points)} points in upper lattice\") assert len(self.lower_lattice.points) == len(self.upper_lattice.points), \"FATAL ERROR: number of points in lower and upper lattice are not equal, take different ll1, ll2, ul1, ul2 values\" # self.plot_lattice() def plot_lattice(self): mlv1 = self.mlv1 mlv2 = self.mlv2 n1 = self.n1 n2 = self.n2 # plt.plot(*zip(*self.lower_lattice.points), 'r.', markersize=2) # plt.plot(*zip(*self.upper_lattice.points), 'b.', markersize=2) self.lower_lattice.plot_lattice(colours=[\"b\"], plot_connections=True) self.upper_lattice.plot_lattice(colours=[\"r\"], plot_connections=True) # parallellogram around the whole lattice plt.plot([0, n1*mlv1[0]], [0, n1*mlv1[1]], 'k', linewidth=1) plt.plot([0, n2*mlv2[0]], [0, n2*mlv2[1]], 'k', linewidth=1) plt.plot([n1*mlv1[0], n1*mlv1[0] + n2*mlv2[0]], [n1*mlv1[1], n1*mlv1[1] + n2*mlv2[1]], 'k', linewidth=1) plt.plot([n2*mlv2[0], n1*mlv1[0] + n2*mlv2[0]], [n2*mlv2[1], n1*mlv1[1] + n2*mlv2[1]], 'k', linewidth=1) # just plot mlv1 and mlv2 parallellogram plt.plot([0, mlv1[0]], [0, mlv1[1]], 'k', linewidth=1) plt.plot([0, mlv2[0]], [0, mlv2[1]], 'k', linewidth=1) plt.plot([mlv1[0], mlv1[0] + mlv2[0]], [mlv1[1], mlv1[1] + mlv2[1]], 'k', linewidth=1) plt.plot([mlv2[0], mlv1[0] + mlv2[0]], [mlv2[1], mlv1[1] + mlv2[1]], 'k', linewidth=1) # set equal aspect ratio plt.gca().set_aspect('equal', adjustable='box') # plt.grid() # plt.show() # plt.savefig(\"moire.pdf\", bbox_inches='tight') def _validate_input1(self, a, name): if a is None: a = 0 print(f\"WARNING: {name} is not set, setting it to 0\") if callable(a): return a return lambda this_coo, neigh_coo, this_type, neigh_type: a def _validate_input2(self, a, name): if a is None: a = 0 print(f\"WARNING: {name} is not set, setting it to 0\") if callable(a): return a return lambda this_coo, this_type: a def generate_hamiltonian( self, tll: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tuu: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tlu: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tul: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tuself: Union[float, int, Callable[[Sequence[float], str], float]] = None, tlself: Union[float, int, Callable[[Sequence[float], str], float]] = None, data_type: np.dtype = np.float64, # set to np.complex128 if you want complex numbers ): k = self.orbitals if tll is None or isinstance(tll, int) or isinstance(tll, float): tll = self._validate_input1(tll, \"tll\") if tuu is None or isinstance(tuu, int) or isinstance(tuu, float): tuu = self._validate_input1(tuu, \"tuu\") if tlu is None or isinstance(tlu, int) or isinstance(tlu, float): tlu = self._validate_input1(tlu, \"tlu\") if tul is None or isinstance(tul, int) or isinstance(tul, float): tul = self._validate_input1(tul, \"tul\") if tuself is None or isinstance(tuself, int) or isinstance(tuself, float): tuself = self._validate_input2(tuself, \"tuself\") if tlself is None or isinstance(tlself, int) or isinstance(tlself, float): tlself = self._validate_input2(tlself, \"tlself\") assert ( callable(tll) and callable(tuu) and callable(tlu) and callable(tul) and callable(tuself) and callable(tlself) ), \"tuu, tll, tlu, tul, tuself and tlself must be floats, ints or callable objects like functions\" # self.plot_lattice() # 1. interaction inside the lower lattice ham_ll = np.zeros((len(self.lower_lattice.points)*k, len(self.lower_lattice.points)*k), dtype=data_type) for i in range(len(self.lower_lattice.points)): # self interactions ham_ll[i*k:(i+1)*k, i*k:(i+1)*k] += tlself( self.lower_lattice.points[i], self.lower_lattice.point_types[i] ) bigger_indices, indices, _ = self.lower_lattice.first_nearest_neighbours(self.lower_lattice.points, self.lower_lattice.point_types) for this_i in range(len(self.lower_lattice.points)): # neighbour interactions this_coo = self.lower_lattice.points[this_i] this_type = self.lower_lattice.point_types[this_i] for phantom_neigh_i, neigh_i in zip(bigger_indices[this_i], indices[this_i]): if self.pbc: neigh_coo = self.lower_lattice.bigger_points[phantom_neigh_i] else: neigh_coo = self.lower_lattice.points[neigh_i] neigh_type = self.lower_lattice.point_types[neigh_i] ham_ll[this_i*k:(this_i+1)*k, neigh_i*k:(neigh_i+1)*k] += tll(this_coo, neigh_coo, this_type, neigh_type) # 2. interaction inside the upper lattice ham_uu = np.zeros((len(self.upper_lattice.points)*k, len(self.upper_lattice.points)*k), dtype=data_type) for i in range(len(self.upper_lattice.points)): # self interactions ham_uu[i*k:(i+1)*k, i*k:(i+1)*k] += tuself( self.upper_lattice.points[i], self.upper_lattice.point_types[i] ) bigger_indices, indices, _ = self.upper_lattice.first_nearest_neighbours(self.upper_lattice.points, self.upper_lattice.point_types) for this_i in range(len(self.upper_lattice.points)): # neighbour interactions this_coo = self.upper_lattice.points[this_i] this_type = self.upper_lattice.point_types[this_i] # for neigh_i in indices[this_i]: for phantom_neigh_i, neigh_i in zip(bigger_indices[this_i], indices[this_i]): if self.pbc: neigh_coo = self.lower_lattice.bigger_points[phantom_neigh_i] else: neigh_coo = self.lower_lattice.points[neigh_i] neigh_type = self.upper_lattice.point_types[neigh_i] ham_uu[this_i*k:(this_i+1)*k, neigh_i*k:(neigh_i+1)*k] += tuu(this_coo, neigh_coo, this_type, neigh_type) # 3. interaction from the lower to the upper lattice ham_lu = np.zeros((len(self.lower_lattice.points)*k, len(self.upper_lattice.points)*k), dtype=data_type) bigger_indices, indices, _ = self.upper_lattice.query_one(self.lower_lattice.points) for this_i in range(len(self.lower_lattice.points)): neigh_i = indices[this_i, 0] phantom_neigh_i = bigger_indices[this_i, 0] ham_lu[this_i*k:(this_i+1)*k, neigh_i*k:(neigh_i+1)*k] += tlu( self.lower_lattice.points[this_i], self.upper_lattice.bigger_points[phantom_neigh_i] if self.pbc else self.upper_lattice.points[neigh_i], self.lower_lattice.point_types[this_i], self.upper_lattice.point_types[neigh_i], ) # 4. interaction from the upper to the lower lattice ham_ul = np.zeros((len(self.upper_lattice.points)*k, len(self.lower_lattice.points)*k), dtype=data_type) bigger_indices, indices, _ = self.lower_lattice.query_one(self.upper_lattice.points) for this_i in range(len(self.upper_lattice.points)): neigh_i = indices[this_i, 0] phantom_neigh_i = bigger_indices[this_i, 0] ham_ul[this_i*k:(this_i+1)*k, neigh_i*k:(neigh_i+1)*k] += tul( self.upper_lattice.points[this_i], self.lower_lattice.bigger_points[phantom_neigh_i] if self.pbc else self.lower_lattice.points[neigh_i], self.upper_lattice.point_types[this_i], self.lower_lattice.point_types[neigh_i], ) # # in ham_ll and ham_uu, check sum of all the rows... # # for constant t it should represent the number of neighbours for each point # print(f\"unique sums in ham_ll: {np.unique(np.sum(ham_ll, axis=1))}\") # print(f\"unique sums in ham_uu: {np.unique(np.sum(ham_uu, axis=1))}\") # print(f\"unique sums in ham_lu: {np.unique(np.sum(ham_lu, axis=1))}\") # print(f\"unique sums in ham_ul: {np.unique(np.sum(ham_ul, axis=1))}\") # combine the hamiltonians self.ham = np.block([ [ham_ll, ham_lu], [ham_ul, ham_uu] ]) return self.ham def generate_k_space_hamiltonian( self, k: np.ndarray, tll: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tuu: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tlu: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tul: Union[float, int, Callable[[Sequence[float], Sequence[float], str, str], float]] = None, tuself: Union[float, int, Callable[[Sequence[float], str], float]] = None, tlself: Union[float, int, Callable[[Sequence[float], str], float]] = None, suppress_nxny_warning: bool = False, ): if suppress_nxny_warning is False and (self.n1 != 1 or self.n2 != 1): print(\"WARNING: atleast one of n1 and n2 are not 1, are you sure you want to use generate_k_space_hamiltonian with this lattice?\") if tll is None or isinstance(tll, int) or isinstance(tll, float): tll = self._validate_input1(tll, \"tll\") if tuu is None or isinstance(tuu, int) or isinstance(tuu, float): tuu = self._validate_input1(tuu, \"tuu\") if tlu is None or isinstance(tlu, int) or isinstance(tlu, float): tlu = self._validate_input1(tlu, \"tlu\") if tul is None or isinstance(tul, int) or isinstance(tul, float): tul = self._validate_input1(tul, \"tul\") if tuself is None or isinstance(tuself, int) or isinstance(tuself, float): tuself = self._validate_input2(tuself, \"tuself\") if tlself is None or isinstance(tlself, int) or isinstance(tlself, float): tlself = self._validate_input2(tlself, \"tlself\") assert ( callable(tll) and callable(tuu) and callable(tlu) and callable(tul) and callable(tuself) and callable(tlself) ), \"tuu, tll, tlu, tul, tuself and tlself must be floats, ints or callable objects like functions\" part = lambda k, this_coo, neigh_coo: np.exp(1j * (k @ (this_coo.squeeze() - neigh_coo.squeeze()))) return self.generate_hamiltonian( lambda this_coo, neigh_coo, this_type, neigh_type: tll(this_coo, neigh_coo, this_type, neigh_type) * part(k, this_coo, neigh_coo), lambda this_coo, neigh_coo, this_type, neigh_type: tuu(this_coo, neigh_coo, this_type, neigh_type) * part(k, this_coo, neigh_coo), lambda this_coo, neigh_coo, this_type, neigh_type: tlu(this_coo, neigh_coo, this_type, neigh_type) * part(k, this_coo, neigh_coo), lambda this_coo, neigh_coo, this_type, neigh_type: tul(this_coo, neigh_coo, this_type, neigh_type) * part(k, this_coo, neigh_coo), tuself, tlself, data_type=np.complex128 )","title":"BilayerMoireLattice"},{"location":"api/moire/#moirepy.moire.BilayerMoireLattice.__init__","text":"Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Parameters: latticetype ( Layer ) \u2013 A subclass of the Layer class representing the lattice type used for both layers. ll1, ( ll2, ul1, ul2 (int ) \u2013 Values select from the AVC tool . n1 ( int , default: 1 ) \u2013 Number of moir\u00e9 cells along the first lattice vector. n2 ( int , default: 1 ) \u2013 Number of moir\u00e9 cells along the second lattice vector. translate_upper ( tuple , default: (0, 0) ) \u2013 Translation vector (dx, dy) applied to the upper layer before rotation. pbc ( bool , default: True ) \u2013 Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k ( int , default: 1 ) \u2013 Number of orbitals on each lattice point. Source code in moirepy/moire.py def __init__( self, latticetype: Layer, ll1:int, ll2:int, # lower lattice ul1:int, ul2:int, # upper lattice n1:int=1, n2:int=1, translate_upper=(0, 0), pbc:bool=True, k:int=1, # number of orbitals ): \"\"\" Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Args: latticetype (Layer): A subclass of the `Layer` class representing the lattice type used for both layers. ll1, ll2, ul1, ul2 (int): Values select from the [AVC tool](https://jabed-umar.github.io/MoirePy/theory/avc/). n1 (int, optional): Number of moir\u00e9 cells along the first lattice vector. n2 (int, optional): Number of moir\u00e9 cells along the second lattice vector. translate_upper (tuple, optional): Translation vector (dx, dy) applied to the upper layer before rotation. pbc (bool, optional): Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k (int, optional): Number of orbitals on each lattice point. \"\"\" # study_proximity = 1 means only studying nearest neighbours will be enabled, # 2 means study of next nearest neighbours will be enabled too and so on, # always better to keep this value 1 or two more than what you will actually need. lower_lattice = latticetype(pbc=pbc) upper_lattice = latticetype(pbc=pbc) lv1, lv2 = lower_lattice.lv1, lower_lattice.lv2 # c = cos(theta) between lv1 and lv2 (60 degree for triangular, 90 for square and so on) c = np.dot(lv1, lv2) / (np.linalg.norm(lv1) * np.linalg.norm(lv2)) beta = np.arccos(c) mlv1 = ll1*lv1 + ll2*lv2 # because lower latice is fixed mlv2 = get_rotation_matrix(beta).dot(mlv1) # calculating the moire twist angle one = ll1*lv1 + ll2*lv2 # the coords of overlapping point in the lower lattice two = ul1*lv1 + ul2*lv2 # the coords of overlapping point in the upper lattice assert np.isclose(np.linalg.norm(one), np.linalg.norm(two)), \"INPUT ERROR: the two points are not overlapping, check ll1, ll2, ul1, ul2 values\" c = np.dot(one, two) / (np.linalg.norm(one) * np.linalg.norm(two)) theta = np.arccos(c) # in radians print(f\"twist angle = {theta:.4f} rad ({np.rad2deg(theta):.4f} deg)\") upper_lattice.perform_rotation_translation(theta, translate_upper) assert ( are_coeffs_integers(lower_lattice.lv1, lower_lattice.lv2, mlv1) and are_coeffs_integers(upper_lattice.lv1, upper_lattice.lv2, mlv1) ), \"FATAL ERROR: calculated mlv2 is incorrect\" lower_lattice.generate_points(mlv1, mlv2, n1, n2) upper_lattice.generate_points(mlv1, mlv2, n1, n2) # print(f\"{mlv1 = }\") # print(f\"{mlv2 = }\") self.ll1 = ll1 self.ll2 = ll2 self.ul1 = ul1 self.ul2 = ul2 self.n1 = n1 self.n2 = n2 self.translate_upper = translate_upper self.lower_lattice = lower_lattice self.upper_lattice = upper_lattice self.theta = theta self.mlv1 = mlv1 self.mlv2 = mlv2 self.pbc = pbc self.orbitals = k self.ham = None print(f\"{len(self.lower_lattice.points)} points in lower lattice\") print(f\"{len(self.upper_lattice.points)} points in upper lattice\") assert len(self.lower_lattice.points) == len(self.upper_lattice.points), \"FATAL ERROR: number of points in lower and upper lattice are not equal, take different ll1, ll2, ul1, ul2 values\"","title":"__init__"},{"location":"api/utils/","text":"are_coeffs_integers(v1, v2, v3, tol=1e-08) Solves a v1 + b v2 = v3 for scalars a and b using Cramer's Rule, and checks if both are integers (within a tolerance). v1, v2, v3 are lists or tuples or np arrays of length 2 Source code in moirepy/utils.py def are_coeffs_integers(v1, v2, v3, tol=1e-8): \"\"\" Solves a v1 + b v2 = v3 for scalars a and b using Cramer's Rule, and checks if both are integers (within a tolerance). v1, v2, v3 are lists or tuples or np arrays of length 2 \"\"\" a1, a2 = v1 b1, b2 = v2 c1, c2 = v3 det = a1 * b2 - a2 * b1 if abs(det) < tol: return False # no unique solution a = (c1 * b2 - c2 * b1) / det b = (a1 * c2 - a2 * c1) / det ret = abs(a - round(a)) < tol and abs(b - round(b)) < tol return ret get_rotation_matrix(theta_rad) Computes a 2D rotation matrix for a given angle. Parameters: theta_rad ( float ) \u2013 The rotation angle in radians. Returns: ndarray \u2013 np.ndarray: A 2x2 rotation matrix that rotates a point counterclockwise by theta_rad . >>> get_rotation_matrix(np.pi/2) array([[ 6.123234e-17, -1.000000e+00], [ 1.000000e+00, 6.123234e-17]]) Source code in moirepy/utils.py def get_rotation_matrix(theta_rad: float) -> np.ndarray: \"\"\" Computes a 2D rotation matrix for a given angle. Args: theta_rad (float): The rotation angle in radians. Returns: np.ndarray: A 2x2 rotation matrix that rotates a point counterclockwise by `theta_rad`. ```python >>> get_rotation_matrix(np.pi/2) array([[ 6.123234e-17, -1.000000e+00], [ 1.000000e+00, 6.123234e-17]]) ``` \"\"\" return np.array( [ [np.cos(theta_rad), -np.sin(theta_rad)], [np.sin(theta_rad), np.cos(theta_rad)] ] )","title":"Utils"},{"location":"api/utils/#moirepy.utils.are_coeffs_integers","text":"Solves a v1 + b v2 = v3 for scalars a and b using Cramer's Rule, and checks if both are integers (within a tolerance). v1, v2, v3 are lists or tuples or np arrays of length 2 Source code in moirepy/utils.py def are_coeffs_integers(v1, v2, v3, tol=1e-8): \"\"\" Solves a v1 + b v2 = v3 for scalars a and b using Cramer's Rule, and checks if both are integers (within a tolerance). v1, v2, v3 are lists or tuples or np arrays of length 2 \"\"\" a1, a2 = v1 b1, b2 = v2 c1, c2 = v3 det = a1 * b2 - a2 * b1 if abs(det) < tol: return False # no unique solution a = (c1 * b2 - c2 * b1) / det b = (a1 * c2 - a2 * c1) / det ret = abs(a - round(a)) < tol and abs(b - round(b)) < tol return ret","title":"are_coeffs_integers"},{"location":"api/utils/#moirepy.utils.get_rotation_matrix","text":"Computes a 2D rotation matrix for a given angle. Parameters: theta_rad ( float ) \u2013 The rotation angle in radians. Returns: ndarray \u2013 np.ndarray: A 2x2 rotation matrix that rotates a point counterclockwise by theta_rad . >>> get_rotation_matrix(np.pi/2) array([[ 6.123234e-17, -1.000000e+00], [ 1.000000e+00, 6.123234e-17]]) Source code in moirepy/utils.py def get_rotation_matrix(theta_rad: float) -> np.ndarray: \"\"\" Computes a 2D rotation matrix for a given angle. Args: theta_rad (float): The rotation angle in radians. Returns: np.ndarray: A 2x2 rotation matrix that rotates a point counterclockwise by `theta_rad`. ```python >>> get_rotation_matrix(np.pi/2) array([[ 6.123234e-17, -1.000000e+00], [ 1.000000e+00, 6.123234e-17]]) ``` \"\"\" return np.array( [ [np.cos(theta_rad), -np.sin(theta_rad)], [np.sin(theta_rad), np.cos(theta_rad)] ] )","title":"get_rotation_matrix"},{"location":"getting_started/gs_intro/","text":"Getting Started","title":"Getting Started"},{"location":"getting_started/gs_intro/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/installation/","text":".section{ text-align: justify; } Installation You can install the moirepy library using pip from the official PyPI library , the standard package installer for Python. This guide provides detailed installation instructions for various operating systems and environments. Prerequisites Before installing moirepy , ensure that you have the following: Python: It is highly recommended to use Python 3.12. While moirepy is generally compatible with Python versions greater than 3.7, comprehensive testing has been performed primarily with Python 3.12. Using this version will provide the most stable and reliable experience. pip: Pip usually comes bundled with Python installations. You can check if you have pip installed by opening your terminal or command prompt and running: pip --version If pip is not installed, you can find installation instructions in the official Python documentation here . Installation Instructions The most common way to install moirepy is using pip. Follow the instructions below for your operating system. Linux / macOS / Windows pip install moirepy or pip3 install moirepy or python3 -m pip install moirepy If you experience any problems during installation, please refer to the project's issue tracker on GitHub.","title":"Installation"},{"location":"getting_started/installation/#installation","text":"You can install the moirepy library using pip from the official PyPI library , the standard package installer for Python. This guide provides detailed installation instructions for various operating systems and environments.","title":"Installation"},{"location":"getting_started/installation/#prerequisites","text":"Before installing moirepy , ensure that you have the following: Python: It is highly recommended to use Python 3.12. While moirepy is generally compatible with Python versions greater than 3.7, comprehensive testing has been performed primarily with Python 3.12. Using this version will provide the most stable and reliable experience. pip: Pip usually comes bundled with Python installations. You can check if you have pip installed by opening your terminal or command prompt and running: pip --version If pip is not installed, you can find installation instructions in the official Python documentation here .","title":"Prerequisites"},{"location":"getting_started/installation/#installation-instructions","text":"The most common way to install moirepy is using pip. Follow the instructions below for your operating system. Linux / macOS / Windows pip install moirepy or pip3 install moirepy or python3 -m pip install moirepy If you experience any problems during installation, please refer to the project's issue tracker on GitHub.","title":"Installation Instructions"},{"location":"getting_started/moire_lattice_and_hamiltonian/","text":"Preparing Moir\u00e9 Lattice and it's Hamiltonian In the previous section, we learned how to prepare a lattice layer using the Layer class. Now, we will extend this knowledge to create a Moir\u00e9 lattice and its Hamiltonian. Generate Moir\u00e9 Lattice Assuming you have written your own Layer subclasses, for this tutorial we will use the inbuilt TriangleLayer for simplicity. We will create a bilayer Moir\u00e9 lattice using the BilayerMoireLattice class where both the lower and upper layers are of the same type ( TriangleLayer in this case). Warning For now we only support Moir\u00e9 lattices where both layers are of the same type. We will shortly add support for lattices with different types of layers. >>> # Import the necessary classes >>> from moirepy import BilayerMoireLattice, TriangularLayer >>> # Define the Moir\u00e9 lattice with two triangular layers >>> moire_lattice = BilayerMoireLattice( >>> latticetype=TriangularLayer, >>> ll1=9, ll2=10, >>> ul1=10, ul2=9, >>> n1=1, n2=1, # number of unit cells >>> ) twist angle = 0.0608 rad (3.4810 deg) 271 points in lower lattice 271 points in upper lattice >>> # Plot the Moir\u00e9 lattice >>> moire_lattice.plot_lattice() The values ll1 , ll2 , ul1 , and ul2 are supposed to be obtained from the Angle Value Calculator tool. In this page you have to input the layer types and the radius till which you want to search for overlaps. The tool will then search for all the overlaps and return the values of ll1 , ll2 , ul1 , and ul2 along with the twist angle and the number of points in each layer. Choose the appropriate values of ll1 , ll2 , ul1 , and ul2 based on the desired twist angle. For more information about the options that can be tweaked please check the related API reference. Obtain the real space Hamiltonian of this Moir\u00e9 lattice Obtaining the Hamiltonian in Moir\u00e9Py is as easy as calling the BilayerMoireLattice.generate_hamiltonian function with the intended hopping parameters. Let's see how: >>> # with the already generated `moire_lattice` >>> ham = moire_lattice.generate_hamiltonian( >>> tll=1, tuu=1, tlu=1, tul=1, >>> tuself=1, tlself=1, >>> ) >>> ham array([[1., 1., 0., ..., 0., 0., 0.], [1., 1., 1., ..., 0., 0., 0.], [0., 1., 1., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 1., 1., 0.], [0., 0., 0., ..., 1., 1., 1.], [0., 0., 0., ..., 0., 1., 1.]], shape=(542, 542)) The shape of the Hamiltonian is \\((n, n)\\) , where: \\[ \\begin{aligned} n &= \\text{\\#lattice points} \\times \\text{\\#orbitals per site } (=k) \\\\ &= (271_\\text{upper} + 271_\\text{lower}) \\times (k=1) = 542 \\end{aligned} \\] This matches the shape \\((542, 542)\\) shown in the example. let us now try visualising the obtained hamiltonian: >>> import matplotlib.pyplot as plt >>> plt.matshow(ham, cmap=\"gray\") Customising the Hopping Parameters The hopping parameters tll , tuu , tlu , tul , tuself , and tlself can be customized when generating the Hamiltonian. All of them can sure take float or integer values (as demonstrated above). But instead of that, you can pass a function as input to these parameters as well. Before seeing how to write that function, we need to understand what these parameters mean: tll : hopping between neighbours on lower lattice tuu : hopping between neighbours on upper lattice tlu : hopping from lower lattice to upper lattice tul : hopping from upper lattice to lower lattice tlself : on-site energy for lower lattice tuself : on-site energy for upper lattice for tll , tuu , tlu and tul we have to write a function that takes in these values: this_coo (float, float): 2D coordinate of the current site. neigh_coo (float, float): 2D coordinate of the neighboring site. this_type (string): Type of the current site (as defined in your sublattice.lattice_points ). neigh_type (string): Type of the neighboring site (as defined in sublattice.lattice_points ). The function should return the desired hopping value for the given pair of sites. This allows you to implement position or type-dependent hopping amplitudes. However in case of lattices with higher number of orbitals per site, you have to return a (k, k) shaped numpy array. More about this in Examples section. On the other hand tlself and tuself are single point operations. So they take in only two values: this_coo (int): The coordinate of the current site. this_type (string): The type of the current site (as defined in your sublattice.lattice_points ). Now let us look into an example: >>> def inter_layer_hopping(this_coo, neigh_coo, this_type, neigh_type): >>> distance_between_layers = 1 >>> this_coo_3D = np.array([*this_coo, 0]) >>> neigh_coo_3D = np.array([*neigh_coo, distance_between_layers]) >>> distance = np.linalg.norm(this_coo_3D - neigh_coo_3D) >>> # hopping parameter as a function of distance >>> return 4 * (distance - 1) >>> ham = moire_lattice.generate_hamiltonian( >>> tll=1, tuu=1, >>> tlu=inter_layer_hopping, >>> tul=inter_layer_hopping, >>> tuself=1, tlself=1 >>> ) >>> plt.matshow(ham, cmap=\"gray\") Note Although the inter_layer_hopping function takes in the values this_type and neigh_type , they are not used in this example. You can use them in your problem if you want, but not using them (as in this example) is perfectly fine too. However, you must take them as input parameters in the function definition. In case of PBC, the neigh_coo might not actually be a point in the lattice for boundary points. The actual neigbouring point might be on the other side of the boundary. This is a design choice in Moir\u00e9Py, and we think it is more intuitive to handle the periodic boundary conditions this way. However, if you want to get the actual neighbouring point in the lattice, we will add an example notebook for that (not yet done). We will explore more examples of custom hopping parameters, and interesting ways to use them in the Examples section. Obtaining the k-space Hamiltonian of this Moir\u00e9 lattice To obtain the k-space Hamiltonian, we can use the generate_kspace_hamiltonian method of the BilayerMoireLattice class. This method will compute the Hamiltonian in momentum space based on the real space Hamiltonian we generated earlier. The inputs are all the same as the ones we used for generating the real space Hamiltonian, but now we also need to specify a k point at which to evaluate the Hamiltonian. >>> kspace_ham = moire_lattice.generate_k_space_hamiltonian( >>> k = (0, 0), # k-point at which to evaluate the Hamiltonian >>> tll=1, tuu=1, >>> tlu=inter_layer_hopping, >>> tul=inter_layer_hopping, >>> tuself=1, tlself=1 >>> ) >>> kspace_ham array([[1.+0.j, 1.+0.j, 0.+0.j, ..., 0.+0.j, 0.+0.j, 0.+0.j], [1.+0.j, 1.+0.j, 1.+0.j, ..., 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 1.+0.j, 1.+0.j, ..., 0.+0.j, 0.+0.j, 0.+0.j], ..., [0.+0.j, 0.+0.j, 0.+0.j, ..., 1.+0.j, 1.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, ..., 1.+0.j, 1.+0.j, 1.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, ..., 0.+0.j, 1.+0.j, 1.+0.j]], shape=(542, 542)) The k-space Hamiltonian is by default a complex-valued matrix. The real hamiltonian is a real-valued matrix by default, but if you want to pass complex valued hopping parameters, you can do so after specifying data_type = np.complex128 in the generate_hamiltonian method. In this section, we have learned how to create a Moir\u00e9 lattice using the BilayerMoireLattice class and generate its Hamiltonian in both real and k-space. We also touched upon how to customize the hopping parameters using functions. This sets the foundation for further exploration of Moir\u00e9 lattices and their properties in Moir\u00e9Py. Currently, this is all we have in Moir\u00e9Py for Moir\u00e9 lattices. We will be adding more features and functionalities in the future as we continue to develop the library. Please raise issues on the GitHub repository if you have any suggestions, want to raise feature requests or encounter any problems. After calculating the Hamiltonians using MoirePy, we expect you to use other more specific libraries like numpy , scipy , kwant etc. to perform further analysis.","title":"Moir\u00e9 Lattice and Hamiltonian"},{"location":"getting_started/moire_lattice_and_hamiltonian/#preparing-moire-lattice-and-its-hamiltonian","text":"In the previous section, we learned how to prepare a lattice layer using the Layer class. Now, we will extend this knowledge to create a Moir\u00e9 lattice and its Hamiltonian.","title":"Preparing Moir\u00e9 Lattice and it's Hamiltonian"},{"location":"getting_started/moire_lattice_and_hamiltonian/#generate-moire-lattice","text":"Assuming you have written your own Layer subclasses, for this tutorial we will use the inbuilt TriangleLayer for simplicity. We will create a bilayer Moir\u00e9 lattice using the BilayerMoireLattice class where both the lower and upper layers are of the same type ( TriangleLayer in this case). Warning For now we only support Moir\u00e9 lattices where both layers are of the same type. We will shortly add support for lattices with different types of layers. >>> # Import the necessary classes >>> from moirepy import BilayerMoireLattice, TriangularLayer >>> # Define the Moir\u00e9 lattice with two triangular layers >>> moire_lattice = BilayerMoireLattice( >>> latticetype=TriangularLayer, >>> ll1=9, ll2=10, >>> ul1=10, ul2=9, >>> n1=1, n2=1, # number of unit cells >>> ) twist angle = 0.0608 rad (3.4810 deg) 271 points in lower lattice 271 points in upper lattice >>> # Plot the Moir\u00e9 lattice >>> moire_lattice.plot_lattice() The values ll1 , ll2 , ul1 , and ul2 are supposed to be obtained from the Angle Value Calculator tool. In this page you have to input the layer types and the radius till which you want to search for overlaps. The tool will then search for all the overlaps and return the values of ll1 , ll2 , ul1 , and ul2 along with the twist angle and the number of points in each layer. Choose the appropriate values of ll1 , ll2 , ul1 , and ul2 based on the desired twist angle. For more information about the options that can be tweaked please check the related API reference.","title":"Generate Moir\u00e9 Lattice"},{"location":"getting_started/moire_lattice_and_hamiltonian/#obtain-the-real-space-hamiltonian-of-this-moire-lattice","text":"Obtaining the Hamiltonian in Moir\u00e9Py is as easy as calling the BilayerMoireLattice.generate_hamiltonian function with the intended hopping parameters. Let's see how: >>> # with the already generated `moire_lattice` >>> ham = moire_lattice.generate_hamiltonian( >>> tll=1, tuu=1, tlu=1, tul=1, >>> tuself=1, tlself=1, >>> ) >>> ham array([[1., 1., 0., ..., 0., 0., 0.], [1., 1., 1., ..., 0., 0., 0.], [0., 1., 1., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 1., 1., 0.], [0., 0., 0., ..., 1., 1., 1.], [0., 0., 0., ..., 0., 1., 1.]], shape=(542, 542)) The shape of the Hamiltonian is \\((n, n)\\) , where: \\[ \\begin{aligned} n &= \\text{\\#lattice points} \\times \\text{\\#orbitals per site } (=k) \\\\ &= (271_\\text{upper} + 271_\\text{lower}) \\times (k=1) = 542 \\end{aligned} \\] This matches the shape \\((542, 542)\\) shown in the example. let us now try visualising the obtained hamiltonian: >>> import matplotlib.pyplot as plt >>> plt.matshow(ham, cmap=\"gray\")","title":"Obtain the real space Hamiltonian of this Moir\u00e9 lattice"},{"location":"getting_started/moire_lattice_and_hamiltonian/#customising-the-hopping-parameters","text":"The hopping parameters tll , tuu , tlu , tul , tuself , and tlself can be customized when generating the Hamiltonian. All of them can sure take float or integer values (as demonstrated above). But instead of that, you can pass a function as input to these parameters as well. Before seeing how to write that function, we need to understand what these parameters mean: tll : hopping between neighbours on lower lattice tuu : hopping between neighbours on upper lattice tlu : hopping from lower lattice to upper lattice tul : hopping from upper lattice to lower lattice tlself : on-site energy for lower lattice tuself : on-site energy for upper lattice for tll , tuu , tlu and tul we have to write a function that takes in these values: this_coo (float, float): 2D coordinate of the current site. neigh_coo (float, float): 2D coordinate of the neighboring site. this_type (string): Type of the current site (as defined in your sublattice.lattice_points ). neigh_type (string): Type of the neighboring site (as defined in sublattice.lattice_points ). The function should return the desired hopping value for the given pair of sites. This allows you to implement position or type-dependent hopping amplitudes. However in case of lattices with higher number of orbitals per site, you have to return a (k, k) shaped numpy array. More about this in Examples section. On the other hand tlself and tuself are single point operations. So they take in only two values: this_coo (int): The coordinate of the current site. this_type (string): The type of the current site (as defined in your sublattice.lattice_points ). Now let us look into an example: >>> def inter_layer_hopping(this_coo, neigh_coo, this_type, neigh_type): >>> distance_between_layers = 1 >>> this_coo_3D = np.array([*this_coo, 0]) >>> neigh_coo_3D = np.array([*neigh_coo, distance_between_layers]) >>> distance = np.linalg.norm(this_coo_3D - neigh_coo_3D) >>> # hopping parameter as a function of distance >>> return 4 * (distance - 1) >>> ham = moire_lattice.generate_hamiltonian( >>> tll=1, tuu=1, >>> tlu=inter_layer_hopping, >>> tul=inter_layer_hopping, >>> tuself=1, tlself=1 >>> ) >>> plt.matshow(ham, cmap=\"gray\") Note Although the inter_layer_hopping function takes in the values this_type and neigh_type , they are not used in this example. You can use them in your problem if you want, but not using them (as in this example) is perfectly fine too. However, you must take them as input parameters in the function definition. In case of PBC, the neigh_coo might not actually be a point in the lattice for boundary points. The actual neigbouring point might be on the other side of the boundary. This is a design choice in Moir\u00e9Py, and we think it is more intuitive to handle the periodic boundary conditions this way. However, if you want to get the actual neighbouring point in the lattice, we will add an example notebook for that (not yet done). We will explore more examples of custom hopping parameters, and interesting ways to use them in the Examples section.","title":"Customising the Hopping Parameters"},{"location":"getting_started/moire_lattice_and_hamiltonian/#obtaining-the-k-space-hamiltonian-of-this-moire-lattice","text":"To obtain the k-space Hamiltonian, we can use the generate_kspace_hamiltonian method of the BilayerMoireLattice class. This method will compute the Hamiltonian in momentum space based on the real space Hamiltonian we generated earlier. The inputs are all the same as the ones we used for generating the real space Hamiltonian, but now we also need to specify a k point at which to evaluate the Hamiltonian. >>> kspace_ham = moire_lattice.generate_k_space_hamiltonian( >>> k = (0, 0), # k-point at which to evaluate the Hamiltonian >>> tll=1, tuu=1, >>> tlu=inter_layer_hopping, >>> tul=inter_layer_hopping, >>> tuself=1, tlself=1 >>> ) >>> kspace_ham array([[1.+0.j, 1.+0.j, 0.+0.j, ..., 0.+0.j, 0.+0.j, 0.+0.j], [1.+0.j, 1.+0.j, 1.+0.j, ..., 0.+0.j, 0.+0.j, 0.+0.j], [0.+0.j, 1.+0.j, 1.+0.j, ..., 0.+0.j, 0.+0.j, 0.+0.j], ..., [0.+0.j, 0.+0.j, 0.+0.j, ..., 1.+0.j, 1.+0.j, 0.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, ..., 1.+0.j, 1.+0.j, 1.+0.j], [0.+0.j, 0.+0.j, 0.+0.j, ..., 0.+0.j, 1.+0.j, 1.+0.j]], shape=(542, 542)) The k-space Hamiltonian is by default a complex-valued matrix. The real hamiltonian is a real-valued matrix by default, but if you want to pass complex valued hopping parameters, you can do so after specifying data_type = np.complex128 in the generate_hamiltonian method. In this section, we have learned how to create a Moir\u00e9 lattice using the BilayerMoireLattice class and generate its Hamiltonian in both real and k-space. We also touched upon how to customize the hopping parameters using functions. This sets the foundation for further exploration of Moir\u00e9 lattices and their properties in Moir\u00e9Py. Currently, this is all we have in Moir\u00e9Py for Moir\u00e9 lattices. We will be adding more features and functionalities in the future as we continue to develop the library. Please raise issues on the GitHub repository if you have any suggestions, want to raise feature requests or encounter any problems. After calculating the Hamiltonians using MoirePy, we expect you to use other more specific libraries like numpy , scipy , kwant etc. to perform further analysis.","title":"Obtaining the k-space Hamiltonian of this Moir\u00e9 lattice"},{"location":"getting_started/prepare_layers/","text":"Prepare Layers After successfully installing MoirePy , this tutorial will walk you through the process of constructing moir\u00e9 lattices from individual lattice layers. As you may know, moir\u00e9 patterns emerge when two lattice layers are stacked with a slight rotational misalignment between them. In this guide, we'll start by defining individual layers using MoirePy, and then demonstrate how to combine them to generate a moir\u00e9 lattice. Prepare Layers Defining a layer Defining Some Example Lattices Square Lattice Kagome Lattice Inbuilt Layers Defining a layer We will start by importing the parent class Layer from MoirePy, which helps us define single layers. >>> import numpy as np >>> import matplotlib.pyplot as plt >>> from moirepy import Layer The Layer class handles tasks such as generating lattice points, identifying their neighbours, managing boundary conditions, efficiently searching for specific points in the lattice, and more. For Layer to work properly, we need to define the following properties of a lattice: Lattice vectors : These define the periodicity of the lattice. In MoirePy, they are named lv1 and lv2 . For simplicity, lv1 must lie along the \\(x\\) -direction, and lv2 must lie above the \\(x\\) -axis. This is a reasonable constraint, as any lattice can be expressed in this form. Lattice points : These are the points within the unit cell of the lattice. Each point is defined by its coordinates relative to the unit cell , along with a unique identifier (called a point type). The point type is useful for lattices with multiple points per unit cell (such as hexagonal or kagome lattices). Neighbours : This is a dictionary defining the neighbours of each lattice point. Each key is a point type, and its value is a list of vectors that represent the relative positions of the neighbouring points . Omitting even one of these properties will result in an error. Defining Some Example Lattices First, we will start with a simple square lattice, which has only one lattice point in the unit cell and four orthogonal neighbours. Then we will look at a more complex example \u2014 the kagome lattice \u2014 which has three lattice points in the unit cell and four neighbours each. Square Lattice Now let us define a square lattice using this Layer class. class SquareLayer(Layer): # Inherit the Layer class def __init__(self, pbc=False, study_proximity: int=1) -> None: self.lv1 = np.array([1, 0]) self.lv2 = np.array([0, 1]) self.lattice_points = ( # location of the point inside the unit cell [0, 0, \"A\"], # coo_x, coo_y, point_type (unique string) ) self.neighbours = { \"A\": [ [-1, 0], # Left [1, 0], # Right [0, 1], # Up [0, -1], # Down ], } # do not forget to initialise the parent class at the end super().__init__(pbc=pbc, study_proximity=study_proximity) Things to Note Make sure to define all required properties for the lattice. Remember to include super().__init__(pbc=pbc, study_proximity=study_proximity) at the end of your __init__ method to properly initialize the parent class. The values in self.neighbours are defined relative to the lattice points . So if the lattice point moves, the neighbour positions will automatically update \u2014 no manual changes needed. Now we can create an instance of this SquareLayer class: >>> square_layer = SquareLayer(pbc=True, study_proximity=1) >>> square_layer Layer( lv1 = [1 0], lv2 = [0 1], lattice_points = ([0, 0, 'A'],), pbc = True, ) Next, let us try plotting this lattice. First, we need to generate the points and then plot them. >>> square_layer.generate_points( >>> np.array([7, 0]), >>> np.array([0, 5]), >>> 1, 1, test=True >>> ) Making moir\u00e9 lattices requires precise cutting of the layers. This can only be done using the Moir\u00e9 lattice classes. Since we\u2019re cutting them arbitrarily here, we set test=True and mln1 = mln2 = 1 to prevent the system from freaking out. Now, we can either use the attributes square_layer.points and square_layer.point_types to manually plot the lattice, or \u2014 for quick testing \u2014 use the built-in Layer.plot_lattice() method. However, we encourage you to write your own customised plotting function to better suit your preferences. >>> square_layer.plot_lattice() Kagome Lattice Now let us look at a more complex lattice \u2014 the kagome lattice. This structure has three lattice points (A, B, and C, marked with red, blue, and green in the above image) in each unit cell. Each of them has four neighbours \u2014 two within the same cell and two in diagonally opposite positions to the first two. class KagomeLayer(Layer): def __init__(self, pbc=False, study_proximity: int=1) -> None: self.lv1 = np.array([1, 0]) # Lattice vector in the x-direction self.lv2 = np.array([0.5, np.sqrt(3)/2]) # Lattice vector at 60 degrees self.lattice_points = ( [0, 0, \"A\"], [0.5, 0, \"B\"], [0.25, np.sqrt(3)/4, \"C\"], ) self.neighbours = { \"A\": [ [ 0.5, 0], # Right [ 0.25, np.sqrt(3)/4], # Right-up [-0.5, 0], # Left [-0.25, -np.sqrt(3)/4], # Left-down ], \"B\": [ [ 0.5, 0], # Right [-0.25, np.sqrt(3)/4], # Left-up [-0.5, 0], # Left [ 0.25, -np.sqrt(3)/4], # Right-down ], \"C\": [ [ 0.25, np.sqrt(3)/4], # Right-up [-0.25, np.sqrt(3)/4], # Left-up [-0.25, -np.sqrt(3)/4], # Left-down [ 0.25, -np.sqrt(3)/4], # Right-down ], } super().__init__(pbc=pbc, study_proximity=study_proximity) Now let us plot this lattice as well. >>> kagome_layer = KagomeLayer(pbc=True, study_proximity=1) >>> kagome_layer.generate_points( >>> np.array([7, 0]), >>> np.array([0, 5]), >>> 1, 1, test=True, >>> ) >>> kagome_layer.plot_lattice() Inbuilt Layers Although we highly recommend defining your own layers for research purposes, MoirePy provides a few basic lattices for quick testing and prototyping. These are available in the moirepy.layers module. Here\u2019s a list of the available layers: moirepy.SquareLayer : A simple square lattice as shown above. moirepy.TriangularLayer : A triangular lattice with \\(60^\\circ\\) angles. moirepy.HexagonalLayer : A hexagonal lattice with \\(60^\\circ\\) angles and two points per unit cell. moirepy.KagomeLayer : A kagome lattice as shown above. Here are the blueprints of these lattices: Square Lattice Triangle Lattice Hexagon Lattice Kagome Lattice Now that you've seen how to define custom layers \u2014 and also explored the inbuilt ones \u2014 you should have a good understanding of how individual lattices are represented in MoirePy. We encourage you to experiment with creating your own layer classes suited to your specific research needs. The inbuilt layers are helpful for quick prototyping, but the real power of MoirePy lies in its flexibility. In this section we learned how to define custom layers using the Layer class. We also noted the inbuilt layers available in MoirePy for quick testing. In the next section, we\u2019ll explore how to combine two layers into a moir\u00e9 superlattice , and how to use these structures to build the tight-binding Hamiltonians and compute physical observables.","title":"Prepare Layers"},{"location":"getting_started/prepare_layers/#prepare-layers","text":"After successfully installing MoirePy , this tutorial will walk you through the process of constructing moir\u00e9 lattices from individual lattice layers. As you may know, moir\u00e9 patterns emerge when two lattice layers are stacked with a slight rotational misalignment between them. In this guide, we'll start by defining individual layers using MoirePy, and then demonstrate how to combine them to generate a moir\u00e9 lattice. Prepare Layers Defining a layer Defining Some Example Lattices Square Lattice Kagome Lattice Inbuilt Layers","title":"Prepare Layers"},{"location":"getting_started/prepare_layers/#defining-a-layer","text":"We will start by importing the parent class Layer from MoirePy, which helps us define single layers. >>> import numpy as np >>> import matplotlib.pyplot as plt >>> from moirepy import Layer The Layer class handles tasks such as generating lattice points, identifying their neighbours, managing boundary conditions, efficiently searching for specific points in the lattice, and more. For Layer to work properly, we need to define the following properties of a lattice: Lattice vectors : These define the periodicity of the lattice. In MoirePy, they are named lv1 and lv2 . For simplicity, lv1 must lie along the \\(x\\) -direction, and lv2 must lie above the \\(x\\) -axis. This is a reasonable constraint, as any lattice can be expressed in this form. Lattice points : These are the points within the unit cell of the lattice. Each point is defined by its coordinates relative to the unit cell , along with a unique identifier (called a point type). The point type is useful for lattices with multiple points per unit cell (such as hexagonal or kagome lattices). Neighbours : This is a dictionary defining the neighbours of each lattice point. Each key is a point type, and its value is a list of vectors that represent the relative positions of the neighbouring points . Omitting even one of these properties will result in an error.","title":"Defining a layer"},{"location":"getting_started/prepare_layers/#defining-some-example-lattices","text":"First, we will start with a simple square lattice, which has only one lattice point in the unit cell and four orthogonal neighbours. Then we will look at a more complex example \u2014 the kagome lattice \u2014 which has three lattice points in the unit cell and four neighbours each.","title":"Defining Some Example Lattices"},{"location":"getting_started/prepare_layers/#square-lattice","text":"Now let us define a square lattice using this Layer class. class SquareLayer(Layer): # Inherit the Layer class def __init__(self, pbc=False, study_proximity: int=1) -> None: self.lv1 = np.array([1, 0]) self.lv2 = np.array([0, 1]) self.lattice_points = ( # location of the point inside the unit cell [0, 0, \"A\"], # coo_x, coo_y, point_type (unique string) ) self.neighbours = { \"A\": [ [-1, 0], # Left [1, 0], # Right [0, 1], # Up [0, -1], # Down ], } # do not forget to initialise the parent class at the end super().__init__(pbc=pbc, study_proximity=study_proximity) Things to Note Make sure to define all required properties for the lattice. Remember to include super().__init__(pbc=pbc, study_proximity=study_proximity) at the end of your __init__ method to properly initialize the parent class. The values in self.neighbours are defined relative to the lattice points . So if the lattice point moves, the neighbour positions will automatically update \u2014 no manual changes needed. Now we can create an instance of this SquareLayer class: >>> square_layer = SquareLayer(pbc=True, study_proximity=1) >>> square_layer Layer( lv1 = [1 0], lv2 = [0 1], lattice_points = ([0, 0, 'A'],), pbc = True, ) Next, let us try plotting this lattice. First, we need to generate the points and then plot them. >>> square_layer.generate_points( >>> np.array([7, 0]), >>> np.array([0, 5]), >>> 1, 1, test=True >>> ) Making moir\u00e9 lattices requires precise cutting of the layers. This can only be done using the Moir\u00e9 lattice classes. Since we\u2019re cutting them arbitrarily here, we set test=True and mln1 = mln2 = 1 to prevent the system from freaking out. Now, we can either use the attributes square_layer.points and square_layer.point_types to manually plot the lattice, or \u2014 for quick testing \u2014 use the built-in Layer.plot_lattice() method. However, we encourage you to write your own customised plotting function to better suit your preferences. >>> square_layer.plot_lattice()","title":"Square Lattice"},{"location":"getting_started/prepare_layers/#kagome-lattice","text":"Now let us look at a more complex lattice \u2014 the kagome lattice. This structure has three lattice points (A, B, and C, marked with red, blue, and green in the above image) in each unit cell. Each of them has four neighbours \u2014 two within the same cell and two in diagonally opposite positions to the first two. class KagomeLayer(Layer): def __init__(self, pbc=False, study_proximity: int=1) -> None: self.lv1 = np.array([1, 0]) # Lattice vector in the x-direction self.lv2 = np.array([0.5, np.sqrt(3)/2]) # Lattice vector at 60 degrees self.lattice_points = ( [0, 0, \"A\"], [0.5, 0, \"B\"], [0.25, np.sqrt(3)/4, \"C\"], ) self.neighbours = { \"A\": [ [ 0.5, 0], # Right [ 0.25, np.sqrt(3)/4], # Right-up [-0.5, 0], # Left [-0.25, -np.sqrt(3)/4], # Left-down ], \"B\": [ [ 0.5, 0], # Right [-0.25, np.sqrt(3)/4], # Left-up [-0.5, 0], # Left [ 0.25, -np.sqrt(3)/4], # Right-down ], \"C\": [ [ 0.25, np.sqrt(3)/4], # Right-up [-0.25, np.sqrt(3)/4], # Left-up [-0.25, -np.sqrt(3)/4], # Left-down [ 0.25, -np.sqrt(3)/4], # Right-down ], } super().__init__(pbc=pbc, study_proximity=study_proximity) Now let us plot this lattice as well. >>> kagome_layer = KagomeLayer(pbc=True, study_proximity=1) >>> kagome_layer.generate_points( >>> np.array([7, 0]), >>> np.array([0, 5]), >>> 1, 1, test=True, >>> ) >>> kagome_layer.plot_lattice()","title":"Kagome Lattice"},{"location":"getting_started/prepare_layers/#inbuilt-layers","text":"Although we highly recommend defining your own layers for research purposes, MoirePy provides a few basic lattices for quick testing and prototyping. These are available in the moirepy.layers module. Here\u2019s a list of the available layers: moirepy.SquareLayer : A simple square lattice as shown above. moirepy.TriangularLayer : A triangular lattice with \\(60^\\circ\\) angles. moirepy.HexagonalLayer : A hexagonal lattice with \\(60^\\circ\\) angles and two points per unit cell. moirepy.KagomeLayer : A kagome lattice as shown above. Here are the blueprints of these lattices: Square Lattice Triangle Lattice Hexagon Lattice Kagome Lattice Now that you've seen how to define custom layers \u2014 and also explored the inbuilt ones \u2014 you should have a good understanding of how individual lattices are represented in MoirePy. We encourage you to experiment with creating your own layer classes suited to your specific research needs. The inbuilt layers are helpful for quick prototyping, but the real power of MoirePy lies in its flexibility. In this section we learned how to define custom layers using the Layer class. We also noted the inbuilt layers available in MoirePy for quick testing. In the next section, we\u2019ll explore how to combine two layers into a moir\u00e9 superlattice , and how to use these structures to build the tight-binding Hamiltonians and compute physical observables.","title":"Inbuilt Layers"},{"location":"theory/angle_calculation_process/","text":".section{ text-align: justify; } Angle Calculation Process When two single layers of a 2D material are stacked with a small misalignment, they produce a moir\u00e9 pattern with a length scale much larger than the periodicity of either individual layer. At specific twist angles, this results in a commensurate moir\u00e9 pattern \u2014a structure where atoms from one layer align exactly with those of the other. In this section, we describe how MoirePy calculates the commensurate rotation angles between two lattices confined to a bounded region. The goal is to identify angles where the lattices align periodically, producing well-ordered moir\u00e9 patterns that are physically observable. 1. Problem Statement Let lattices \\(A\\) and \\(B\\) be two periodic point sets in two dimensions, each defined by their respective lattice vectors. We address the following geometric question: Given a rotation angle \\(\\theta\\) , does there exist a point \\(\\mathbf{p} \\in A\\) and a point \\(\\mathbf{q} \\in B\\) such that \\[ \\mathbf{p} = R(\\theta)\\mathbf{q} \\tag{1.1} \\] where \\(R(\\theta)\\) denotes the standard rotation matrix. In 2D, this matrix is defined as: \\[ R(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\tag{1.2} \\] To bound the computation, we restrict our analysis to a finite region by considering only lattice points within a circular region of radius \\(r\\) . Let the truncated sets be \\(A_r = A \\cap \\text{circle}(r)\\) and \\(B_r = B \\cap \\text{circle}(r)\\) . Our goal is to determine the set of angles \\(\\theta\\) (including the corresponding points) for which there exists a pair of points \\(\\mathbf{p} \\in A_r\\) and \\(\\mathbf{q} \\in B_r\\) satisfying Equation 1.1. These angles correspond to commensurate alignments between the two lattices, yielding physically observable moir\u00e9 patterns. 2. Traditional Diophantine Equation Approach In commensurate moir\u00e9 superlattices, specific periodic points exist where atoms from the top and bottom layers align exactly. To analyze these alignments, let \\((\\vec{a}, \\vec{b})\\) and \\((\\vec{m}, \\vec{n})\\) denote the primitive lattice vectors of the lower and upper layers, respectively. The atomic positions in each layer are given by: \\[ \\vec{R}^1_{p,q} = a\\vec{a} + b\\vec{b} \\quad \\text{and} \\quad \\vec{R}^2_{m,n} = R(\\theta)(m\\vec{m} + n\\vec{n}), \\quad a, b, m, n \\in \\mathbb{Z} \\] Fig 1: Illustration of vector matching for commensurate moir\u00e9 patterns. Here vectors m and n are already rotated by angle theta. For a commensurate moir\u00e9 superlattice to form, there must exist integers \\(a, b, m, n\\) such that: \\[\\vec{R}^1_{p,q} = \\vec{R}^2_{m,n}\\] This leads to a condition based on vector magnitudes and orientations: \\[ \\vec{a} \\cdot \\vec{b} = \\vec{m} \\cdot \\vec{n} = \\cos{\\beta} = \\frac{m^2 + n^2 - a^2 - b^2}{2(ab - mn)} \\tag{2.1} \\] We need to find all integer quadruples (a, b, m, n) satisfying Equation 2.1. Then, the corresponding twist angle \\(\\theta\\) can then be computed. The computation proceeds as follows. The length of the moir\u00e9 lattice vector \\(\\vec{r}\\) connecting equivalent lattice points is: \\[ r = |\\vec{r}| = \\sqrt{a^2 + b^2 + 2ab\\cos\\beta} \\] Using the Law of Sines, we calculate the intermediate angles \\(\\alpha\\) and \\(\\gamma\\) : \\[ \\frac{b}{\\sin\\alpha} = \\frac{r}{\\sin(180^\\circ - \\beta)} \\quad \\Rightarrow \\quad \\alpha = \\sin^{-1}\\left(\\frac{b \\sin\\beta}{r}\\right) \\tag{2.2} \\] \\[ \\frac{n}{\\sin\\gamma} = \\frac{r}{\\sin(180^\\circ - \\beta)} \\quad \\Rightarrow \\quad \\gamma = \\sin^{-1}\\left(\\frac{n \\sin\\beta}{r}\\right) \\tag{2.3} \\] The twist angle \\(\\theta\\) between the two layers is then: \\[ \\theta = \\alpha - \\gamma = \\sin^{-1}\\left(\\frac{b \\sin\\beta}{r}\\right) - \\sin^{-1}\\left(\\frac{n \\sin\\beta}{r}\\right) \\] This classical Diophantine approach provides a rigorous framework for determining commensurate twist angles where the lattice vectors form periodic overlaps. Time Complexity The general approach involves iterating over all possible values of the first three variables ( \\(a\\) , \\(b\\) , \\(m\\) ) and computing the fourth variable ( \\(n\\) ) based on the condition in Equation 2.1. A valid solution exists when \\(n\\) is an integer. This brute-force search results in a time complexity of \\(O(n^3)\\) , where \\(n\\) represents the maximum value of the variables (starting from 0). For large \\(n\\) (i.e., when considering dense lattice points), this cubic complexity becomes computationally prohibitive. We wanted to find a better solution. Observations About Lattice Structure When examining regularly spaced lattices (like triangular or square lattices), we observed several useful structural properties. As shown in Fig. 2, lattice points naturally organize into concentric circles around the origin. If we sort all points by their distance from the origin, we see distinct discrete levels forming - similar to a step function. Each level (corresponding to a specific radius) contains symmetrically arranged points. For instance, in triangular lattices, each level contains a multiple of 6 points due to the lattice's 6-fold rotational symmetry (Fig. 3). (Similarly we see in Square lattice, a multiple of 4 points per level.) Fig 2: Lattice points reside in concentric circles Fig 3: Number of points in each shell is a multiple of 6 (Triangle lattice) This symmetric distribution has an important consequence: when two lattices share the same radial level, we only need to align one pair of points at that level. The remaining 5 symmetric points will automatically align due to the lattice symmetry, significantly reducing the computational effort needed to find commensurate angles. Our Method Our approach leverages lattice geometry and symmetry rather than algebraic equations to identify commensurate rotation angles. The method operates directly on the spatial distribution of lattice points, and hence is applicable for any regular lattice structure even stacking two different ones. Algorithm Overview Let \\(A_r\\) and \\(B_r\\) be the sets of lattice points (from lattice A and B respectively) within radius \\(r\\) from the origin. Group points by radius : For each point ( \\(\\mathbf{p}\\) ) in \\(A_r\\) and \\(B_r\\) , compute its distance \\(d = \\|\\mathbf{p}\\|\\) from the origin. In each lattice, group points that lie at the same radius into levels . Identify shared levels : Let \\(D = \\{d \\mid d \\text{ occurs in both } A_r \\text{ and } B_r \\} \\setminus \\{0\\}\\) . These are the radii at which both lattices have points. Filter by angular sector : For each \\(d \\in D\\) , consider only those points \\(\\{\\mathbf{p}\\} \\in A_r\\) and \\(\\{\\mathbf{q}\\} \\in B_r\\) on level \\(d\\) such that \\[ 0 < \\angle\\mathbf{p} \\le \\theta_\\text{max}, \\quad 0 < \\angle\\mathbf{q} \\le \\theta_\\text{max} \\] where \\(\\theta_\\text{max}\\) is the lattice's symmetry sector (e.g., \\(60^\\circ\\) for triangular lattices, \\(90^\\circ\\) for square lattices). Although till now we have discussed as if the upper lattice and lower lattice can be different, in practice we have never tested this code on different lattices. Neither do we know if those cases will yield any commensurate angles. For now, we will assume that both lattices are the same. So here when we say lattice's symmetry sector, we mean the symmetry sectors of both are same. Compute angle differences : Now we will pair points from \\(\\{\\mathbf{p}\\}\\) with \\(\\{\\mathbf{q}\\}\\) at each common level \\(D\\) . For each point from \\(\\{\\mathbf{p}\\}\\) , we will pair it with every point from \\(\\{\\mathbf{q}\\}\\) . For each pair, compute the angle differences. This procedure ensures we collect unique, minimal-angle configurations that could align under rotation, constrained to the symmetry of the lattice. Some Practical Optimizations In Step 4 after calculating the angle difference (say \\(\\theta\\)), we keep the angle only if it is in the range \\(0 < \\theta < \\theta_\\text{max}\\). Note that we exclude \\(0\\) because it corresponds to the trivial case where no rotation is applied, and we exclude \\(\\theta_\\text{max}\\) because it corresponds to the case where the two lattices are again perfectly aligned, as if no rotation is applied. Also we do not take angles more than \\(\\theta_\\text{max}\\) because they are equivalent to angles less than \\(\\theta_\\text{max}\\) due to periodicity. In Step 1 , when using same lattice as both upper and lower layer, after grouping points that lie at the same distance from the origin, we discard those \\(d\\)s who just have 6 points (4 points for square lattice). This is because it will lead us to no rotation anyway. We keep only those \\(d\\)s which have more than 6 points (12, 18, etc. for triangular lattice; 8, 12, etc. for square lattice) where we can form pairs of points that yield non-trivial angles. Time Complexity If the number points is of the order \\(O(n^2)\\) and they are sorted by distance, the time complexity of this part becomes \\(O(n^2 \\log n^2)\\) . Apart from this all other steps are multiple order smaller than this cost, hence can be ignored. That makes this algorithm much less than the \\(O(n^3)\\) of the Diophantine approach and arguably more intuitive. Calculating the lattice vectors given the overlapping points Summary We avoided solving Diophantine equations by leaning on geometry and symmetry: Points are grouped by radius Only overlapping radii are considered Pairwise angle differences yield the commensurate angles This makes MoirePy \u2019s angle detection both fast and visual , and opens up room for further optimizations or generalizations.","title":"Angle Calculation Process"},{"location":"theory/angle_calculation_process/#angle-calculation-process","text":"When two single layers of a 2D material are stacked with a small misalignment, they produce a moir\u00e9 pattern with a length scale much larger than the periodicity of either individual layer. At specific twist angles, this results in a commensurate moir\u00e9 pattern \u2014a structure where atoms from one layer align exactly with those of the other. In this section, we describe how MoirePy calculates the commensurate rotation angles between two lattices confined to a bounded region. The goal is to identify angles where the lattices align periodically, producing well-ordered moir\u00e9 patterns that are physically observable.","title":"Angle Calculation Process"},{"location":"theory/angle_calculation_process/#1-problem-statement","text":"Let lattices \\(A\\) and \\(B\\) be two periodic point sets in two dimensions, each defined by their respective lattice vectors. We address the following geometric question: Given a rotation angle \\(\\theta\\) , does there exist a point \\(\\mathbf{p} \\in A\\) and a point \\(\\mathbf{q} \\in B\\) such that \\[ \\mathbf{p} = R(\\theta)\\mathbf{q} \\tag{1.1} \\] where \\(R(\\theta)\\) denotes the standard rotation matrix. In 2D, this matrix is defined as: \\[ R(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\tag{1.2} \\] To bound the computation, we restrict our analysis to a finite region by considering only lattice points within a circular region of radius \\(r\\) . Let the truncated sets be \\(A_r = A \\cap \\text{circle}(r)\\) and \\(B_r = B \\cap \\text{circle}(r)\\) . Our goal is to determine the set of angles \\(\\theta\\) (including the corresponding points) for which there exists a pair of points \\(\\mathbf{p} \\in A_r\\) and \\(\\mathbf{q} \\in B_r\\) satisfying Equation 1.1. These angles correspond to commensurate alignments between the two lattices, yielding physically observable moir\u00e9 patterns.","title":"1. Problem Statement"},{"location":"theory/angle_calculation_process/#2-traditional-diophantine-equation-approach","text":"In commensurate moir\u00e9 superlattices, specific periodic points exist where atoms from the top and bottom layers align exactly. To analyze these alignments, let \\((\\vec{a}, \\vec{b})\\) and \\((\\vec{m}, \\vec{n})\\) denote the primitive lattice vectors of the lower and upper layers, respectively. The atomic positions in each layer are given by: \\[ \\vec{R}^1_{p,q} = a\\vec{a} + b\\vec{b} \\quad \\text{and} \\quad \\vec{R}^2_{m,n} = R(\\theta)(m\\vec{m} + n\\vec{n}), \\quad a, b, m, n \\in \\mathbb{Z} \\] Fig 1: Illustration of vector matching for commensurate moir\u00e9 patterns. Here vectors m and n are already rotated by angle theta. For a commensurate moir\u00e9 superlattice to form, there must exist integers \\(a, b, m, n\\) such that: \\[\\vec{R}^1_{p,q} = \\vec{R}^2_{m,n}\\] This leads to a condition based on vector magnitudes and orientations: \\[ \\vec{a} \\cdot \\vec{b} = \\vec{m} \\cdot \\vec{n} = \\cos{\\beta} = \\frac{m^2 + n^2 - a^2 - b^2}{2(ab - mn)} \\tag{2.1} \\] We need to find all integer quadruples (a, b, m, n) satisfying Equation 2.1. Then, the corresponding twist angle \\(\\theta\\) can then be computed. The computation proceeds as follows. The length of the moir\u00e9 lattice vector \\(\\vec{r}\\) connecting equivalent lattice points is: \\[ r = |\\vec{r}| = \\sqrt{a^2 + b^2 + 2ab\\cos\\beta} \\] Using the Law of Sines, we calculate the intermediate angles \\(\\alpha\\) and \\(\\gamma\\) : \\[ \\frac{b}{\\sin\\alpha} = \\frac{r}{\\sin(180^\\circ - \\beta)} \\quad \\Rightarrow \\quad \\alpha = \\sin^{-1}\\left(\\frac{b \\sin\\beta}{r}\\right) \\tag{2.2} \\] \\[ \\frac{n}{\\sin\\gamma} = \\frac{r}{\\sin(180^\\circ - \\beta)} \\quad \\Rightarrow \\quad \\gamma = \\sin^{-1}\\left(\\frac{n \\sin\\beta}{r}\\right) \\tag{2.3} \\] The twist angle \\(\\theta\\) between the two layers is then: \\[ \\theta = \\alpha - \\gamma = \\sin^{-1}\\left(\\frac{b \\sin\\beta}{r}\\right) - \\sin^{-1}\\left(\\frac{n \\sin\\beta}{r}\\right) \\] This classical Diophantine approach provides a rigorous framework for determining commensurate twist angles where the lattice vectors form periodic overlaps.","title":"2. Traditional Diophantine Equation Approach"},{"location":"theory/angle_calculation_process/#time-complexity","text":"The general approach involves iterating over all possible values of the first three variables ( \\(a\\) , \\(b\\) , \\(m\\) ) and computing the fourth variable ( \\(n\\) ) based on the condition in Equation 2.1. A valid solution exists when \\(n\\) is an integer. This brute-force search results in a time complexity of \\(O(n^3)\\) , where \\(n\\) represents the maximum value of the variables (starting from 0). For large \\(n\\) (i.e., when considering dense lattice points), this cubic complexity becomes computationally prohibitive. We wanted to find a better solution.","title":"Time Complexity"},{"location":"theory/angle_calculation_process/#observations-about-lattice-structure","text":"When examining regularly spaced lattices (like triangular or square lattices), we observed several useful structural properties. As shown in Fig. 2, lattice points naturally organize into concentric circles around the origin. If we sort all points by their distance from the origin, we see distinct discrete levels forming - similar to a step function. Each level (corresponding to a specific radius) contains symmetrically arranged points. For instance, in triangular lattices, each level contains a multiple of 6 points due to the lattice's 6-fold rotational symmetry (Fig. 3). (Similarly we see in Square lattice, a multiple of 4 points per level.) Fig 2: Lattice points reside in concentric circles Fig 3: Number of points in each shell is a multiple of 6 (Triangle lattice) This symmetric distribution has an important consequence: when two lattices share the same radial level, we only need to align one pair of points at that level. The remaining 5 symmetric points will automatically align due to the lattice symmetry, significantly reducing the computational effort needed to find commensurate angles.","title":"Observations About Lattice Structure"},{"location":"theory/angle_calculation_process/#our-method","text":"Our approach leverages lattice geometry and symmetry rather than algebraic equations to identify commensurate rotation angles. The method operates directly on the spatial distribution of lattice points, and hence is applicable for any regular lattice structure even stacking two different ones.","title":"Our Method"},{"location":"theory/angle_calculation_process/#algorithm-overview","text":"Let \\(A_r\\) and \\(B_r\\) be the sets of lattice points (from lattice A and B respectively) within radius \\(r\\) from the origin. Group points by radius : For each point ( \\(\\mathbf{p}\\) ) in \\(A_r\\) and \\(B_r\\) , compute its distance \\(d = \\|\\mathbf{p}\\|\\) from the origin. In each lattice, group points that lie at the same radius into levels . Identify shared levels : Let \\(D = \\{d \\mid d \\text{ occurs in both } A_r \\text{ and } B_r \\} \\setminus \\{0\\}\\) . These are the radii at which both lattices have points. Filter by angular sector : For each \\(d \\in D\\) , consider only those points \\(\\{\\mathbf{p}\\} \\in A_r\\) and \\(\\{\\mathbf{q}\\} \\in B_r\\) on level \\(d\\) such that \\[ 0 < \\angle\\mathbf{p} \\le \\theta_\\text{max}, \\quad 0 < \\angle\\mathbf{q} \\le \\theta_\\text{max} \\] where \\(\\theta_\\text{max}\\) is the lattice's symmetry sector (e.g., \\(60^\\circ\\) for triangular lattices, \\(90^\\circ\\) for square lattices). Although till now we have discussed as if the upper lattice and lower lattice can be different, in practice we have never tested this code on different lattices. Neither do we know if those cases will yield any commensurate angles. For now, we will assume that both lattices are the same. So here when we say lattice's symmetry sector, we mean the symmetry sectors of both are same. Compute angle differences : Now we will pair points from \\(\\{\\mathbf{p}\\}\\) with \\(\\{\\mathbf{q}\\}\\) at each common level \\(D\\) . For each point from \\(\\{\\mathbf{p}\\}\\) , we will pair it with every point from \\(\\{\\mathbf{q}\\}\\) . For each pair, compute the angle differences. This procedure ensures we collect unique, minimal-angle configurations that could align under rotation, constrained to the symmetry of the lattice. Some Practical Optimizations In Step 4 after calculating the angle difference (say \\(\\theta\\)), we keep the angle only if it is in the range \\(0 < \\theta < \\theta_\\text{max}\\). Note that we exclude \\(0\\) because it corresponds to the trivial case where no rotation is applied, and we exclude \\(\\theta_\\text{max}\\) because it corresponds to the case where the two lattices are again perfectly aligned, as if no rotation is applied. Also we do not take angles more than \\(\\theta_\\text{max}\\) because they are equivalent to angles less than \\(\\theta_\\text{max}\\) due to periodicity. In Step 1 , when using same lattice as both upper and lower layer, after grouping points that lie at the same distance from the origin, we discard those \\(d\\)s who just have 6 points (4 points for square lattice). This is because it will lead us to no rotation anyway. We keep only those \\(d\\)s which have more than 6 points (12, 18, etc. for triangular lattice; 8, 12, etc. for square lattice) where we can form pairs of points that yield non-trivial angles.","title":"Algorithm Overview"},{"location":"theory/angle_calculation_process/#time-complexity_1","text":"If the number points is of the order \\(O(n^2)\\) and they are sorted by distance, the time complexity of this part becomes \\(O(n^2 \\log n^2)\\) . Apart from this all other steps are multiple order smaller than this cost, hence can be ignored. That makes this algorithm much less than the \\(O(n^3)\\) of the Diophantine approach and arguably more intuitive.","title":"Time Complexity"},{"location":"theory/angle_calculation_process/#calculating-the-lattice-vectors-given-the-overlapping-points","text":"","title":"Calculating the lattice vectors given the overlapping points"},{"location":"theory/angle_calculation_process/#summary","text":"We avoided solving Diophantine equations by leaning on geometry and symmetry: Points are grouped by radius Only overlapping radii are considered Pairwise angle differences yield the commensurate angles This makes MoirePy \u2019s angle detection both fast and visual , and opens up room for further optimizations or generalizations.","title":"Summary"},{"location":"theory/avc/","text":".input-form { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; } input, select, button { font-size: 16px; padding: 5px; } button { cursor: pointer; background-color: rgb(41, 128, 185); color: white; border: none; padding: 10px; } table { width: 100%; border-collapse: collapse; margin-top: 20px; } th, td { padding: 8px; text-align: center; border: 1px solid #ddd; } thead { background-color: #f2f2f2; } .hidden { display: none; } .vector-inputs input { width: 80px; margin: 5px; } #end, #start { border: 1px solid #000; border-radius: 5px; padding: 8px; width: 100px; font-size: 16px; } .section{ text-align: justify; } Angle Value Calculator The Moir\u00e9 Angle Calculator finds all possible commensurate angles between two stacked lattices by trimming both layers within a given radius and checking for periodic overlaps following the Angle Calculation Process . After calculation, it provides a list of angles with their corresponding ll1 , ll2 , ul1 , ul2 values that define the rotation between the two lattices along with the number of points in each cell of the Moir\u00e9 lattice. Since most angles are irrational and can't be precisely represented, the rotation is defined using these coordinate pairs instead \u2014 they mark the overlapping points between the two lattices. Once you've selected an angle from the list, just copy the ll1 , ll2 , ul1 , and ul2 values into your code \u2014 the system will figure out the exact rotation angle from that. This also makes it easy to calculate the moire lattice vectors. Some Guidelines A radius must be specified to define the extent of the circular region centred at the origin. This value is used to truncate both the upper and lower lattices. Larger radius Includes more lattice points, potentially giving more precise calculations and revealing smaller angles, but increases computation time. Smaller radius Produces faster results, yet may detect only larger angle values. Currently supported systems: Both layers 60 \\(^\\circ\\) (Triangular, Hexagonal and Kagome lattices) Both layers 90 \\(^\\circ\\) (Square lattice) Custom mode \u2013 experimental Possible problems - Erroneous or nonsensical output - Unresponsiveness or infinite loops - Unexpected program behaviour Proceed only if you believe the results yielded by the Angle Calculation Process are correct and meaningful for your custom lattice vectors. Larger Value of points per cell More points per cell in the lattice means larger hamiltonian matrix, which can lead to longer computation times and higher memory usage. Especially if planning to invert the hamiltonian matrix and find eigenvalues and eigenvectors later. Number of Points has been calculated assuming only one point per unit cell. If you are using lattices which have multiple points per unit cell like hexagonal (2) or kagome (3), multiply this value by the number of points per unit cell in your lattice to get the actual number of points in the Moir\u00e9 lattice. Precision has NO effect on the calculation . It only affects the output format of the results. (In the calculation, we stick to integer values to avoid floating point errors). Calculator Radius: Lattice Type: both layers 60 degree (Triangular, Hexagonal and Kagome lattice) both layers 90 degree (Square lattice) Custom (experimental) Lattice Vectors for Layer 1: lv1: x + y lv2: x + y Lattice Vectors for Layer 2: lv1: x + y lv2: x + y WARNING: RESULTS MIGHT BE MEANINGLESS OR INACCURATE Precision: 6 CALCULATE Note The last column (number of points per unit cell in the Moir\u00e9 lattice) has been calculated assuming only one point per unit cell. If you are using lattices which have multiple points per unit cell like hexagonal (2) or kagome (3), multiply this value by the number of points per unit cell in your lattice to get the actual number of points in the Moir\u00e9 lattice. angle (deg) angle (rad) ll1 ll2 ul1 ul2 points/cell let root3 = Math.sqrt(3); const latticeDefaults = { HexagonalLayer: [1, 0, 0.5, root3 / 2], SquareLayer: [1, 0, 0, 1], RhombusLayer: [1, 0, 0.5, root3 / 2], TriangularLayer: [1, 0, 0.5, root3 / 2], KagomeLayer: [1, 0, 0.5, root3 / 2], }; document.getElementById(\"precision\").addEventListener(\"input\", function() { document.getElementById(\"precision-value\").textContent = this.value; }); function updateLatticeVectors() { const type = document.getElementById(\"latticeType\").value; const customDiv = document.getElementById(\"custom-vectors\"); if (type === \"Custom\") { customDiv.classList.remove(\"hidden\"); } else { customDiv.classList.add(\"hidden\"); const vec = latticeDefaults[type] || [1, 1, 1, 1]; // Set both layers with the same vectors document.getElementById(\"layer1-lv1x\").value = vec[0]; document.getElementById(\"layer1-lv1y\").value = vec[1]; document.getElementById(\"layer1-lv2x\").value = vec[2]; document.getElementById(\"layer1-lv2y\").value = vec[3]; document.getElementById(\"layer2-lv1x\").value = vec[0]; document.getElementById(\"layer2-lv1y\").value = vec[1]; document.getElementById(\"layer2-lv2x\").value = vec[2]; document.getElementById(\"layer2-lv2y\").value = vec[3]; } } function gcd(x, y) { if (y === 0) return x; else return gcd(y, x % y); } function angleId(p1, p2) { // Dot product const dot = p1[0] * p2[0] + p1[1] * p2[1]; const dotSq = dot * dot; // Norms squared const norm1Sq = p1[0] ** 2 + p1[1] ** 2; const norm2Sq = p2[0] ** 2 + p2[1] ** 2; const denom = norm1Sq * norm2Sq; // Reduce the fraction dotSq / denom const commonDivisor = gcd(dotSq, denom); const num = dotSq / commonDivisor; const den = denom / commonDivisor; // Return as a string ID return `${num}/${den}`; } function calculate() { const radius = parseInt(document.getElementById(\"radius\").value); const layer1Vectors = [ parseFloat(document.getElementById(\"layer1-lv1x\").value), parseFloat(document.getElementById(\"layer1-lv1y\").value), parseFloat(document.getElementById(\"layer1-lv2x\").value), parseFloat(document.getElementById(\"layer1-lv2y\").value) ]; const layer2Vectors = [ parseFloat(document.getElementById(\"layer2-lv1x\").value), parseFloat(document.getElementById(\"layer2-lv1y\").value), parseFloat(document.getElementById(\"layer2-lv2x\").value), parseFloat(document.getElementById(\"layer2-lv2y\").value) ]; const precision = parseInt(document.getElementById(\"precision\").value); // console.log(radius, layer1Vectors, layer2Vectors); const results = find_values(radius, layer1Vectors, layer2Vectors, tol=precision); console.log(results); console.log(\"Number of results:\", results.length); displayResults_(results); } function calc_indices(p, lv1, lv2) { const [a, b] = lv1; const [c, d] = lv2; const [x, y] = p; const det = (a * d - b * c); const nx = (d * x - c * y) / det; const ny = (a * y - b * x) / det; if (Math.abs(Math.round(nx) - nx) > 1e-5 || Math.abs(Math.round(ny) - ny) > 1e-5) { throw new Error(`Calculation error for indices: ${nx}, ${ny}`); } return [Math.round(nx), Math.round(ny)]; } function generate_lattice_points(lv1, lv2, radius) { const points = []; const maxGridSize = Math.floor(radius / Math.abs(lv2[1])) + 5; // console.log(radius, lv1, lv2, maxGridSize); for (let i = -maxGridSize; i <= maxGridSize; i++) { for (let j = -maxGridSize; j <= maxGridSize; j++) { // console.log(i, j); const point = [i * lv1[0] + j * lv2[0], i * lv1[1] + j * lv2[1]]; const dist = Math.sqrt(point[0] ** 2 + point[1] ** 2); if (dist <= radius) points.push(point); } } return points; } function angle_from_x(p) { return Math.atan2(p[1], p[0]) * 180 / Math.PI; } function process_lattice(points, tol) { const distances = points.map(p => Math.hypot(p[0], p[1])); const distMap = new Map(); // console.log(distMap); for (let i = 0; i < points.length; i++) { const d = parseFloat(distances[i].toFixed(tol)); if (!distMap.has(d)) distMap.set(d, {}); distMap.get(d)[i] = points[i]; } return [distMap, new Set([...distMap.keys()])]; } function find_values(radius, layer1Vectors, layer2Vectors, tol = 6) { const [a1x, a1y, b1x, b1y] = layer1Vectors; const [a2x, a2y, b2x, b2y] = layer2Vectors; if (JSON.stringify(layer1Vectors) !== JSON.stringify(layer2Vectors)) { alert(\"Warning: Vectors are not identical! Results might be inaccurate or meaningless.\"); } const lv1 = [a1x, a1y]; const lv2 = [b1x, b1y]; const lattice1 = generate_lattice_points(lv1, lv2, radius); const lattice2 = generate_lattice_points(lv1, lv2, radius); const [dict1, dist_set1] = process_lattice(lattice1, tol); const [dict2, dist_set2] = process_lattice(lattice2, tol); const common_dists = [...dist_set1].filter(d => dist_set2.has(d)).sort((a, b) => a - b).slice(1); const angle_dict = {}; const lattice_angle = angle_from_x(lv2) - angle_from_x(lv1); const isValidTheta = (theta) => theta > 0 && theta < lattice_angle; for (const d of common_dists) { // console.log(d) const pts1 = Object.values(dict1.get(d)).filter(p => isValidTheta(angle_from_x(p))); const pts2 = Object.values(dict2.get(d)).filter(p => isValidTheta(angle_from_x(p))); for (const p1 of pts1) { const theta1 = parseFloat(angle_from_x(p1).toFixed(tol)); for (const p2 of pts2) { const theta2 = parseFloat(angle_from_x(p2)); const angle = parseFloat((theta2 - theta1)); // use cos theta square between p1 and p2 as uid const uid = angleId(p1, p2); if ( theta2 <= theta1 || angle < Math.pow(10, -tol) || uid in angle_dict ) continue; angle_dict[uid] = [p1, p2, angle]; } } } const results = Object.entries(angle_dict) .sort(([, a], [, b]) => parseFloat(a[2]) - parseFloat(b[2])) // ascending by angle .map(([k, [p1, p2, angle]]) => { const thetaRad = (parseFloat(angle) * Math.PI) / 180; const thetaDeg = parseFloat(angle); const [i1, j1] = calc_indices(p1, lv1, lv2); const [i2, j2] = calc_indices(p2, lv1, lv2); const num_pts = 2*(p1[0] * p1[0] + p1[1] * p1[1]) * 1; // 1 for one point per unit cell return [thetaDeg.toFixed(tol), thetaRad.toFixed(tol), i2, j2, i1, j1, num_pts]; }); return results; } function displayResults_(results) { const resultsBody = document.getElementById(\"results-body\"); resultsBody.innerHTML = \"\"; // Clear previous results results.forEach((tuple, index) => { const row = document.createElement(\"tr\"); const cell = document.createElement(\"td\"); cell.textContent = index + 1; // add the index row.appendChild(cell); tuple.forEach(value => { const cell = document.createElement(\"td\"); cell.textContent = value; row.appendChild(cell); }); resultsBody.appendChild(row); }); } updateLatticeVectors('layer1'); updateLatticeVectors('layer2');","title":"Angle Value Calculator"},{"location":"theory/avc/#angle-value-calculator","text":"The Moir\u00e9 Angle Calculator finds all possible commensurate angles between two stacked lattices by trimming both layers within a given radius and checking for periodic overlaps following the Angle Calculation Process . After calculation, it provides a list of angles with their corresponding ll1 , ll2 , ul1 , ul2 values that define the rotation between the two lattices along with the number of points in each cell of the Moir\u00e9 lattice. Since most angles are irrational and can't be precisely represented, the rotation is defined using these coordinate pairs instead \u2014 they mark the overlapping points between the two lattices. Once you've selected an angle from the list, just copy the ll1 , ll2 , ul1 , and ul2 values into your code \u2014 the system will figure out the exact rotation angle from that. This also makes it easy to calculate the moire lattice vectors. Some Guidelines A radius must be specified to define the extent of the circular region centred at the origin. This value is used to truncate both the upper and lower lattices. Larger radius Includes more lattice points, potentially giving more precise calculations and revealing smaller angles, but increases computation time. Smaller radius Produces faster results, yet may detect only larger angle values. Currently supported systems: Both layers 60 \\(^\\circ\\) (Triangular, Hexagonal and Kagome lattices) Both layers 90 \\(^\\circ\\) (Square lattice) Custom mode \u2013 experimental Possible problems - Erroneous or nonsensical output - Unresponsiveness or infinite loops - Unexpected program behaviour Proceed only if you believe the results yielded by the Angle Calculation Process are correct and meaningful for your custom lattice vectors. Larger Value of points per cell More points per cell in the lattice means larger hamiltonian matrix, which can lead to longer computation times and higher memory usage. Especially if planning to invert the hamiltonian matrix and find eigenvalues and eigenvectors later. Number of Points has been calculated assuming only one point per unit cell. If you are using lattices which have multiple points per unit cell like hexagonal (2) or kagome (3), multiply this value by the number of points per unit cell in your lattice to get the actual number of points in the Moir\u00e9 lattice. Precision has NO effect on the calculation . It only affects the output format of the results. (In the calculation, we stick to integer values to avoid floating point errors).","title":"Angle Value Calculator"},{"location":"theory/avc/#calculator","text":"Radius: Lattice Type: both layers 60 degree (Triangular, Hexagonal and Kagome lattice) both layers 90 degree (Square lattice) Custom (experimental) Lattice Vectors for Layer 1: lv1: x + y lv2: x + y Lattice Vectors for Layer 2: lv1: x + y lv2: x + y WARNING: RESULTS MIGHT BE MEANINGLESS OR INACCURATE Precision: 6 CALCULATE Note The last column (number of points per unit cell in the Moir\u00e9 lattice) has been calculated assuming only one point per unit cell. If you are using lattices which have multiple points per unit cell like hexagonal (2) or kagome (3), multiply this value by the number of points per unit cell in your lattice to get the actual number of points in the Moir\u00e9 lattice. angle (deg) angle (rad) ll1 ll2 ul1 ul2 points/cell let root3 = Math.sqrt(3); const latticeDefaults = { HexagonalLayer: [1, 0, 0.5, root3 / 2], SquareLayer: [1, 0, 0, 1], RhombusLayer: [1, 0, 0.5, root3 / 2], TriangularLayer: [1, 0, 0.5, root3 / 2], KagomeLayer: [1, 0, 0.5, root3 / 2], }; document.getElementById(\"precision\").addEventListener(\"input\", function() { document.getElementById(\"precision-value\").textContent = this.value; }); function updateLatticeVectors() { const type = document.getElementById(\"latticeType\").value; const customDiv = document.getElementById(\"custom-vectors\"); if (type === \"Custom\") { customDiv.classList.remove(\"hidden\"); } else { customDiv.classList.add(\"hidden\"); const vec = latticeDefaults[type] || [1, 1, 1, 1]; // Set both layers with the same vectors document.getElementById(\"layer1-lv1x\").value = vec[0]; document.getElementById(\"layer1-lv1y\").value = vec[1]; document.getElementById(\"layer1-lv2x\").value = vec[2]; document.getElementById(\"layer1-lv2y\").value = vec[3]; document.getElementById(\"layer2-lv1x\").value = vec[0]; document.getElementById(\"layer2-lv1y\").value = vec[1]; document.getElementById(\"layer2-lv2x\").value = vec[2]; document.getElementById(\"layer2-lv2y\").value = vec[3]; } } function gcd(x, y) { if (y === 0) return x; else return gcd(y, x % y); } function angleId(p1, p2) { // Dot product const dot = p1[0] * p2[0] + p1[1] * p2[1]; const dotSq = dot * dot; // Norms squared const norm1Sq = p1[0] ** 2 + p1[1] ** 2; const norm2Sq = p2[0] ** 2 + p2[1] ** 2; const denom = norm1Sq * norm2Sq; // Reduce the fraction dotSq / denom const commonDivisor = gcd(dotSq, denom); const num = dotSq / commonDivisor; const den = denom / commonDivisor; // Return as a string ID return `${num}/${den}`; } function calculate() { const radius = parseInt(document.getElementById(\"radius\").value); const layer1Vectors = [ parseFloat(document.getElementById(\"layer1-lv1x\").value), parseFloat(document.getElementById(\"layer1-lv1y\").value), parseFloat(document.getElementById(\"layer1-lv2x\").value), parseFloat(document.getElementById(\"layer1-lv2y\").value) ]; const layer2Vectors = [ parseFloat(document.getElementById(\"layer2-lv1x\").value), parseFloat(document.getElementById(\"layer2-lv1y\").value), parseFloat(document.getElementById(\"layer2-lv2x\").value), parseFloat(document.getElementById(\"layer2-lv2y\").value) ]; const precision = parseInt(document.getElementById(\"precision\").value); // console.log(radius, layer1Vectors, layer2Vectors); const results = find_values(radius, layer1Vectors, layer2Vectors, tol=precision); console.log(results); console.log(\"Number of results:\", results.length); displayResults_(results); } function calc_indices(p, lv1, lv2) { const [a, b] = lv1; const [c, d] = lv2; const [x, y] = p; const det = (a * d - b * c); const nx = (d * x - c * y) / det; const ny = (a * y - b * x) / det; if (Math.abs(Math.round(nx) - nx) > 1e-5 || Math.abs(Math.round(ny) - ny) > 1e-5) { throw new Error(`Calculation error for indices: ${nx}, ${ny}`); } return [Math.round(nx), Math.round(ny)]; } function generate_lattice_points(lv1, lv2, radius) { const points = []; const maxGridSize = Math.floor(radius / Math.abs(lv2[1])) + 5; // console.log(radius, lv1, lv2, maxGridSize); for (let i = -maxGridSize; i <= maxGridSize; i++) { for (let j = -maxGridSize; j <= maxGridSize; j++) { // console.log(i, j); const point = [i * lv1[0] + j * lv2[0], i * lv1[1] + j * lv2[1]]; const dist = Math.sqrt(point[0] ** 2 + point[1] ** 2); if (dist <= radius) points.push(point); } } return points; } function angle_from_x(p) { return Math.atan2(p[1], p[0]) * 180 / Math.PI; } function process_lattice(points, tol) { const distances = points.map(p => Math.hypot(p[0], p[1])); const distMap = new Map(); // console.log(distMap); for (let i = 0; i < points.length; i++) { const d = parseFloat(distances[i].toFixed(tol)); if (!distMap.has(d)) distMap.set(d, {}); distMap.get(d)[i] = points[i]; } return [distMap, new Set([...distMap.keys()])]; } function find_values(radius, layer1Vectors, layer2Vectors, tol = 6) { const [a1x, a1y, b1x, b1y] = layer1Vectors; const [a2x, a2y, b2x, b2y] = layer2Vectors; if (JSON.stringify(layer1Vectors) !== JSON.stringify(layer2Vectors)) { alert(\"Warning: Vectors are not identical! Results might be inaccurate or meaningless.\"); } const lv1 = [a1x, a1y]; const lv2 = [b1x, b1y]; const lattice1 = generate_lattice_points(lv1, lv2, radius); const lattice2 = generate_lattice_points(lv1, lv2, radius); const [dict1, dist_set1] = process_lattice(lattice1, tol); const [dict2, dist_set2] = process_lattice(lattice2, tol); const common_dists = [...dist_set1].filter(d => dist_set2.has(d)).sort((a, b) => a - b).slice(1); const angle_dict = {}; const lattice_angle = angle_from_x(lv2) - angle_from_x(lv1); const isValidTheta = (theta) => theta > 0 && theta < lattice_angle; for (const d of common_dists) { // console.log(d) const pts1 = Object.values(dict1.get(d)).filter(p => isValidTheta(angle_from_x(p))); const pts2 = Object.values(dict2.get(d)).filter(p => isValidTheta(angle_from_x(p))); for (const p1 of pts1) { const theta1 = parseFloat(angle_from_x(p1).toFixed(tol)); for (const p2 of pts2) { const theta2 = parseFloat(angle_from_x(p2)); const angle = parseFloat((theta2 - theta1)); // use cos theta square between p1 and p2 as uid const uid = angleId(p1, p2); if ( theta2 <= theta1 || angle < Math.pow(10, -tol) || uid in angle_dict ) continue; angle_dict[uid] = [p1, p2, angle]; } } } const results = Object.entries(angle_dict) .sort(([, a], [, b]) => parseFloat(a[2]) - parseFloat(b[2])) // ascending by angle .map(([k, [p1, p2, angle]]) => { const thetaRad = (parseFloat(angle) * Math.PI) / 180; const thetaDeg = parseFloat(angle); const [i1, j1] = calc_indices(p1, lv1, lv2); const [i2, j2] = calc_indices(p2, lv1, lv2); const num_pts = 2*(p1[0] * p1[0] + p1[1] * p1[1]) * 1; // 1 for one point per unit cell return [thetaDeg.toFixed(tol), thetaRad.toFixed(tol), i2, j2, i1, j1, num_pts]; }); return results; } function displayResults_(results) { const resultsBody = document.getElementById(\"results-body\"); resultsBody.innerHTML = \"\"; // Clear previous results results.forEach((tuple, index) => { const row = document.createElement(\"tr\"); const cell = document.createElement(\"td\"); cell.textContent = index + 1; // add the index row.appendChild(cell); tuple.forEach(value => { const cell = document.createElement(\"td\"); cell.textContent = value; row.appendChild(cell); }); resultsBody.appendChild(row); }); } updateLatticeVectors('layer1'); updateLatticeVectors('layer2');","title":"Calculator"},{"location":"theory/search_algorithm_kdtree/","text":"Searching Algorithm & KDTree","title":"Searching Algorithm & KDTree"},{"location":"theory/search_algorithm_kdtree/#searching-algorithm-kdtree","text":"","title":"Searching Algorithm &amp; KDTree"},{"location":"theory/theory_intro/","text":"Theoretical Background","title":"Theoretical Background"},{"location":"theory/theory_intro/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"theory/tight_binding_ham/","text":"Tight Binding Moir\u00e9 Hamiltonian Construction The tight-binding Hamiltonian 1 is a widely used model in solid-state physics and quantum chemistry to describe the electronic structure of solids \u2014 especially in crystals and layered materials. In this model, electrons are considered localized around atomic sites but can hop to neighbouring atoms. To describe such a Hamiltonian for a Moir\u00e9 system , we use the second quantized 2 form: \\[ H = \\sum_{\\alpha, \\beta;\\, r,r' \\in L} t^1_{rr', \\alpha\\beta}c^{\\dagger}_{r,\\beta}c_{r',\\alpha} + \\sum_{\\alpha, \\beta;\\, r,r' \\in U} t^2_{rr', \\alpha\\beta}d^{\\dagger}_{r,\\beta}d_{r',\\alpha} + \\sum_{\\alpha, \\beta;\\, r,r'} t^{\\perp}_{rr', \\alpha\\beta}c^{\\dagger}_{r,\\beta}d_{r',\\alpha} + \\text{h.c.} \\] Here, \\(c^{\\dagger}_{r,\\beta}\\) and \\(c_{r',\\alpha}\\) denote the electron creation and annihilation operators at lattice sites \\(r\\) and \\(r'\\) in the lower layer ( \\(L\\) ), associated with orbitals \\(\\beta\\) and \\(\\alpha\\) , respectively. Likewise, \\(d^{\\dagger}_{r,\\beta}\\) and \\(d_{r',\\alpha}\\) are the corresponding operators in the upper layer ( \\(U\\) ). The terms \\(t^1_{rr', \\alpha\\beta}\\) and \\(t^2_{rr', \\alpha\\beta}\\) represent the intralayer hopping amplitudes , describing electron tunneling from orbital \\(\\alpha\\) at site \\(r'\\) to orbital \\(\\beta\\) at site \\(r\\) within the lower and upper layers, respectively. In the special case where \\(r = r'\\) and \\(\\alpha = \\beta\\) , these terms correspond to the on-site potential \u2014the energy of an electron residing in a particular orbital. The interlayer coupling is described by \\(t^{\\perp}_{rr', \\alpha\\beta}\\) , which governs the hopping of an electron from orbital \\(\\alpha\\) at site \\(r'\\) in the upper layer to orbital \\(\\beta\\) at site \\(r\\) in the lower layer. For simplicity, consider only nearest-neighbour hopping with a single orbital per site ( MoirePy can handle any arbitrary number of orbital systems). In such cases, the orbital indices \\( \\alpha \\) and \\( \\beta \\) can be omitted to simplify the notation. We can define the basis as: \\[ \\Psi^{\\dagger} = (c^{\\dagger}_{1}, c^{\\dagger}_{2}, \\dots, c^{\\dagger}_{n}, d^{\\dagger}_{1}, d^{\\dagger}_{2}, \\dots, d^{\\dagger}_{n}) \\] Here, \\( c^{\\dagger}_{i} \\) ( \\( d^{\\dagger}_{i} \\) ) is the creation operator at site \\( i \\) in the lower (upper) layer. Then, the Hamiltonian takes the block matrix form: \\[ H = \\Psi^{\\dagger} \\begin{pmatrix} h_{LL} & h_{LU} \\\\ h_{UL} & h_{UU} \\end{pmatrix} \\Psi \\] Here, \\( h_{LL} \\) and \\( h_{UU} \\) are the first-quantized \\( n \\times n \\) Hamiltonians of the lower and upper layers, respectively. The blocks \\( h_{LU} \\) and \\( h_{UL} \\) represent interlayer couplings. Neil W. Ashcroft and N. David Mermin. Solid State Physics . Saunders College Publishing, 1976. \u21a9 Henrik Bruus and Karsten Flensberg. Many-Body Quantum Theory in Condensed Matter Physics: An Introduction . Oxford University Press, Oxford, 2004. \u21a9","title":"Tight Binding Moir\u00e9 Hamiltonian"},{"location":"theory/tight_binding_ham/#tight-binding-moire-hamiltonian-construction","text":"The tight-binding Hamiltonian 1 is a widely used model in solid-state physics and quantum chemistry to describe the electronic structure of solids \u2014 especially in crystals and layered materials. In this model, electrons are considered localized around atomic sites but can hop to neighbouring atoms. To describe such a Hamiltonian for a Moir\u00e9 system , we use the second quantized 2 form: \\[ H = \\sum_{\\alpha, \\beta;\\, r,r' \\in L} t^1_{rr', \\alpha\\beta}c^{\\dagger}_{r,\\beta}c_{r',\\alpha} + \\sum_{\\alpha, \\beta;\\, r,r' \\in U} t^2_{rr', \\alpha\\beta}d^{\\dagger}_{r,\\beta}d_{r',\\alpha} + \\sum_{\\alpha, \\beta;\\, r,r'} t^{\\perp}_{rr', \\alpha\\beta}c^{\\dagger}_{r,\\beta}d_{r',\\alpha} + \\text{h.c.} \\] Here, \\(c^{\\dagger}_{r,\\beta}\\) and \\(c_{r',\\alpha}\\) denote the electron creation and annihilation operators at lattice sites \\(r\\) and \\(r'\\) in the lower layer ( \\(L\\) ), associated with orbitals \\(\\beta\\) and \\(\\alpha\\) , respectively. Likewise, \\(d^{\\dagger}_{r,\\beta}\\) and \\(d_{r',\\alpha}\\) are the corresponding operators in the upper layer ( \\(U\\) ). The terms \\(t^1_{rr', \\alpha\\beta}\\) and \\(t^2_{rr', \\alpha\\beta}\\) represent the intralayer hopping amplitudes , describing electron tunneling from orbital \\(\\alpha\\) at site \\(r'\\) to orbital \\(\\beta\\) at site \\(r\\) within the lower and upper layers, respectively. In the special case where \\(r = r'\\) and \\(\\alpha = \\beta\\) , these terms correspond to the on-site potential \u2014the energy of an electron residing in a particular orbital. The interlayer coupling is described by \\(t^{\\perp}_{rr', \\alpha\\beta}\\) , which governs the hopping of an electron from orbital \\(\\alpha\\) at site \\(r'\\) in the upper layer to orbital \\(\\beta\\) at site \\(r\\) in the lower layer. For simplicity, consider only nearest-neighbour hopping with a single orbital per site ( MoirePy can handle any arbitrary number of orbital systems). In such cases, the orbital indices \\( \\alpha \\) and \\( \\beta \\) can be omitted to simplify the notation. We can define the basis as: \\[ \\Psi^{\\dagger} = (c^{\\dagger}_{1}, c^{\\dagger}_{2}, \\dots, c^{\\dagger}_{n}, d^{\\dagger}_{1}, d^{\\dagger}_{2}, \\dots, d^{\\dagger}_{n}) \\] Here, \\( c^{\\dagger}_{i} \\) ( \\( d^{\\dagger}_{i} \\) ) is the creation operator at site \\( i \\) in the lower (upper) layer. Then, the Hamiltonian takes the block matrix form: \\[ H = \\Psi^{\\dagger} \\begin{pmatrix} h_{LL} & h_{LU} \\\\ h_{UL} & h_{UU} \\end{pmatrix} \\Psi \\] Here, \\( h_{LL} \\) and \\( h_{UU} \\) are the first-quantized \\( n \\times n \\) Hamiltonians of the lower and upper layers, respectively. The blocks \\( h_{LU} \\) and \\( h_{UL} \\) represent interlayer couplings. Neil W. Ashcroft and N. David Mermin. Solid State Physics . Saunders College Publishing, 1976. \u21a9 Henrik Bruus and Karsten Flensberg. Many-Body Quantum Theory in Condensed Matter Physics: An Introduction . Oxford University Press, Oxford, 2004. \u21a9","title":"Tight Binding Moir\u00e9 Hamiltonian Construction"}]}