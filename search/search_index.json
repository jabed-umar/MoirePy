{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MoirePy: Twist It, Solve It, Own It! MoirePy is a FOSS Python library for simulating moire lattices with a clean, highly Pythonic API. It is designed to be easy to use while remaining fully flexible. You can define custom lattice geometries, program arbitrary hopping functions, and build tight-binding Hamiltonians in both real space and k-space , with support for open (OBC) and periodic (PBC) boundary conditions. Generated Hamiltonians can also be exported to tools like Kwant for further analysis. Documentation: https://jabed-umar.github.io/MoirePy/ Github Repository: https://github.com/jabed-umar/MoirePy PyPI page: https://pypi.org/project/moirepy/ Why MoirePy Define anything : No restrictions on lattice geometry or orbitals Pythonic API : If you know Python, MoirePy is intuitive Custom hoppings : Fully programmable intra/inter-layer couplings Real-space + k-space : Both supported natively OBC + PBC : Switch boundary conditions easily Kwant-compatible : Export Hamiltonians for further analysis Fast construction : Efficient neighbour search using KDTree Reproducibility-first : Designed to replicate known results and papers Installation pip install moirepy Quick Example: Twisted Bilayer Graphene import numpy as np import matplotlib.pyplot as plt from moirepy import BilayerMoireLattice , HexagonalLayer # Define a twisted bilayer moir\u00e9 lattice lattice = BilayerMoireLattice ( latticetype = HexagonalLayer , # you choose the next 4 values based on the twist angle using this tool: # Angle-Value Calculator: https://jabed-umar.github.io/MoirePy/theory/avc/ ll1 = 3 , ll2 = 4 , ul1 = 4 , ul2 = 3 , n1 = 1 , n2 = 1 , ) # Visualize the lattice lattice . plot_lattice () plt . show () ham = lattice . generate_hamiltonian ( tll = 1 , tuu = 1 , tlu = 1 , tul = 1 , tlself = 0 , tuself = 0 ) # returns scipy sparse matrix print ( ham . shape ) Philosophy MoirePy does not try to enforce what is \"physically valid\". If you want: unusual lattices non-standard couplings high orbital counts you are free to do so. The library gives you control. You decide what makes sense. Contributing Contributions are welcome. Report bugs or request features via issues Submit pull requests for improvements Add examples, tutorials, or benchmarks A detailed contributing guide will be added soon. Citation If you use this work in research: @misc { MoirePy2025 , author = {Aritra Mukhopadhyay and Jabed Umar} , title = {MoirePy: Python package for efficient atomistic simulation of moir\u00e9 lattices} , year = {2025} , url = {https://jabed-umar.github.io/MoirePy/} }","title":"Home"},{"location":"#moirepy-twist-it-solve-it-own-it","text":"MoirePy is a FOSS Python library for simulating moire lattices with a clean, highly Pythonic API. It is designed to be easy to use while remaining fully flexible. You can define custom lattice geometries, program arbitrary hopping functions, and build tight-binding Hamiltonians in both real space and k-space , with support for open (OBC) and periodic (PBC) boundary conditions. Generated Hamiltonians can also be exported to tools like Kwant for further analysis. Documentation: https://jabed-umar.github.io/MoirePy/ Github Repository: https://github.com/jabed-umar/MoirePy PyPI page: https://pypi.org/project/moirepy/","title":"MoirePy: Twist It, Solve It, Own It!"},{"location":"#why-moirepy","text":"Define anything : No restrictions on lattice geometry or orbitals Pythonic API : If you know Python, MoirePy is intuitive Custom hoppings : Fully programmable intra/inter-layer couplings Real-space + k-space : Both supported natively OBC + PBC : Switch boundary conditions easily Kwant-compatible : Export Hamiltonians for further analysis Fast construction : Efficient neighbour search using KDTree Reproducibility-first : Designed to replicate known results and papers","title":"Why MoirePy"},{"location":"#installation","text":"pip install moirepy","title":"Installation"},{"location":"#quick-example-twisted-bilayer-graphene","text":"import numpy as np import matplotlib.pyplot as plt from moirepy import BilayerMoireLattice , HexagonalLayer # Define a twisted bilayer moir\u00e9 lattice lattice = BilayerMoireLattice ( latticetype = HexagonalLayer , # you choose the next 4 values based on the twist angle using this tool: # Angle-Value Calculator: https://jabed-umar.github.io/MoirePy/theory/avc/ ll1 = 3 , ll2 = 4 , ul1 = 4 , ul2 = 3 , n1 = 1 , n2 = 1 , ) # Visualize the lattice lattice . plot_lattice () plt . show () ham = lattice . generate_hamiltonian ( tll = 1 , tuu = 1 , tlu = 1 , tul = 1 , tlself = 0 , tuself = 0 ) # returns scipy sparse matrix print ( ham . shape )","title":"Quick Example: Twisted Bilayer Graphene"},{"location":"#philosophy","text":"MoirePy does not try to enforce what is \"physically valid\". If you want: unusual lattices non-standard couplings high orbital counts you are free to do so. The library gives you control. You decide what makes sense.","title":"Philosophy"},{"location":"#contributing","text":"Contributions are welcome. Report bugs or request features via issues Submit pull requests for improvements Add examples, tutorials, or benchmarks A detailed contributing guide will be added soon.","title":"Contributing"},{"location":"#citation","text":"If you use this work in research: @misc { MoirePy2025 , author = {Aritra Mukhopadhyay and Jabed Umar} , title = {MoirePy: Python package for efficient atomistic simulation of moir\u00e9 lattices} , year = {2025} , url = {https://jabed-umar.github.io/MoirePy/} }","title":"Citation"},{"location":"examples/","text":"table td, table th { max-width: 500px !important; overflow-wrap: break-word !important; word-wrap: break-word !important; white-space: normal !important; } Learning Moire Physics Through Examples Here are a couple of examples to help you get started with Moire physics: Topic Links K-Space Hamiltonian: An example of a Hamiltonian in k-space. examples/k_space_ham.ipynb Tight Binding Hamiltonian: An example of a tight binding Hamiltonian. examples/tight_binding_ham.ipynb Density of States Calculation: An example of a density of states calculation. examples/dos_calculation.ipynb document.addEventListener('DOMContentLoaded', () => { document.querySelectorAll('table').forEach(table => { table.querySelectorAll('thead tr th')[0].style.textAlign = 'center'; table.querySelectorAll('tbody tr').forEach(row => { const cell = row.cells[1]; const path = cell.textContent.trim(); cell.innerHTML = `<a target=\"_blank\" href=\"https://github.com/jabed-umar/MoirePy/blob/main/${path}\">Github</a>` + ' | ' + `<a target=\"_blank\" href=\"https://colab.research.google.com/github/jabed-umar/MoirePy/blob/main/${path}\">Colab</a>`; }); }); });","title":"Tutorials and Replicated Papers"},{"location":"examples/#learning-moire-physics-through-examples","text":"Here are a couple of examples to help you get started with Moire physics: Topic Links K-Space Hamiltonian: An example of a Hamiltonian in k-space. examples/k_space_ham.ipynb Tight Binding Hamiltonian: An example of a tight binding Hamiltonian. examples/tight_binding_ham.ipynb Density of States Calculation: An example of a density of states calculation. examples/dos_calculation.ipynb document.addEventListener('DOMContentLoaded', () => { document.querySelectorAll('table').forEach(table => { table.querySelectorAll('thead tr th')[0].style.textAlign = 'center'; table.querySelectorAll('tbody tr').forEach(row => { const cell = row.cells[1]; const path = cell.textContent.trim(); cell.innerHTML = `<a target=\"_blank\" href=\"https://github.com/jabed-umar/MoirePy/blob/main/${path}\">Github</a>` + ' | ' + `<a target=\"_blank\" href=\"https://colab.research.google.com/github/jabed-umar/MoirePy/blob/main/${path}\">Colab</a>`; }); }); });","title":"Learning Moire Physics Through Examples"},{"location":"api/layers/","text":"Layer Source code in moirepy/layers.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 class Layer : # parent class def __init__ ( self , pbc : bool = False , study_proximity : int = 1 ) -> None : \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity (int): Scaling factor for proximity calculations, **enabling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. \"\"\" required_attrs = [ \"lv1\" , \"lv2\" , \"lattice_points\" , \"neighbours\" ] for attr in required_attrs : if not hasattr ( self , attr ): raise NotImplementedError ( f \"Subclass { self . __class__ . __name__ } must define ' { attr } '\" ) self . toll_scale = max ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ) ) if self . lv1 [ 1 ] != 0 or self . lv2 [ 1 ] < 0 : raise ValueError ( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://jabed-umar.github.io/MoirePy/find_theta/ \"\"\" ) self . rot_m = np . eye ( 2 ) # will be replaced if called perform_rotation self . pbc = pbc self . points = None self . kdtree = None self . study_proximity = study_proximity self . lattice_angle = np . arccos ( np . dot ( self . lv1 , self . lv2 ) / ( np . linalg . norm ( self . lv1 ) * np . linalg . norm ( self . lv2 ))) def perform_rotation_translation ( self , rot : float , translation : Tuple [ float , float ] = ( 0 , 0 )) -> None : \"\"\" Rotates and translates the lattice layer and its components. Has to be applied before point generation. Args: rot (float): The rotation angle in radians. Default to `None`. translation (Tuple[float, float]): The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation_translation(np.pi/4, (1, 1)) ``` \"\"\" assert self . points is None , \"Cannot perform rotation and translation after points have been generated.\" rot_m = get_rotation_matrix ( rot ) self . rot_m = rot_m # Rotate lv1 and lv2 vectors self . lv1 = rot_m @ self . lv1 self . lv2 = rot_m @ self . lv2 # Rotate lattice_points self . lattice_points = [ [ * ( rot_m @ ( np . array ([ x , y ]) + np . array ( translation ))), point_type ] for x , y , point_type in self . lattice_points ] # Rotate neighbours self . neighbours = { point_type : [ rot_m @ np . array ( neighbour ) for neighbour in neighbour_list ] for point_type , neighbour_list in self . neighbours . items () } def generate_points ( self , mlv1 : np . ndarray , mlv2 : np . ndarray , mln1 : int = 1 , mln2 : int = 1 , test : bool = False , ) -> None : \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.ndarray): The first Moir\u00e9 lattice vector. mlv2 (np.ndarray): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test (bool, optional): If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None: The function modifies the object state and stores the generated points and their types. Raises: AssersionError: If mln1 and mln2 are not positive integers. AssersionError: if test is True and mln1 or mln2 is not 1 Example: ```python >>> lattice = MyLattice() # a class inheriting the Layer class >>> lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1) >>> print(lattice.points) ``` \"\"\" # raise the promised errors: assert isinstance ( mln1 , int ) and mln1 > 0 , \"mln1 must be a positive integer.\" assert isinstance ( mln2 , int ) and mln2 > 0 , \"mln2 must be a positive integer.\" if test : assert mln1 == 1 and mln2 == 1 , \"If test is True, both mln1 and mln2 must be 1.\" self . mlv1 = mlv1 # Moire lattice vector 1 self . mlv2 = mlv2 # Moire lattice vector 2 self . mln1 = mln1 # Number of moire unit cells along mlv1 self . mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the number of points along each direction points = [ np . array ([ 0 , 0 ]), mlv1 , mlv2 , mlv1 + mlv2 ] max_distance = max ( np . linalg . norm ( points [ 0 ] - points [ 1 ]), np . linalg . norm ( points [ 0 ] - points [ 2 ]), np . linalg . norm ( points [ 0 ] - points [ 3 ]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math . ceil ( max_distance / min ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range ( - n , n + 1 ): # Iterate along mlv1 for j in range ( - n , n + 1 ): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self . lv1 + j * self . lv2 for xpos , ypos , name in self . lattice_points : point = point_o + np . array ([ xpos , ypos ]) step1_points . append ( point ) step1_names . append ( name ) step1_points = np . array ( step1_points ) step1_names = np . array ( step1_names ) # Apply the boundary check method (inside_boundaries) to filter the points mask = self . _inside_boundaries ( step1_points , 1 , 1 ) # generating points only inside the first cell now step1_points = step1_points [ mask ] step1_names = step1_names [ mask ] # Step 3: Copy and translate the unit cell to create the full lattice points = [] # List to hold all the moire points names = [] for i in range ( self . mln1 ): # Translate along mlv1 direction for j in range ( self . mln2 ): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points . append ( translated_points ) names . append ( step1_names ) self . points = np . vstack ( points ) self . point_types = np . hstack ( names ) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") if not test : self . generate_kdtree () def _point_positions ( self , points : np . ndarray , A : np . ndarray , B : np . ndarray ) -> np . ndarray : \"\"\" Determines the position of each point relative to a parallelogram defined by vectors A and B. Args: points (np.ndarray): Array of points to be analyzed. A (np.ndarray): The first vector of the parallelogram. B (np.ndarray): The second vector of the parallelogram. Returns: np.ndarray: An array indicating the position of each point: - (0, 0) for points inside the parallelogram. - (-1, 1) or (1, -1) for points outside on specific sides. left side and right side will give -1 and 1 respectively top side and bottom side will give -1 and 1 respectively \"\"\" # Compute determinants for positions relative to OA and BC det_OA = ( points [:, 0 ] * A [ 1 ] - points [:, 1 ] * A [ 0 ]) <= self . toll_scale * 1e-2 det_BC = (( points [:, 0 ] - B [ 0 ]) * A [ 1 ] - ( points [:, 1 ] - B [ 1 ]) * A [ 0 ]) <= self . toll_scale * 1e-2 position_y = det_OA . astype ( float ) + det_BC . astype ( float ) # Compute determinants for positions relative to OB and AC det_OB = ( points [:, 0 ] * B [ 1 ] - points [:, 1 ] * B [ 0 ]) > - self . toll_scale * 1e-2 det_AC = (( points [:, 0 ] - A [ 0 ]) * B [ 1 ] - ( points [:, 1 ] - A [ 1 ]) * B [ 0 ]) > - self . toll_scale * 1e-2 position_x = det_OB . astype ( float ) + det_AC . astype ( float ) return np . column_stack (( position_x , position_y )) - 1 def _inside_polygon ( self , points : np . ndarray , polygon : np . ndarray ) -> np . ndarray : \"\"\" Determines if each point is inside a polygon using the ray-casting method. Args: points (np.ndarray): Array of points to check. polygon (np.ndarray): Vertices of the polygon to test against, in counterclockwise order. Returns: np.ndarray: A boolean array where True indicates that the point is inside the polygon. Example: ```python points = np.array([[0.5, 0.5], [1, 1], [-1, -1]]) polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]) inside = _inside_polygon(points, polygon) print(inside) ``` \"\"\" x , y = points [:, 0 ], points [:, 1 ] px , py = polygon [:, 0 ], polygon [:, 1 ] px_next , py_next = np . roll ( px , - 1 ), np . roll ( py , - 1 ) edge_cond = ( y [:, None ] > np . minimum ( py , py_next )) & ( y [:, None ] <= np . maximum ( py , py_next )) with np . errstate ( divide = 'ignore' , invalid = 'ignore' ): xinters = np . where ( py != py_next , ( y [:, None ] - py ) * ( px_next - px ) / ( py_next - py ) + px , np . inf ) ray_crosses = edge_cond & ( x [:, None ] <= xinters ) inside = np . sum ( ray_crosses , axis = 1 ) % 2 == 1 return inside # mask def _inside_boundaries ( self , points : np . ndarray , mln1 = None , mln2 = None ) -> np . ndarray : \"\"\" Determines if the given points lie within the boundaries of the Moir\u00e9 lattice pattern. Args: points (np.ndarray): Array of points to check. mln1 (int, optional): The number of unit cells along the first direction. Defaults to the object's current value. mln2 (int, optional): The number of unit cells along the second direction. Defaults to the object's current value. Returns: np.ndarray: A boolean array where True indicates that the point is within the boundaries of the lattice. Raises: ValueError: If the points array has an invalid shape. Example: ```python points = np.array([[0.5, 0.5], [2, 2], [-1, -1]]) lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3) print(lattice_boundaries) ``` \"\"\" v1 = ( mln1 if mln1 else self . mln1 ) * self . mlv1 v2 = ( mln2 if mln2 else self . mln2 ) * self . mlv2 p1 = np . array ([ 0 , 0 ]) p2 = np . array ([ v1 [ 0 ], v1 [ 1 ]]) p3 = np . array ([ v2 [ 0 ], v2 [ 1 ]]) p4 = np . array ([ v1 [ 0 ] + v2 [ 0 ], v1 [ 1 ] + v2 [ 1 ]]) shift_dir = - ( v1 + v2 ) shift_dir = shift_dir / np . linalg . norm ( shift_dir ) # normalize shift = shift_dir * self . toll_scale * 1e-4 return self . _inside_polygon ( points , np . array ([ p1 , p2 , p4 , p3 ]) + shift ) def generate_kdtree ( self ) -> None : \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. \"\"\" if not self . pbc : # OBC is easy self . kdtree = KDTree ( self . points ) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range ( - 1 , 2 ): for j in range ( - 1 , 2 ): all_points . append ( self . points + i * self . mln1 * self . mlv1 + j * self . mln2 * self . mlv2 ) all_point_names . append ( self . point_types ) all_points = np . vstack ( all_points ) all_point_names = np . hstack ( all_point_names ) v1 = self . mln1 * self . mlv1 v2 = self . mln2 * self . mlv2 neigh_pad_1 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv1 ) / np . linalg . norm ( v1 ) neigh_pad_2 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv2 ) / np . linalg . norm ( v2 ) mask = self . _inside_polygon ( all_points , np . array ([ ( - neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ( - neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ])) # print(mask.shape, mask.dtype) points = all_points [ mask ] point_names = all_point_names [ mask ] self . bigger_points = points self . bigger_point_types = point_names self . kdtree = KDTree ( points ) self . _generate_mapping () # # plot the points but with colours based on the point_positions # # - point_positions = [0, 0] -> black # # - point_positions = [1, 0] -> red # # - do not plot the rest of the points at all # plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], 'k.') # plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], 'r.') # plt.plot(*all_points.T, \"ro\") # plt.plot(*points.T, \"b.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.grid() # plt.show() def _generate_mapping ( self ) -> None : \"\"\" Generates a mapping between two sets of points (larger and smaller lattices) based on their positions and computes the distances between corresponding points. If the distance between a point in the larger lattice and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots the lattice points for visualization. This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice. It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points` and values are the corresponding indices in `self.points`. Raises: ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`. Example: ```python my_lattice._generate_mapping() ``` The function performs the following steps: 1. Initializes an empty dictionary `self.mappings`. 2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`). 3. Computes the translation needed for each point based on a lattice scaling factor. 4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points. 5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`. 6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization. Note: - The function assumes `self.points` and `self.bigger_points` are defined as numpy arrays with the coordinates of the points in the lattices. - The translations used in the function are calculated based on `mln1`, `mln2`, `mlv1`, and `mlv2`, which define the lattice scaling and vectors. \"\"\" self . mappings = {} tree = KDTree ( self . points ) # smaller set translations = self . _point_positions ( self . bigger_points , self . mln1 * self . mlv1 , self . mln2 * self . mlv2 ) for i , ( dx , dy ) in enumerate ( translations ): mapped_point = self . bigger_points [ i ] - ( dx * self . mlv1 * self . mln1 + dy * self . mlv2 * self . mln2 ) distance , index = tree . query ( mapped_point ) if distance >= self . toll_scale * 1e-3 : # print(f\"Distance {distance} exceeds tolerance for {i}th point {self.bigger_points[i]} mapped at location {mapped_point} with translation ({dx}, {dy}).\") # plt.plot(*self.bigger_points.T, \"ko\", alpha=0.3) # plt.plot(*self.points.T, \"k.\") # # plt.plot(*self.bigger_points[i], \"b.\") # # plt.plot(*mapped_point, \"r.\") # # plt.plot(*self.points[index], \"g.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1 * self.mlv1[0]], [0, self.mln1 * self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2 * self.mlv2[0]], [0, self.mln2 * self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1 * self.mlv1[0], self.mln1 * self.mlv1[0] + self.mln2 * self.mlv2[0]], [self.mln1 * self.mlv1[1], self.mln1 * self.mlv1[1] + self.mln2 * self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2 * self.mlv2[0], self.mln1 * self.mlv1[0] + self.mln2 * self.mlv2[0]], [self.mln2 * self.mlv2[1], self.mln1 * self.mlv1[1] + self.mln2 * self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self. mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # # for index, mapped_point in enumerate(self.bigger_points): # # plt.text(*mapped_point, f\"{index}\", fontsize=6) # plt.gca().add_patch(plt.Circle(mapped_point, distance / 2, color='r', fill=False)) # plt.grid() # plt.show() raise ValueError ( f \"FATAL ERROR: Distance { distance } exceeds tolerance for { i } th point { self . bigger_points [ i ] } mapped at location { mapped_point } with translation ( { dx } , { dy } ).\" ) self . mappings [ i ] = index # point positions... for each point in self.point, point position is a array of length 2 (x, y) # where the elemnts are -1, 0 and 1... this is what their value mean about their position # (-1, 1) | (0, 1) | (1, 1) # ----------------------------- # (-1, 0) | (0, 0) | (1, 0) # ----------------------------- # (-1,-1) | (0,-1) | (1,-1) # ----------------------------- # (0, 0) is our actual lattice part... # do this for all points in self.bigger_points: # all point with point_positions = (x, y) need to be translated by # (-x*self.mlv1*self.mln1 - y*self.mlv2*self.mln2) to get the corresponding point inside the lattice # then you would need to run a query on a newly kdtree of the smaller points... # to the get the index of the corresponding point inside the lattice (distance should be zero, just saying) # now we already know the index of the point in the self.bigger_points... so we can map that to the index of the point in the self.points # then we will store that in `self.mappings`` # self.mapppings will be a dictionary with keys as the indices in the # self.bigger_points (unique) and values as the indices in the self.points (not unique) # def kth_nearest_neighbours(self, points, types, k = 1) -> None: # distance_matrix = self.kdtree.sparse_distance_matrix(self.kdtree, k) def first_nearest_neighbours ( self , points : np . ndarray , types : np . ndarray ): assert self . kdtree is not None unique_types = np . unique ( types ) max_neighs = max ( len ( self . neighbours [ t ]) for t in unique_types ) n_points = points . shape [ 0 ] bigger_indices_arr = np . full (( n_points , max_neighs ), - 1 , dtype = int ) smaller_indices_arr = np . full (( n_points , max_neighs ), - 1 , dtype = int ) smaller_distances_arr = np . full (( n_points , max_neighs ), np . nan , dtype = float ) # Pre-compute mapping array for vectorized indexing if self . pbc : map_arr = np . array ([ self . mappings [ i ] for i in range ( len ( self . bigger_points ))]) for t in unique_types : # 1. Mask to find all points of this specific type mask = ( types == t ) type_points = points [ mask ] # Shape (N_t, 2) rel_neighs = np . array ( self . neighbours [ t ]) # Shape (M_t, 2) n_curr = len ( rel_neighs ) # 2. Vectorized meshgrid to get all absolute neighbor coordinates # absolute_coords shape: (N_t, M_t, 2) absolute_coords = type_points [:, np . newaxis , :] + rel_neighs [ np . newaxis , :, :] # 3. Bulk Query (KDTree supports multidimensional input) # distances/indices shape: (N_t, M_t) distances , indices = self . kdtree . query ( absolute_coords , k = 1 ) # 4. Bulk Assignment if self . pbc : if np . any ( distances > 1e-2 * self . toll_scale ): raise ValueError ( f \"Distance exceeds tolerance for type { t } \" ) bigger_indices_arr [ mask , : n_curr ] = indices smaller_indices_arr [ mask , : n_curr ] = map_arr [ indices ] else : bigger_indices_arr [ mask , : n_curr ] = indices smaller_indices_arr [ mask , : n_curr ] = indices smaller_distances_arr [ mask , : n_curr ] = distances return bigger_indices_arr , smaller_indices_arr , smaller_distances_arr def get_neighbors_within_radius ( self , query_points : np . ndarray , radius : float ): assert self . kdtree is not None # 1. Scipy's fast radius search # Returns a list of lists: [[neighs_for_p0], [neighs_for_p1], ...] indices_list = self . kdtree . query_ball_point ( query_points , r = radius ) # 2. Vectorized Flattening # Calculate counts per query point to repeat indices correctly counts = np . array ([ len ( nb ) for nb in indices_list ]) if counts . sum () == 0 : return np . array ([], dtype = int ), np . array ([], dtype = int ), np . array ([]) . reshape ( 0 , 2 ) # query_indices: [0, 0, 0, 1, 1, ...] query_indices = np . repeat ( np . arange ( len ( query_points )), counts ) # tree_indices: flattened neighbor indices from the KDTree tree_indices = np . concatenate ([ nb for nb in indices_list if len ( nb ) > 0 ]) # 3. Retrieve Coordinates if self . pbc : neighbor_coords = self . bigger_points [ tree_indices ] # REPLACEMENT FOR LAMBDA MAPPER: Direct Array Lookup # We pre-mapped these during generate_kdtree map_arr = np . array ([ self . mappings [ i ] for i in range ( len ( self . bigger_points ))]) lattice_indices = map_arr [ tree_indices ] else : neighbor_coords = self . points [ tree_indices ] lattice_indices = tree_indices return query_indices , lattice_indices , neighbor_coords def plot_lattice ( self , plot_connections : bool = True , colours : list = [ \"r\" , \"g\" , \"b\" , \"c\" , \"m\" , \"y\" , \"k\" ]) -> None : \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. colours (list, optional): List of matplotlib colours to use for different point types. Behavior: - Plots all lattice points grouped by type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. Example: ```python lattice = MyLattice() lattice.generate_points() lattice.plot_lattice(plot_connections=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. \"\"\" if len ( colours ) == 1 : cols = { t [ - 1 ]: colours [ 0 ] for i , t , in enumerate ( self . lattice_points )} else : cols = { t [ - 1 ]: colours [ i ] for i , t , in enumerate ( self . lattice_points )} # plt.scatter( # [self.points[:, 0]], # [self.points[:, 1]], # s=10, c=np.vectorize(cols.get)(self.point_types) # ) if plot_connections : a = [] for this , point_type in zip ( self . points , self . point_types ): for delta in self . neighbours [ point_type ]: a . append ([ this [ 0 ], this [ 0 ] + delta [ 0 ]]) a . append (( this [ 1 ], this [ 1 ] + delta [ 1 ])) a . append ( \"k--\" ) # a = a[:30] # print(a) plt . plot ( * a , alpha = 0.1 ) # plt.title(\"Lattice Points\") # plt.xlabel(\"X Coordinate\") # plt.ylabel(\"Y Coordinate\") plt . axis ( \"equal\" ) def __repr__ ( self ): return ( f \"\"\"Layer( lv1 = { self . lv1 } , lv2 = { self . lv2 } , lattice_points = { self . lattice_points } , study_proximity = { self . study_proximity } , pbc = { self . pbc } , )\"\"\" ) __init__ ( pbc = False , study_proximity = 1 ) Initializes the Layer object Parameters: pbc ( bool , default: False ) \u2013 Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity ( int , default: 1 ) \u2013 Scaling factor for proximity calculations, enabling the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError \u2013 If lv1 is not along the x-axis or if lv2 has a negative y-component. Source code in moirepy/layers.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def __init__ ( self , pbc : bool = False , study_proximity : int = 1 ) -> None : \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity (int): Scaling factor for proximity calculations, **enabling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. \"\"\" required_attrs = [ \"lv1\" , \"lv2\" , \"lattice_points\" , \"neighbours\" ] for attr in required_attrs : if not hasattr ( self , attr ): raise NotImplementedError ( f \"Subclass { self . __class__ . __name__ } must define ' { attr } '\" ) self . toll_scale = max ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ) ) if self . lv1 [ 1 ] != 0 or self . lv2 [ 1 ] < 0 : raise ValueError ( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://jabed-umar.github.io/MoirePy/find_theta/ \"\"\" ) self . rot_m = np . eye ( 2 ) # will be replaced if called perform_rotation self . pbc = pbc self . points = None self . kdtree = None self . study_proximity = study_proximity self . lattice_angle = np . arccos ( np . dot ( self . lv1 , self . lv2 ) / ( np . linalg . norm ( self . lv1 ) * np . linalg . norm ( self . lv2 ))) generate_kdtree () Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None ( None ) \u2013 The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError \u2013 If the points in the lattice are not defined. Source code in moirepy/layers.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def generate_kdtree ( self ) -> None : \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. \"\"\" if not self . pbc : # OBC is easy self . kdtree = KDTree ( self . points ) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range ( - 1 , 2 ): for j in range ( - 1 , 2 ): all_points . append ( self . points + i * self . mln1 * self . mlv1 + j * self . mln2 * self . mlv2 ) all_point_names . append ( self . point_types ) all_points = np . vstack ( all_points ) all_point_names = np . hstack ( all_point_names ) v1 = self . mln1 * self . mlv1 v2 = self . mln2 * self . mlv2 neigh_pad_1 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv1 ) / np . linalg . norm ( v1 ) neigh_pad_2 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv2 ) / np . linalg . norm ( v2 ) mask = self . _inside_polygon ( all_points , np . array ([ ( - neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ( - neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ])) # print(mask.shape, mask.dtype) points = all_points [ mask ] point_names = all_point_names [ mask ] self . bigger_points = points self . bigger_point_types = point_names self . kdtree = KDTree ( points ) self . _generate_mapping () generate_points ( mlv1 , mlv2 , mln1 = 1 , mln2 = 1 , test = False ) Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Parameters: mlv1 ( ndarray ) \u2013 The first Moir\u00e9 lattice vector. mlv2 ( ndarray ) \u2013 The second Moir\u00e9 lattice vector. mln1 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test ( bool , default: False ) \u2013 If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None ( None ) \u2013 The function modifies the object state and None \u2013 stores the generated points and their types. Raises: AssersionError \u2013 If mln1 and mln2 are not positive integers. AssersionError \u2013 if test is True and mln1 or mln2 is not 1 Example: >>> lattice = MyLattice () # a class inheriting the Layer class >>> lattice . generate_points ( np . array ([ 1 , 0 ]), np . array ([ 0.5 , np . sqrt ( 3 ) / 2 ]), mln1 = 1 , mln2 = 1 ) >>> print ( lattice . points ) Source code in moirepy/layers.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def generate_points ( self , mlv1 : np . ndarray , mlv2 : np . ndarray , mln1 : int = 1 , mln2 : int = 1 , test : bool = False , ) -> None : \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.ndarray): The first Moir\u00e9 lattice vector. mlv2 (np.ndarray): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test (bool, optional): If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None: The function modifies the object state and stores the generated points and their types. Raises: AssersionError: If mln1 and mln2 are not positive integers. AssersionError: if test is True and mln1 or mln2 is not 1 Example: ```python >>> lattice = MyLattice() # a class inheriting the Layer class >>> lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1) >>> print(lattice.points) ``` \"\"\" # raise the promised errors: assert isinstance ( mln1 , int ) and mln1 > 0 , \"mln1 must be a positive integer.\" assert isinstance ( mln2 , int ) and mln2 > 0 , \"mln2 must be a positive integer.\" if test : assert mln1 == 1 and mln2 == 1 , \"If test is True, both mln1 and mln2 must be 1.\" self . mlv1 = mlv1 # Moire lattice vector 1 self . mlv2 = mlv2 # Moire lattice vector 2 self . mln1 = mln1 # Number of moire unit cells along mlv1 self . mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the number of points along each direction points = [ np . array ([ 0 , 0 ]), mlv1 , mlv2 , mlv1 + mlv2 ] max_distance = max ( np . linalg . norm ( points [ 0 ] - points [ 1 ]), np . linalg . norm ( points [ 0 ] - points [ 2 ]), np . linalg . norm ( points [ 0 ] - points [ 3 ]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math . ceil ( max_distance / min ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range ( - n , n + 1 ): # Iterate along mlv1 for j in range ( - n , n + 1 ): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self . lv1 + j * self . lv2 for xpos , ypos , name in self . lattice_points : point = point_o + np . array ([ xpos , ypos ]) step1_points . append ( point ) step1_names . append ( name ) step1_points = np . array ( step1_points ) step1_names = np . array ( step1_names ) # Apply the boundary check method (inside_boundaries) to filter the points mask = self . _inside_boundaries ( step1_points , 1 , 1 ) # generating points only inside the first cell now step1_points = step1_points [ mask ] step1_names = step1_names [ mask ] # Step 3: Copy and translate the unit cell to create the full lattice points = [] # List to hold all the moire points names = [] for i in range ( self . mln1 ): # Translate along mlv1 direction for j in range ( self . mln2 ): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points . append ( translated_points ) names . append ( step1_names ) self . points = np . vstack ( points ) self . point_types = np . hstack ( names ) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") if not test : self . generate_kdtree () perform_rotation_translation ( rot , translation = ( 0 , 0 )) Rotates and translates the lattice layer and its components. Has to be applied before point generation. Parameters: rot ( float ) \u2013 The rotation angle in radians. Default to None . translation ( Tuple [ float , float ] , default: (0, 0) ) \u2013 The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None ( None ) \u2013 The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: layer . perform_rotation_translation ( np . pi / 4 , ( 1 , 1 )) Source code in moirepy/layers.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def perform_rotation_translation ( self , rot : float , translation : Tuple [ float , float ] = ( 0 , 0 )) -> None : \"\"\" Rotates and translates the lattice layer and its components. Has to be applied before point generation. Args: rot (float): The rotation angle in radians. Default to `None`. translation (Tuple[float, float]): The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation_translation(np.pi/4, (1, 1)) ``` \"\"\" assert self . points is None , \"Cannot perform rotation and translation after points have been generated.\" rot_m = get_rotation_matrix ( rot ) self . rot_m = rot_m # Rotate lv1 and lv2 vectors self . lv1 = rot_m @ self . lv1 self . lv2 = rot_m @ self . lv2 # Rotate lattice_points self . lattice_points = [ [ * ( rot_m @ ( np . array ([ x , y ]) + np . array ( translation ))), point_type ] for x , y , point_type in self . lattice_points ] # Rotate neighbours self . neighbours = { point_type : [ rot_m @ np . array ( neighbour ) for neighbour in neighbour_list ] for point_type , neighbour_list in self . neighbours . items () } plot_lattice ( plot_connections = True , colours = [ 'r' , 'g' , 'b' , 'c' , 'm' , 'y' , 'k' ]) Plots the lattice points and optionally the connections between them and the unit cell structure. Parameters: plot_connections ( bool , default: True ) \u2013 If True, plots the connections between nearest neighbors. Defaults to True. colours ( list , default: ['r', 'g', 'b', 'c', 'm', 'y', 'k'] ) \u2013 List of matplotlib colours to use for different point types. Behavior Plots all lattice points grouped by type. If plot_connections is True, it draws dashed red lines between nearest neighbors. Example: lattice = MyLattice () lattice . generate_points () lattice . plot_lattice ( plot_connections = True ) Visualization Details Lattice points are plotted as small dots. Nearest neighbor connections (if enabled) are shown as dashed red lines. Source code in moirepy/layers.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 def plot_lattice ( self , plot_connections : bool = True , colours : list = [ \"r\" , \"g\" , \"b\" , \"c\" , \"m\" , \"y\" , \"k\" ]) -> None : \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. colours (list, optional): List of matplotlib colours to use for different point types. Behavior: - Plots all lattice points grouped by type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. Example: ```python lattice = MyLattice() lattice.generate_points() lattice.plot_lattice(plot_connections=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. \"\"\" if len ( colours ) == 1 : cols = { t [ - 1 ]: colours [ 0 ] for i , t , in enumerate ( self . lattice_points )} else : cols = { t [ - 1 ]: colours [ i ] for i , t , in enumerate ( self . lattice_points )} # plt.scatter( # [self.points[:, 0]], # [self.points[:, 1]], # s=10, c=np.vectorize(cols.get)(self.point_types) # ) if plot_connections : a = [] for this , point_type in zip ( self . points , self . point_types ): for delta in self . neighbours [ point_type ]: a . append ([ this [ 0 ], this [ 0 ] + delta [ 0 ]]) a . append (( this [ 1 ], this [ 1 ] + delta [ 1 ])) a . append ( \"k--\" ) # a = a[:30] # print(a) plt . plot ( * a , alpha = 0.1 ) # plt.title(\"Lattice Points\") # plt.xlabel(\"X Coordinate\") # plt.ylabel(\"Y Coordinate\") plt . axis ( \"equal\" )","title":"Layers"},{"location":"api/layers/#moirepy.layers.Layer","text":"Source code in moirepy/layers.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 class Layer : # parent class def __init__ ( self , pbc : bool = False , study_proximity : int = 1 ) -> None : \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity (int): Scaling factor for proximity calculations, **enabling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. \"\"\" required_attrs = [ \"lv1\" , \"lv2\" , \"lattice_points\" , \"neighbours\" ] for attr in required_attrs : if not hasattr ( self , attr ): raise NotImplementedError ( f \"Subclass { self . __class__ . __name__ } must define ' { attr } '\" ) self . toll_scale = max ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ) ) if self . lv1 [ 1 ] != 0 or self . lv2 [ 1 ] < 0 : raise ValueError ( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://jabed-umar.github.io/MoirePy/find_theta/ \"\"\" ) self . rot_m = np . eye ( 2 ) # will be replaced if called perform_rotation self . pbc = pbc self . points = None self . kdtree = None self . study_proximity = study_proximity self . lattice_angle = np . arccos ( np . dot ( self . lv1 , self . lv2 ) / ( np . linalg . norm ( self . lv1 ) * np . linalg . norm ( self . lv2 ))) def perform_rotation_translation ( self , rot : float , translation : Tuple [ float , float ] = ( 0 , 0 )) -> None : \"\"\" Rotates and translates the lattice layer and its components. Has to be applied before point generation. Args: rot (float): The rotation angle in radians. Default to `None`. translation (Tuple[float, float]): The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation_translation(np.pi/4, (1, 1)) ``` \"\"\" assert self . points is None , \"Cannot perform rotation and translation after points have been generated.\" rot_m = get_rotation_matrix ( rot ) self . rot_m = rot_m # Rotate lv1 and lv2 vectors self . lv1 = rot_m @ self . lv1 self . lv2 = rot_m @ self . lv2 # Rotate lattice_points self . lattice_points = [ [ * ( rot_m @ ( np . array ([ x , y ]) + np . array ( translation ))), point_type ] for x , y , point_type in self . lattice_points ] # Rotate neighbours self . neighbours = { point_type : [ rot_m @ np . array ( neighbour ) for neighbour in neighbour_list ] for point_type , neighbour_list in self . neighbours . items () } def generate_points ( self , mlv1 : np . ndarray , mlv2 : np . ndarray , mln1 : int = 1 , mln2 : int = 1 , test : bool = False , ) -> None : \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.ndarray): The first Moir\u00e9 lattice vector. mlv2 (np.ndarray): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test (bool, optional): If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None: The function modifies the object state and stores the generated points and their types. Raises: AssersionError: If mln1 and mln2 are not positive integers. AssersionError: if test is True and mln1 or mln2 is not 1 Example: ```python >>> lattice = MyLattice() # a class inheriting the Layer class >>> lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1) >>> print(lattice.points) ``` \"\"\" # raise the promised errors: assert isinstance ( mln1 , int ) and mln1 > 0 , \"mln1 must be a positive integer.\" assert isinstance ( mln2 , int ) and mln2 > 0 , \"mln2 must be a positive integer.\" if test : assert mln1 == 1 and mln2 == 1 , \"If test is True, both mln1 and mln2 must be 1.\" self . mlv1 = mlv1 # Moire lattice vector 1 self . mlv2 = mlv2 # Moire lattice vector 2 self . mln1 = mln1 # Number of moire unit cells along mlv1 self . mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the number of points along each direction points = [ np . array ([ 0 , 0 ]), mlv1 , mlv2 , mlv1 + mlv2 ] max_distance = max ( np . linalg . norm ( points [ 0 ] - points [ 1 ]), np . linalg . norm ( points [ 0 ] - points [ 2 ]), np . linalg . norm ( points [ 0 ] - points [ 3 ]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math . ceil ( max_distance / min ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range ( - n , n + 1 ): # Iterate along mlv1 for j in range ( - n , n + 1 ): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self . lv1 + j * self . lv2 for xpos , ypos , name in self . lattice_points : point = point_o + np . array ([ xpos , ypos ]) step1_points . append ( point ) step1_names . append ( name ) step1_points = np . array ( step1_points ) step1_names = np . array ( step1_names ) # Apply the boundary check method (inside_boundaries) to filter the points mask = self . _inside_boundaries ( step1_points , 1 , 1 ) # generating points only inside the first cell now step1_points = step1_points [ mask ] step1_names = step1_names [ mask ] # Step 3: Copy and translate the unit cell to create the full lattice points = [] # List to hold all the moire points names = [] for i in range ( self . mln1 ): # Translate along mlv1 direction for j in range ( self . mln2 ): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points . append ( translated_points ) names . append ( step1_names ) self . points = np . vstack ( points ) self . point_types = np . hstack ( names ) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") if not test : self . generate_kdtree () def _point_positions ( self , points : np . ndarray , A : np . ndarray , B : np . ndarray ) -> np . ndarray : \"\"\" Determines the position of each point relative to a parallelogram defined by vectors A and B. Args: points (np.ndarray): Array of points to be analyzed. A (np.ndarray): The first vector of the parallelogram. B (np.ndarray): The second vector of the parallelogram. Returns: np.ndarray: An array indicating the position of each point: - (0, 0) for points inside the parallelogram. - (-1, 1) or (1, -1) for points outside on specific sides. left side and right side will give -1 and 1 respectively top side and bottom side will give -1 and 1 respectively \"\"\" # Compute determinants for positions relative to OA and BC det_OA = ( points [:, 0 ] * A [ 1 ] - points [:, 1 ] * A [ 0 ]) <= self . toll_scale * 1e-2 det_BC = (( points [:, 0 ] - B [ 0 ]) * A [ 1 ] - ( points [:, 1 ] - B [ 1 ]) * A [ 0 ]) <= self . toll_scale * 1e-2 position_y = det_OA . astype ( float ) + det_BC . astype ( float ) # Compute determinants for positions relative to OB and AC det_OB = ( points [:, 0 ] * B [ 1 ] - points [:, 1 ] * B [ 0 ]) > - self . toll_scale * 1e-2 det_AC = (( points [:, 0 ] - A [ 0 ]) * B [ 1 ] - ( points [:, 1 ] - A [ 1 ]) * B [ 0 ]) > - self . toll_scale * 1e-2 position_x = det_OB . astype ( float ) + det_AC . astype ( float ) return np . column_stack (( position_x , position_y )) - 1 def _inside_polygon ( self , points : np . ndarray , polygon : np . ndarray ) -> np . ndarray : \"\"\" Determines if each point is inside a polygon using the ray-casting method. Args: points (np.ndarray): Array of points to check. polygon (np.ndarray): Vertices of the polygon to test against, in counterclockwise order. Returns: np.ndarray: A boolean array where True indicates that the point is inside the polygon. Example: ```python points = np.array([[0.5, 0.5], [1, 1], [-1, -1]]) polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]) inside = _inside_polygon(points, polygon) print(inside) ``` \"\"\" x , y = points [:, 0 ], points [:, 1 ] px , py = polygon [:, 0 ], polygon [:, 1 ] px_next , py_next = np . roll ( px , - 1 ), np . roll ( py , - 1 ) edge_cond = ( y [:, None ] > np . minimum ( py , py_next )) & ( y [:, None ] <= np . maximum ( py , py_next )) with np . errstate ( divide = 'ignore' , invalid = 'ignore' ): xinters = np . where ( py != py_next , ( y [:, None ] - py ) * ( px_next - px ) / ( py_next - py ) + px , np . inf ) ray_crosses = edge_cond & ( x [:, None ] <= xinters ) inside = np . sum ( ray_crosses , axis = 1 ) % 2 == 1 return inside # mask def _inside_boundaries ( self , points : np . ndarray , mln1 = None , mln2 = None ) -> np . ndarray : \"\"\" Determines if the given points lie within the boundaries of the Moir\u00e9 lattice pattern. Args: points (np.ndarray): Array of points to check. mln1 (int, optional): The number of unit cells along the first direction. Defaults to the object's current value. mln2 (int, optional): The number of unit cells along the second direction. Defaults to the object's current value. Returns: np.ndarray: A boolean array where True indicates that the point is within the boundaries of the lattice. Raises: ValueError: If the points array has an invalid shape. Example: ```python points = np.array([[0.5, 0.5], [2, 2], [-1, -1]]) lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3) print(lattice_boundaries) ``` \"\"\" v1 = ( mln1 if mln1 else self . mln1 ) * self . mlv1 v2 = ( mln2 if mln2 else self . mln2 ) * self . mlv2 p1 = np . array ([ 0 , 0 ]) p2 = np . array ([ v1 [ 0 ], v1 [ 1 ]]) p3 = np . array ([ v2 [ 0 ], v2 [ 1 ]]) p4 = np . array ([ v1 [ 0 ] + v2 [ 0 ], v1 [ 1 ] + v2 [ 1 ]]) shift_dir = - ( v1 + v2 ) shift_dir = shift_dir / np . linalg . norm ( shift_dir ) # normalize shift = shift_dir * self . toll_scale * 1e-4 return self . _inside_polygon ( points , np . array ([ p1 , p2 , p4 , p3 ]) + shift ) def generate_kdtree ( self ) -> None : \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. \"\"\" if not self . pbc : # OBC is easy self . kdtree = KDTree ( self . points ) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range ( - 1 , 2 ): for j in range ( - 1 , 2 ): all_points . append ( self . points + i * self . mln1 * self . mlv1 + j * self . mln2 * self . mlv2 ) all_point_names . append ( self . point_types ) all_points = np . vstack ( all_points ) all_point_names = np . hstack ( all_point_names ) v1 = self . mln1 * self . mlv1 v2 = self . mln2 * self . mlv2 neigh_pad_1 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv1 ) / np . linalg . norm ( v1 ) neigh_pad_2 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv2 ) / np . linalg . norm ( v2 ) mask = self . _inside_polygon ( all_points , np . array ([ ( - neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ( - neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ])) # print(mask.shape, mask.dtype) points = all_points [ mask ] point_names = all_point_names [ mask ] self . bigger_points = points self . bigger_point_types = point_names self . kdtree = KDTree ( points ) self . _generate_mapping () # # plot the points but with colours based on the point_positions # # - point_positions = [0, 0] -> black # # - point_positions = [1, 0] -> red # # - do not plot the rest of the points at all # plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], 'k.') # plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], 'r.') # plt.plot(*all_points.T, \"ro\") # plt.plot(*points.T, \"b.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.grid() # plt.show() def _generate_mapping ( self ) -> None : \"\"\" Generates a mapping between two sets of points (larger and smaller lattices) based on their positions and computes the distances between corresponding points. If the distance between a point in the larger lattice and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots the lattice points for visualization. This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice. It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points` and values are the corresponding indices in `self.points`. Raises: ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`. Example: ```python my_lattice._generate_mapping() ``` The function performs the following steps: 1. Initializes an empty dictionary `self.mappings`. 2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`). 3. Computes the translation needed for each point based on a lattice scaling factor. 4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points. 5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`. 6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization. Note: - The function assumes `self.points` and `self.bigger_points` are defined as numpy arrays with the coordinates of the points in the lattices. - The translations used in the function are calculated based on `mln1`, `mln2`, `mlv1`, and `mlv2`, which define the lattice scaling and vectors. \"\"\" self . mappings = {} tree = KDTree ( self . points ) # smaller set translations = self . _point_positions ( self . bigger_points , self . mln1 * self . mlv1 , self . mln2 * self . mlv2 ) for i , ( dx , dy ) in enumerate ( translations ): mapped_point = self . bigger_points [ i ] - ( dx * self . mlv1 * self . mln1 + dy * self . mlv2 * self . mln2 ) distance , index = tree . query ( mapped_point ) if distance >= self . toll_scale * 1e-3 : # print(f\"Distance {distance} exceeds tolerance for {i}th point {self.bigger_points[i]} mapped at location {mapped_point} with translation ({dx}, {dy}).\") # plt.plot(*self.bigger_points.T, \"ko\", alpha=0.3) # plt.plot(*self.points.T, \"k.\") # # plt.plot(*self.bigger_points[i], \"b.\") # # plt.plot(*mapped_point, \"r.\") # # plt.plot(*self.points[index], \"g.\") # # parallellogram around the whole lattice # plt.plot([0, self.mln1 * self.mlv1[0]], [0, self.mln1 * self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mln2 * self.mlv2[0]], [0, self.mln2 * self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln1 * self.mlv1[0], self.mln1 * self.mlv1[0] + self.mln2 * self.mlv2[0]], [self.mln1 * self.mlv1[1], self.mln1 * self.mlv1[1] + self.mln2 * self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mln2 * self.mlv2[0], self.mln1 * self.mlv1[0] + self.mln2 * self.mlv2[0]], [self.mln2 * self.mlv2[1], self.mln1 * self.mlv1[1] + self.mln2 * self.mlv2[1]], 'k', linewidth=1) # # just plot mlv1 and mlv2 parallellogram # plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], 'k', linewidth=1) # plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self. mlv2[1], self.mlv1[1] + self.mlv2[1]], 'k', linewidth=1) # # for index, mapped_point in enumerate(self.bigger_points): # # plt.text(*mapped_point, f\"{index}\", fontsize=6) # plt.gca().add_patch(plt.Circle(mapped_point, distance / 2, color='r', fill=False)) # plt.grid() # plt.show() raise ValueError ( f \"FATAL ERROR: Distance { distance } exceeds tolerance for { i } th point { self . bigger_points [ i ] } mapped at location { mapped_point } with translation ( { dx } , { dy } ).\" ) self . mappings [ i ] = index # point positions... for each point in self.point, point position is a array of length 2 (x, y) # where the elemnts are -1, 0 and 1... this is what their value mean about their position # (-1, 1) | (0, 1) | (1, 1) # ----------------------------- # (-1, 0) | (0, 0) | (1, 0) # ----------------------------- # (-1,-1) | (0,-1) | (1,-1) # ----------------------------- # (0, 0) is our actual lattice part... # do this for all points in self.bigger_points: # all point with point_positions = (x, y) need to be translated by # (-x*self.mlv1*self.mln1 - y*self.mlv2*self.mln2) to get the corresponding point inside the lattice # then you would need to run a query on a newly kdtree of the smaller points... # to the get the index of the corresponding point inside the lattice (distance should be zero, just saying) # now we already know the index of the point in the self.bigger_points... so we can map that to the index of the point in the self.points # then we will store that in `self.mappings`` # self.mapppings will be a dictionary with keys as the indices in the # self.bigger_points (unique) and values as the indices in the self.points (not unique) # def kth_nearest_neighbours(self, points, types, k = 1) -> None: # distance_matrix = self.kdtree.sparse_distance_matrix(self.kdtree, k) def first_nearest_neighbours ( self , points : np . ndarray , types : np . ndarray ): assert self . kdtree is not None unique_types = np . unique ( types ) max_neighs = max ( len ( self . neighbours [ t ]) for t in unique_types ) n_points = points . shape [ 0 ] bigger_indices_arr = np . full (( n_points , max_neighs ), - 1 , dtype = int ) smaller_indices_arr = np . full (( n_points , max_neighs ), - 1 , dtype = int ) smaller_distances_arr = np . full (( n_points , max_neighs ), np . nan , dtype = float ) # Pre-compute mapping array for vectorized indexing if self . pbc : map_arr = np . array ([ self . mappings [ i ] for i in range ( len ( self . bigger_points ))]) for t in unique_types : # 1. Mask to find all points of this specific type mask = ( types == t ) type_points = points [ mask ] # Shape (N_t, 2) rel_neighs = np . array ( self . neighbours [ t ]) # Shape (M_t, 2) n_curr = len ( rel_neighs ) # 2. Vectorized meshgrid to get all absolute neighbor coordinates # absolute_coords shape: (N_t, M_t, 2) absolute_coords = type_points [:, np . newaxis , :] + rel_neighs [ np . newaxis , :, :] # 3. Bulk Query (KDTree supports multidimensional input) # distances/indices shape: (N_t, M_t) distances , indices = self . kdtree . query ( absolute_coords , k = 1 ) # 4. Bulk Assignment if self . pbc : if np . any ( distances > 1e-2 * self . toll_scale ): raise ValueError ( f \"Distance exceeds tolerance for type { t } \" ) bigger_indices_arr [ mask , : n_curr ] = indices smaller_indices_arr [ mask , : n_curr ] = map_arr [ indices ] else : bigger_indices_arr [ mask , : n_curr ] = indices smaller_indices_arr [ mask , : n_curr ] = indices smaller_distances_arr [ mask , : n_curr ] = distances return bigger_indices_arr , smaller_indices_arr , smaller_distances_arr def get_neighbors_within_radius ( self , query_points : np . ndarray , radius : float ): assert self . kdtree is not None # 1. Scipy's fast radius search # Returns a list of lists: [[neighs_for_p0], [neighs_for_p1], ...] indices_list = self . kdtree . query_ball_point ( query_points , r = radius ) # 2. Vectorized Flattening # Calculate counts per query point to repeat indices correctly counts = np . array ([ len ( nb ) for nb in indices_list ]) if counts . sum () == 0 : return np . array ([], dtype = int ), np . array ([], dtype = int ), np . array ([]) . reshape ( 0 , 2 ) # query_indices: [0, 0, 0, 1, 1, ...] query_indices = np . repeat ( np . arange ( len ( query_points )), counts ) # tree_indices: flattened neighbor indices from the KDTree tree_indices = np . concatenate ([ nb for nb in indices_list if len ( nb ) > 0 ]) # 3. Retrieve Coordinates if self . pbc : neighbor_coords = self . bigger_points [ tree_indices ] # REPLACEMENT FOR LAMBDA MAPPER: Direct Array Lookup # We pre-mapped these during generate_kdtree map_arr = np . array ([ self . mappings [ i ] for i in range ( len ( self . bigger_points ))]) lattice_indices = map_arr [ tree_indices ] else : neighbor_coords = self . points [ tree_indices ] lattice_indices = tree_indices return query_indices , lattice_indices , neighbor_coords def plot_lattice ( self , plot_connections : bool = True , colours : list = [ \"r\" , \"g\" , \"b\" , \"c\" , \"m\" , \"y\" , \"k\" ]) -> None : \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. colours (list, optional): List of matplotlib colours to use for different point types. Behavior: - Plots all lattice points grouped by type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. Example: ```python lattice = MyLattice() lattice.generate_points() lattice.plot_lattice(plot_connections=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. \"\"\" if len ( colours ) == 1 : cols = { t [ - 1 ]: colours [ 0 ] for i , t , in enumerate ( self . lattice_points )} else : cols = { t [ - 1 ]: colours [ i ] for i , t , in enumerate ( self . lattice_points )} # plt.scatter( # [self.points[:, 0]], # [self.points[:, 1]], # s=10, c=np.vectorize(cols.get)(self.point_types) # ) if plot_connections : a = [] for this , point_type in zip ( self . points , self . point_types ): for delta in self . neighbours [ point_type ]: a . append ([ this [ 0 ], this [ 0 ] + delta [ 0 ]]) a . append (( this [ 1 ], this [ 1 ] + delta [ 1 ])) a . append ( \"k--\" ) # a = a[:30] # print(a) plt . plot ( * a , alpha = 0.1 ) # plt.title(\"Lattice Points\") # plt.xlabel(\"X Coordinate\") # plt.ylabel(\"Y Coordinate\") plt . axis ( \"equal\" ) def __repr__ ( self ): return ( f \"\"\"Layer( lv1 = { self . lv1 } , lv2 = { self . lv2 } , lattice_points = { self . lattice_points } , study_proximity = { self . study_proximity } , pbc = { self . pbc } , )\"\"\" )","title":"Layer"},{"location":"api/layers/#moirepy.layers.Layer.__init__","text":"Initializes the Layer object Parameters: pbc ( bool , default: False ) \u2013 Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity ( int , default: 1 ) \u2013 Scaling factor for proximity calculations, enabling the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError \u2013 If lv1 is not along the x-axis or if lv2 has a negative y-component. Source code in moirepy/layers.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def __init__ ( self , pbc : bool = False , study_proximity : int = 1 ) -> None : \"\"\" Initializes the Layer object Args: pbc (bool): Flag to indicate if periodic boundary conditions (PBC) are applied. study_proximity (int): Scaling factor for proximity calculations, **enabling** the number of nearest neighbors. This is the upper bound for the number of nearest neighbours you will be calculating throughout the code. If you try to calculate higher order neighbours, it might lead to errors, or worse give wrong answers silently. Raises: ValueError: If `lv1` is not along the x-axis or if `lv2` has a negative y-component. \"\"\" required_attrs = [ \"lv1\" , \"lv2\" , \"lattice_points\" , \"neighbours\" ] for attr in required_attrs : if not hasattr ( self , attr ): raise NotImplementedError ( f \"Subclass { self . __class__ . __name__ } must define ' { attr } '\" ) self . toll_scale = max ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ) ) if self . lv1 [ 1 ] != 0 or self . lv2 [ 1 ] < 0 : raise ValueError ( \"\"\"lv1 was expected to be along the x-axis, and lv2 should have a +ve y component Please refer to the documentation for more information: https://jabed-umar.github.io/MoirePy/find_theta/ \"\"\" ) self . rot_m = np . eye ( 2 ) # will be replaced if called perform_rotation self . pbc = pbc self . points = None self . kdtree = None self . study_proximity = study_proximity self . lattice_angle = np . arccos ( np . dot ( self . lv1 , self . lv2 ) / ( np . linalg . norm ( self . lv1 ) * np . linalg . norm ( self . lv2 )))","title":"__init__"},{"location":"api/layers/#moirepy.layers.Layer.generate_kdtree","text":"Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None ( None ) \u2013 The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError \u2013 If the points in the lattice are not defined. Source code in moirepy/layers.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def generate_kdtree ( self ) -> None : \"\"\" Generates a KDTree for spatial queries of points in the Moir\u00e9 lattice. If PBC is enabled, additional points outside the primary unit cell are considered for accurate queries (same numbers of neigbours for all points). Returns: None: The function modifies the object state by generating a KDTree for spatial queries. Raises: ValueError: If the points in the lattice are not defined. \"\"\" if not self . pbc : # OBC is easy self . kdtree = KDTree ( self . points ) return # in case of periodic boundary conditions, we need to generate a bigger set of points all_points = [] all_point_names = [] for i in range ( - 1 , 2 ): for j in range ( - 1 , 2 ): all_points . append ( self . points + i * self . mln1 * self . mlv1 + j * self . mln2 * self . mlv2 ) all_point_names . append ( self . point_types ) all_points = np . vstack ( all_points ) all_point_names = np . hstack ( all_point_names ) v1 = self . mln1 * self . mlv1 v2 = self . mln2 * self . mlv2 neigh_pad_1 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv1 ) / np . linalg . norm ( v1 ) neigh_pad_2 = ( 1 + self . study_proximity ) * np . linalg . norm ( self . lv2 ) / np . linalg . norm ( v2 ) mask = self . _inside_polygon ( all_points , np . array ([ ( - neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( - neigh_pad_2 ) * v2 , ( 1 + neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ( - neigh_pad_1 ) * v1 + ( 1 + neigh_pad_2 ) * v2 , ])) # print(mask.shape, mask.dtype) points = all_points [ mask ] point_names = all_point_names [ mask ] self . bigger_points = points self . bigger_point_types = point_names self . kdtree = KDTree ( points ) self . _generate_mapping ()","title":"generate_kdtree"},{"location":"api/layers/#moirepy.layers.Layer.generate_points","text":"Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Parameters: mlv1 ( ndarray ) \u2013 The first Moir\u00e9 lattice vector. mlv2 ( ndarray ) \u2013 The second Moir\u00e9 lattice vector. mln1 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 ( int , default: 1 ) \u2013 The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test ( bool , default: False ) \u2013 If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None ( None ) \u2013 The function modifies the object state and None \u2013 stores the generated points and their types. Raises: AssersionError \u2013 If mln1 and mln2 are not positive integers. AssersionError \u2013 if test is True and mln1 or mln2 is not 1 Example: >>> lattice = MyLattice () # a class inheriting the Layer class >>> lattice . generate_points ( np . array ([ 1 , 0 ]), np . array ([ 0.5 , np . sqrt ( 3 ) / 2 ]), mln1 = 1 , mln2 = 1 ) >>> print ( lattice . points ) Source code in moirepy/layers.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def generate_points ( self , mlv1 : np . ndarray , mlv2 : np . ndarray , mln1 : int = 1 , mln2 : int = 1 , test : bool = False , ) -> None : \"\"\" Generates points for a Moir\u00e9 lattice based on the given lattice vectors and the number of unit cells along each direction. Args: mlv1 (np.ndarray): The first Moir\u00e9 lattice vector. mlv2 (np.ndarray): The second Moir\u00e9 lattice vector. mln1 (int, optional): The number of Moir\u00e9 unit cells along the first lattice vector. Defaults to 1. mln2 (int, optional): The number of Moir\u00e9 unit cells along the second lattice vector. Defaults to 1. test (bool, optional): If we are generating points just for testing purpose. kdtree will not be prepared and mln1 and mln2 both need to be 1 Returns: None: The function modifies the object state and stores the generated points and their types. Raises: AssersionError: If mln1 and mln2 are not positive integers. AssersionError: if test is True and mln1 or mln2 is not 1 Example: ```python >>> lattice = MyLattice() # a class inheriting the Layer class >>> lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1) >>> print(lattice.points) ``` \"\"\" # raise the promised errors: assert isinstance ( mln1 , int ) and mln1 > 0 , \"mln1 must be a positive integer.\" assert isinstance ( mln2 , int ) and mln2 > 0 , \"mln2 must be a positive integer.\" if test : assert mln1 == 1 and mln2 == 1 , \"If test is True, both mln1 and mln2 must be 1.\" self . mlv1 = mlv1 # Moire lattice vector 1 self . mlv2 = mlv2 # Moire lattice vector 2 self . mln1 = mln1 # Number of moire unit cells along mlv1 self . mln2 = mln2 # Number of moire unit cells along mlv2 # Step 1: Find the maximum distance to determine the number of points along each direction points = [ np . array ([ 0 , 0 ]), mlv1 , mlv2 , mlv1 + mlv2 ] max_distance = max ( np . linalg . norm ( points [ 0 ] - points [ 1 ]), np . linalg . norm ( points [ 0 ] - points [ 2 ]), np . linalg . norm ( points [ 0 ] - points [ 3 ]), ) # Calculate number of grid points based on maximum distance and lattice vectors n = math . ceil ( max_distance / min ( np . linalg . norm ( self . lv1 ), np . linalg . norm ( self . lv2 ))) * 2 # print(f\"Calculated grid size: {n}\") # Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`) step1_points = [] # List to hold points inside the unit cell step1_names = [] # List to hold the names of the points for i in range ( - n , n + 1 ): # Iterate along mlv1 for j in range ( - n , n + 1 ): # Iterate along mlv2 # Calculate the lattice point inside the unit cell point_o = i * self . lv1 + j * self . lv2 for xpos , ypos , name in self . lattice_points : point = point_o + np . array ([ xpos , ypos ]) step1_points . append ( point ) step1_names . append ( name ) step1_points = np . array ( step1_points ) step1_names = np . array ( step1_names ) # Apply the boundary check method (inside_boundaries) to filter the points mask = self . _inside_boundaries ( step1_points , 1 , 1 ) # generating points only inside the first cell now step1_points = step1_points [ mask ] step1_names = step1_names [ mask ] # Step 3: Copy and translate the unit cell to create the full lattice points = [] # List to hold all the moire points names = [] for i in range ( self . mln1 ): # Translate along mlv1 direction for j in range ( self . mln2 ): # Translate along mlv2 direction translation_vector = i * mlv1 + j * mlv2 translated_points = step1_points + translation_vector # Translate points points . append ( translated_points ) names . append ( step1_names ) self . points = np . vstack ( points ) self . point_types = np . hstack ( names ) # print(f\"{self.point_types.shape=}, {self.points.shape=}\") if not test : self . generate_kdtree ()","title":"generate_points"},{"location":"api/layers/#moirepy.layers.Layer.perform_rotation_translation","text":"Rotates and translates the lattice layer and its components. Has to be applied before point generation. Parameters: rot ( float ) \u2013 The rotation angle in radians. Default to None . translation ( Tuple [ float , float ] , default: (0, 0) ) \u2013 The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None ( None ) \u2013 The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: layer . perform_rotation_translation ( np . pi / 4 , ( 1 , 1 )) Source code in moirepy/layers.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def perform_rotation_translation ( self , rot : float , translation : Tuple [ float , float ] = ( 0 , 0 )) -> None : \"\"\" Rotates and translates the lattice layer and its components. Has to be applied before point generation. Args: rot (float): The rotation angle in radians. Default to `None`. translation (Tuple[float, float]): The translation vector (dx, dy) for each point on the lattice. new position = old position + translation translation will be applied before the rotation Returns: None: The function modifies the rotation matrix and updates the lattice points and neighbors in place. Example: ```python layer.perform_rotation_translation(np.pi/4, (1, 1)) ``` \"\"\" assert self . points is None , \"Cannot perform rotation and translation after points have been generated.\" rot_m = get_rotation_matrix ( rot ) self . rot_m = rot_m # Rotate lv1 and lv2 vectors self . lv1 = rot_m @ self . lv1 self . lv2 = rot_m @ self . lv2 # Rotate lattice_points self . lattice_points = [ [ * ( rot_m @ ( np . array ([ x , y ]) + np . array ( translation ))), point_type ] for x , y , point_type in self . lattice_points ] # Rotate neighbours self . neighbours = { point_type : [ rot_m @ np . array ( neighbour ) for neighbour in neighbour_list ] for point_type , neighbour_list in self . neighbours . items () }","title":"perform_rotation_translation"},{"location":"api/layers/#moirepy.layers.Layer.plot_lattice","text":"Plots the lattice points and optionally the connections between them and the unit cell structure. Parameters: plot_connections ( bool , default: True ) \u2013 If True, plots the connections between nearest neighbors. Defaults to True. colours ( list , default: ['r', 'g', 'b', 'c', 'm', 'y', 'k'] ) \u2013 List of matplotlib colours to use for different point types. Behavior Plots all lattice points grouped by type. If plot_connections is True, it draws dashed red lines between nearest neighbors. Example: lattice = MyLattice () lattice . generate_points () lattice . plot_lattice ( plot_connections = True ) Visualization Details Lattice points are plotted as small dots. Nearest neighbor connections (if enabled) are shown as dashed red lines. Source code in moirepy/layers.py 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 def plot_lattice ( self , plot_connections : bool = True , colours : list = [ \"r\" , \"g\" , \"b\" , \"c\" , \"m\" , \"y\" , \"k\" ]) -> None : \"\"\" Plots the lattice points and optionally the connections between them and the unit cell structure. Args: plot_connections (bool, optional): If True, plots the connections between nearest neighbors. Defaults to True. colours (list, optional): List of matplotlib colours to use for different point types. Behavior: - Plots all lattice points grouped by type. - If `plot_connections` is True, it draws dashed red lines between nearest neighbors. Example: ```python lattice = MyLattice() lattice.generate_points() lattice.plot_lattice(plot_connections=True) ``` Visualization Details: - Lattice points are plotted as small dots. - Nearest neighbor connections (if enabled) are shown as dashed red lines. \"\"\" if len ( colours ) == 1 : cols = { t [ - 1 ]: colours [ 0 ] for i , t , in enumerate ( self . lattice_points )} else : cols = { t [ - 1 ]: colours [ i ] for i , t , in enumerate ( self . lattice_points )} # plt.scatter( # [self.points[:, 0]], # [self.points[:, 1]], # s=10, c=np.vectorize(cols.get)(self.point_types) # ) if plot_connections : a = [] for this , point_type in zip ( self . points , self . point_types ): for delta in self . neighbours [ point_type ]: a . append ([ this [ 0 ], this [ 0 ] + delta [ 0 ]]) a . append (( this [ 1 ], this [ 1 ] + delta [ 1 ])) a . append ( \"k--\" ) # a = a[:30] # print(a) plt . plot ( * a , alpha = 0.1 ) # plt.title(\"Lattice Points\") # plt.xlabel(\"X Coordinate\") # plt.ylabel(\"Y Coordinate\") plt . axis ( \"equal\" )","title":"plot_lattice"},{"location":"api/moire/","text":"BilayerMoireLattice Source code in moirepy/moire.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 class BilayerMoireLattice : # both layers same, only one point in one unit cell def __init__ ( self , latticetype : Layer , ll1 : int , ll2 : int , # lower lattice ul1 : int , ul2 : int , # upper lattice n1 : int = 1 , n2 : int = 1 , translate_upper = ( 0 , 0 ), pbc : bool = True , k : int = 1 , # number of orbitals verbose = True , ): \"\"\" Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Args: latticetype (Layer): A subclass of the `Layer` class representing the lattice type used for both layers. ll1, ll2, ul1, ul2 (int): Values select from the [AVC tool](https://jabed-umar.github.io/MoirePy/theory/avc/). n1 (int, optional): Number of moir\u00e9 cells along the first lattice vector. n2 (int, optional): Number of moir\u00e9 cells along the second lattice vector. translate_upper (tuple, optional): Translation vector (dx, dy) applied to the upper layer before rotation. pbc (bool, optional): Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k (int, optional): Number of orbitals on each lattice point. \"\"\" # study_proximity = 1 means only studying nearest neighbours will be enabled, # 2 means study of next nearest neighbours will be enabled too and so on, # always better to keep this value 1 or two more than what you will actually need. lower_lattice = latticetype ( pbc = pbc ) upper_lattice = latticetype ( pbc = pbc ) lv1 , lv2 = lower_lattice . lv1 , lower_lattice . lv2 # c = cos(theta) between lv1 and lv2 (60 degree for triangular, 90 for square and so on) c = np . dot ( lv1 , lv2 ) / ( np . linalg . norm ( lv1 ) * np . linalg . norm ( lv2 )) beta = np . arccos ( c ) mlv1 = ll1 * lv1 + ll2 * lv2 # because lower latice is fixed mlv2 = get_rotation_matrix ( beta ) . dot ( mlv1 ) # calculating the moire twist angle one = ll1 * lv1 + ll2 * lv2 # the coords of overlapping point in the lower lattice two = ul1 * lv1 + ul2 * lv2 # the coords of overlapping point in the upper lattice assert np . isclose ( np . linalg . norm ( one ), np . linalg . norm ( two )), \"INPUT ERROR: the two points are not overlapping, check ll1, ll2, ul1, ul2 values\" c = np . dot ( one , two ) / ( np . linalg . norm ( one ) * np . linalg . norm ( two )) theta = np . arccos ( c ) # in radians if verbose : print ( f \"twist angle = { theta : .4f } rad ( { np . rad2deg ( theta ) : .4f } deg)\" ) upper_lattice . perform_rotation_translation ( theta , translate_upper ) assert ( are_coeffs_integers ( lower_lattice . lv1 , lower_lattice . lv2 , mlv1 ) and are_coeffs_integers ( upper_lattice . lv1 , upper_lattice . lv2 , mlv1 ) ), \"FATAL ERROR: calculated mlv2 is incorrect\" lower_lattice . generate_points ( mlv1 , mlv2 , n1 , n2 ) upper_lattice . generate_points ( mlv1 , mlv2 , n1 , n2 ) # print(f\"{mlv1 = }\") # print(f\"{mlv2 = }\") self . ll1 = ll1 self . ll2 = ll2 self . ul1 = ul1 self . ul2 = ul2 self . n1 = n1 self . n2 = n2 self . translate_upper = translate_upper self . lower_lattice = lower_lattice self . upper_lattice = upper_lattice self . theta = theta self . mlv1 = mlv1 self . mlv2 = mlv2 self . pbc = pbc self . orbitals = k self . ham = None if verbose : print ( f \" { len ( self . upper_lattice . points ) } cells in upper lattice\" ) print ( f \" { len ( self . lower_lattice . points ) } cells in lower lattice\" ) assert len ( self . lower_lattice . points ) == len ( self . upper_lattice . points ), \"FATAL ERROR: number of cells in lower and upper lattice are not equal, report and take different ll1, ll2, ul1, ul2 values\" # self.plot_lattice() def plot_lattice ( self ): mlv1 = self . mlv1 mlv2 = self . mlv2 n1 = self . n1 n2 = self . n2 plt . plot ( * zip ( * self . lower_lattice . points ), 'r.' , markersize = 2 ) plt . plot ( * zip ( * self . upper_lattice . points ), 'b.' , markersize = 2 ) self . lower_lattice . plot_lattice ( colours = [ \"b\" ], plot_connections = True ) self . upper_lattice . plot_lattice ( colours = [ \"r\" ], plot_connections = True ) # parallellogram around the whole lattice plt . plot ([ 0 , n1 * mlv1 [ 0 ]], [ 0 , n1 * mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , n2 * mlv2 [ 0 ]], [ 0 , n2 * mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ n1 * mlv1 [ 0 ], n1 * mlv1 [ 0 ] + n2 * mlv2 [ 0 ]], [ n1 * mlv1 [ 1 ], n1 * mlv1 [ 1 ] + n2 * mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ n2 * mlv2 [ 0 ], n1 * mlv1 [ 0 ] + n2 * mlv2 [ 0 ]], [ n2 * mlv2 [ 1 ], n1 * mlv1 [ 1 ] + n2 * mlv2 [ 1 ]], 'k' , linewidth = 1 ) # just plot mlv1 and mlv2 parallellogram plt . plot ([ 0 , mlv1 [ 0 ]], [ 0 , mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , mlv2 [ 0 ]], [ 0 , mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ mlv1 [ 0 ], mlv1 [ 0 ] + mlv2 [ 0 ]], [ mlv1 [ 1 ], mlv1 [ 1 ] + mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ mlv2 [ 0 ], mlv1 [ 0 ] + mlv2 [ 0 ]], [ mlv2 [ 1 ], mlv1 [ 1 ] + mlv2 [ 1 ]], 'k' , linewidth = 1 ) # set equal aspect ratio plt . gca () . set_aspect ( 'equal' , adjustable = 'box' ) # plt.grid() # plt.show() # plt.savefig(\"moire.pdf\", bbox_inches='tight') def _as_callable ( self , val , n_args = 4 ): if callable ( val ): return val if n_args == 4 : return lambda c1 , c2 , t1 , t2 : val if val is not None else 0 return lambda c , t : val if val is not None else 0 def _validate_hamiltonian_inputs ( self , tll , tuu , tlu , tul , tuself , tlself ): \"\"\"Helper to ensure all hopping terms are callable.\"\"\" tll , tuu , tlu , tul = [ self . _as_callable ( t , 4 ) for t in ( tll , tuu , tlu , tul )] tuself , tlself = [ self . _as_callable ( t , 2 ) for t in ( tuself , tlself )] assert all ( callable ( fn ) for fn in ( tll , tuu , tlu , tul , tuself , tlself ) ), \"Hopping parameters must be floats, ints, or callable functions.\" return tll , tuu , tlu , tul , tuself , tlself def generate_hamiltonian ( self , tll : Union [ float , int , Callable ] = None , tuu : Union [ float , int , Callable ] = None , tlu : Union [ float , int , Callable ] = None , tul : Union [ float , int , Callable ] = None , tuself : Union [ float , int , Callable ] = None , tlself : Union [ float , int , Callable ] = None , inter_layer_radius : float = 3.0 , data_type : np . dtype = np . float64 , ): k = self . orbitals n_lower = len ( self . lower_lattice . points ) n_upper = len ( self . upper_lattice . points ) total_dim = ( n_lower + n_upper ) * k tll , tuu , tlu , tul , tuself , tlself = self . _validate_hamiltonian_inputs ( tll , tuu , tlu , tul , tuself , tlself ) builder = COOBuilder () # 1. Lower Lattice Intra-layer (Indices: 0 to n_lower*k - 1) for i in range ( n_lower ): val = tlself ( self . lower_lattice . points [ i ], self . lower_lattice . point_types [ i ]) for o in range ( k ): builder . add ( i * k + o , i * k + o , val ) bigger_indices , indices , _ = self . lower_lattice . first_nearest_neighbours ( self . lower_lattice . points , self . lower_lattice . point_types ) for this_i in range ( n_lower ): this_coo , this_type = self . lower_lattice . points [ this_i ], self . lower_lattice . point_types [ this_i ] for phantom_neigh_i , neigh_i in zip ( bigger_indices [ this_i ], indices [ this_i ]): neigh_coo = self . lower_lattice . bigger_points [ phantom_neigh_i ] if self . pbc else self . lower_lattice . points [ neigh_i ] neigh_type = self . lower_lattice . point_types [ neigh_i ] val = tll ( this_coo , neigh_coo , this_type , neigh_type ) for o1 in range ( k ): for o2 in range ( k ): builder . add ( this_i * k + o1 , neigh_i * k + o2 , val ) # 2. Upper Lattice Intra-layer (Indices: n_lower*k to total_dim - 1) offset = n_lower * k for i in range ( n_upper ): val = tuself ( self . upper_lattice . points [ i ], self . upper_lattice . point_types [ i ]) for o in range ( k ): builder . add ( offset + i * k + o , offset + i * k + o , val ) bigger_indices , indices , _ = self . upper_lattice . first_nearest_neighbours ( self . upper_lattice . points , self . upper_lattice . point_types ) for this_i in range ( n_upper ): this_coo , this_type = self . upper_lattice . points [ this_i ], self . upper_lattice . point_types [ this_i ] for phantom_neigh_i , neigh_i in zip ( bigger_indices [ this_i ], indices [ this_i ]): neigh_coo = self . upper_lattice . bigger_points [ phantom_neigh_i ] if self . pbc else self . upper_lattice . points [ neigh_i ] neigh_type = self . upper_lattice . point_types [ neigh_i ] val = tuu ( this_coo , neigh_coo , this_type , neigh_type ) for o1 in range ( k ): for o2 in range ( k ): builder . add ( offset + this_i * k + o1 , offset + neigh_i * k + o2 , val ) # 3. Inter-layer (Radius Search) u_indices , l_indices , l_coords = self . lower_lattice . get_neighbors_within_radius ( self . upper_lattice . points , inter_layer_radius ) for i in range ( len ( u_indices )): u_idx , l_idx = u_indices [ i ], l_indices [ i ] u_pos , l_pos = self . upper_lattice . points [ u_idx ], l_coords [ i ] u_type , l_type = self . upper_lattice . point_types [ u_idx ], self . lower_lattice . point_types [ l_idx ] # tul: Upper -> Lower hopping val_ul = tul ( u_pos , l_pos , u_type , l_type ) # tlu: Lower -> Upper hopping (assuming Hermiticity if not provided) val_lu = tlu ( l_pos , u_pos , l_type , u_type ) for o1 in range ( k ): for o2 in range ( k ): # Upper row, Lower col (H_ul block) builder . add ( offset + u_idx * k + o1 , l_idx * k + o2 , val_ul ) # Lower row, Upper col (H_lu block) builder . add ( l_idx * k + o1 , offset + u_idx * k + o2 , val_lu ) from scipy.sparse import coo_matrix self . ham = coo_matrix (( builder . data , ( builder . rows , builder . cols )), shape = ( total_dim , total_dim ), dtype = data_type ) return self . ham . tocsc () def generate_k_space_hamiltonian ( self , k : np . ndarray , tll : Union [ float , int , Callable ] = None , tuu : Union [ float , int , Callable ] = None , tlu : Union [ float , int , Callable ] = None , tul : Union [ float , int , Callable ] = None , tuself : Union [ float , int , Callable ] = None , tlself : Union [ float , int , Callable ] = None , inter_layer_radius : float = 3.0 , suppress_nxny_warning : bool = False , suppress_pbc_warning : bool = False , ): if not suppress_nxny_warning and ( self . n1 != 1 or self . n2 != 1 ): print ( \"WARNING: n1 or n2 != 1. Momentum space is usually for n1=n2=1. Aborting mission. set suppress_nxny_warning=True to override this check.\" ) return if not suppress_pbc_warning and not self . pbc : print ( \"WARNING: k-space generation is only physically meaningful with pbc=True. Aborting mission. set suppress_pbc_warning=True to override this check.\" ) return # Validate and convert inputs to callables tll , tuu , tlu , tul , tuself , tlself = self . _validate_hamiltonian_inputs ( tll , tuu , tlu , tul , tuself , tlself ) # Bloch phase factor helper def part ( this_coo , neigh_coo ): return np . exp ( 1 j * ( k @ ( this_coo . squeeze () - neigh_coo . squeeze ()))) return self . generate_hamiltonian ( tll = lambda c1 , c2 , t1 , t2 : tll ( c1 , c2 , t1 , t2 ) * part ( c1 , c2 ), tuu = lambda c1 , c2 , t1 , t2 : tuu ( c1 , c2 , t1 , t2 ) * part ( c1 , c2 ), tlu = lambda c1 , c2 , t1 , t2 : tlu ( c1 , c2 , t1 , t2 ) * part ( c1 , c2 ), tul = lambda c1 , c2 , t1 , t2 : tul ( c1 , c2 , t1 , t2 ) * part ( c1 , c2 ), tuself = tuself , tlself = tlself , inter_layer_radius = inter_layer_radius , data_type = np . complex128 ) __init__ ( latticetype , ll1 , ll2 , ul1 , ul2 , n1 = 1 , n2 = 1 , translate_upper = ( 0 , 0 ), pbc = True , k = 1 , verbose = True ) Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Parameters: latticetype ( Layer ) \u2013 A subclass of the Layer class representing the lattice type used for both layers. ll1, ll2, ul1, ul2 ( int ) \u2013 Values select from the AVC tool . n1 ( int , default: 1 ) \u2013 Number of moir\u00e9 cells along the first lattice vector. n2 ( int , default: 1 ) \u2013 Number of moir\u00e9 cells along the second lattice vector. translate_upper ( tuple , default: (0, 0) ) \u2013 Translation vector (dx, dy) applied to the upper layer before rotation. pbc ( bool , default: True ) \u2013 Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k ( int , default: 1 ) \u2013 Number of orbitals on each lattice point. Source code in moirepy/moire.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def __init__ ( self , latticetype : Layer , ll1 : int , ll2 : int , # lower lattice ul1 : int , ul2 : int , # upper lattice n1 : int = 1 , n2 : int = 1 , translate_upper = ( 0 , 0 ), pbc : bool = True , k : int = 1 , # number of orbitals verbose = True , ): \"\"\" Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Args: latticetype (Layer): A subclass of the `Layer` class representing the lattice type used for both layers. ll1, ll2, ul1, ul2 (int): Values select from the [AVC tool](https://jabed-umar.github.io/MoirePy/theory/avc/). n1 (int, optional): Number of moir\u00e9 cells along the first lattice vector. n2 (int, optional): Number of moir\u00e9 cells along the second lattice vector. translate_upper (tuple, optional): Translation vector (dx, dy) applied to the upper layer before rotation. pbc (bool, optional): Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k (int, optional): Number of orbitals on each lattice point. \"\"\" # study_proximity = 1 means only studying nearest neighbours will be enabled, # 2 means study of next nearest neighbours will be enabled too and so on, # always better to keep this value 1 or two more than what you will actually need. lower_lattice = latticetype ( pbc = pbc ) upper_lattice = latticetype ( pbc = pbc ) lv1 , lv2 = lower_lattice . lv1 , lower_lattice . lv2 # c = cos(theta) between lv1 and lv2 (60 degree for triangular, 90 for square and so on) c = np . dot ( lv1 , lv2 ) / ( np . linalg . norm ( lv1 ) * np . linalg . norm ( lv2 )) beta = np . arccos ( c ) mlv1 = ll1 * lv1 + ll2 * lv2 # because lower latice is fixed mlv2 = get_rotation_matrix ( beta ) . dot ( mlv1 ) # calculating the moire twist angle one = ll1 * lv1 + ll2 * lv2 # the coords of overlapping point in the lower lattice two = ul1 * lv1 + ul2 * lv2 # the coords of overlapping point in the upper lattice assert np . isclose ( np . linalg . norm ( one ), np . linalg . norm ( two )), \"INPUT ERROR: the two points are not overlapping, check ll1, ll2, ul1, ul2 values\" c = np . dot ( one , two ) / ( np . linalg . norm ( one ) * np . linalg . norm ( two )) theta = np . arccos ( c ) # in radians if verbose : print ( f \"twist angle = { theta : .4f } rad ( { np . rad2deg ( theta ) : .4f } deg)\" ) upper_lattice . perform_rotation_translation ( theta , translate_upper ) assert ( are_coeffs_integers ( lower_lattice . lv1 , lower_lattice . lv2 , mlv1 ) and are_coeffs_integers ( upper_lattice . lv1 , upper_lattice . lv2 , mlv1 ) ), \"FATAL ERROR: calculated mlv2 is incorrect\" lower_lattice . generate_points ( mlv1 , mlv2 , n1 , n2 ) upper_lattice . generate_points ( mlv1 , mlv2 , n1 , n2 ) # print(f\"{mlv1 = }\") # print(f\"{mlv2 = }\") self . ll1 = ll1 self . ll2 = ll2 self . ul1 = ul1 self . ul2 = ul2 self . n1 = n1 self . n2 = n2 self . translate_upper = translate_upper self . lower_lattice = lower_lattice self . upper_lattice = upper_lattice self . theta = theta self . mlv1 = mlv1 self . mlv2 = mlv2 self . pbc = pbc self . orbitals = k self . ham = None if verbose : print ( f \" { len ( self . upper_lattice . points ) } cells in upper lattice\" ) print ( f \" { len ( self . lower_lattice . points ) } cells in lower lattice\" ) assert len ( self . lower_lattice . points ) == len ( self . upper_lattice . points ), \"FATAL ERROR: number of cells in lower and upper lattice are not equal, report and take different ll1, ll2, ul1, ul2 values\"","title":"Moire"},{"location":"api/moire/#moirepy.moire.BilayerMoireLattice","text":"Source code in moirepy/moire.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 class BilayerMoireLattice : # both layers same, only one point in one unit cell def __init__ ( self , latticetype : Layer , ll1 : int , ll2 : int , # lower lattice ul1 : int , ul2 : int , # upper lattice n1 : int = 1 , n2 : int = 1 , translate_upper = ( 0 , 0 ), pbc : bool = True , k : int = 1 , # number of orbitals verbose = True , ): \"\"\" Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Args: latticetype (Layer): A subclass of the `Layer` class representing the lattice type used for both layers. ll1, ll2, ul1, ul2 (int): Values select from the [AVC tool](https://jabed-umar.github.io/MoirePy/theory/avc/). n1 (int, optional): Number of moir\u00e9 cells along the first lattice vector. n2 (int, optional): Number of moir\u00e9 cells along the second lattice vector. translate_upper (tuple, optional): Translation vector (dx, dy) applied to the upper layer before rotation. pbc (bool, optional): Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k (int, optional): Number of orbitals on each lattice point. \"\"\" # study_proximity = 1 means only studying nearest neighbours will be enabled, # 2 means study of next nearest neighbours will be enabled too and so on, # always better to keep this value 1 or two more than what you will actually need. lower_lattice = latticetype ( pbc = pbc ) upper_lattice = latticetype ( pbc = pbc ) lv1 , lv2 = lower_lattice . lv1 , lower_lattice . lv2 # c = cos(theta) between lv1 and lv2 (60 degree for triangular, 90 for square and so on) c = np . dot ( lv1 , lv2 ) / ( np . linalg . norm ( lv1 ) * np . linalg . norm ( lv2 )) beta = np . arccos ( c ) mlv1 = ll1 * lv1 + ll2 * lv2 # because lower latice is fixed mlv2 = get_rotation_matrix ( beta ) . dot ( mlv1 ) # calculating the moire twist angle one = ll1 * lv1 + ll2 * lv2 # the coords of overlapping point in the lower lattice two = ul1 * lv1 + ul2 * lv2 # the coords of overlapping point in the upper lattice assert np . isclose ( np . linalg . norm ( one ), np . linalg . norm ( two )), \"INPUT ERROR: the two points are not overlapping, check ll1, ll2, ul1, ul2 values\" c = np . dot ( one , two ) / ( np . linalg . norm ( one ) * np . linalg . norm ( two )) theta = np . arccos ( c ) # in radians if verbose : print ( f \"twist angle = { theta : .4f } rad ( { np . rad2deg ( theta ) : .4f } deg)\" ) upper_lattice . perform_rotation_translation ( theta , translate_upper ) assert ( are_coeffs_integers ( lower_lattice . lv1 , lower_lattice . lv2 , mlv1 ) and are_coeffs_integers ( upper_lattice . lv1 , upper_lattice . lv2 , mlv1 ) ), \"FATAL ERROR: calculated mlv2 is incorrect\" lower_lattice . generate_points ( mlv1 , mlv2 , n1 , n2 ) upper_lattice . generate_points ( mlv1 , mlv2 , n1 , n2 ) # print(f\"{mlv1 = }\") # print(f\"{mlv2 = }\") self . ll1 = ll1 self . ll2 = ll2 self . ul1 = ul1 self . ul2 = ul2 self . n1 = n1 self . n2 = n2 self . translate_upper = translate_upper self . lower_lattice = lower_lattice self . upper_lattice = upper_lattice self . theta = theta self . mlv1 = mlv1 self . mlv2 = mlv2 self . pbc = pbc self . orbitals = k self . ham = None if verbose : print ( f \" { len ( self . upper_lattice . points ) } cells in upper lattice\" ) print ( f \" { len ( self . lower_lattice . points ) } cells in lower lattice\" ) assert len ( self . lower_lattice . points ) == len ( self . upper_lattice . points ), \"FATAL ERROR: number of cells in lower and upper lattice are not equal, report and take different ll1, ll2, ul1, ul2 values\" # self.plot_lattice() def plot_lattice ( self ): mlv1 = self . mlv1 mlv2 = self . mlv2 n1 = self . n1 n2 = self . n2 plt . plot ( * zip ( * self . lower_lattice . points ), 'r.' , markersize = 2 ) plt . plot ( * zip ( * self . upper_lattice . points ), 'b.' , markersize = 2 ) self . lower_lattice . plot_lattice ( colours = [ \"b\" ], plot_connections = True ) self . upper_lattice . plot_lattice ( colours = [ \"r\" ], plot_connections = True ) # parallellogram around the whole lattice plt . plot ([ 0 , n1 * mlv1 [ 0 ]], [ 0 , n1 * mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , n2 * mlv2 [ 0 ]], [ 0 , n2 * mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ n1 * mlv1 [ 0 ], n1 * mlv1 [ 0 ] + n2 * mlv2 [ 0 ]], [ n1 * mlv1 [ 1 ], n1 * mlv1 [ 1 ] + n2 * mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ n2 * mlv2 [ 0 ], n1 * mlv1 [ 0 ] + n2 * mlv2 [ 0 ]], [ n2 * mlv2 [ 1 ], n1 * mlv1 [ 1 ] + n2 * mlv2 [ 1 ]], 'k' , linewidth = 1 ) # just plot mlv1 and mlv2 parallellogram plt . plot ([ 0 , mlv1 [ 0 ]], [ 0 , mlv1 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ 0 , mlv2 [ 0 ]], [ 0 , mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ mlv1 [ 0 ], mlv1 [ 0 ] + mlv2 [ 0 ]], [ mlv1 [ 1 ], mlv1 [ 1 ] + mlv2 [ 1 ]], 'k' , linewidth = 1 ) plt . plot ([ mlv2 [ 0 ], mlv1 [ 0 ] + mlv2 [ 0 ]], [ mlv2 [ 1 ], mlv1 [ 1 ] + mlv2 [ 1 ]], 'k' , linewidth = 1 ) # set equal aspect ratio plt . gca () . set_aspect ( 'equal' , adjustable = 'box' ) # plt.grid() # plt.show() # plt.savefig(\"moire.pdf\", bbox_inches='tight') def _as_callable ( self , val , n_args = 4 ): if callable ( val ): return val if n_args == 4 : return lambda c1 , c2 , t1 , t2 : val if val is not None else 0 return lambda c , t : val if val is not None else 0 def _validate_hamiltonian_inputs ( self , tll , tuu , tlu , tul , tuself , tlself ): \"\"\"Helper to ensure all hopping terms are callable.\"\"\" tll , tuu , tlu , tul = [ self . _as_callable ( t , 4 ) for t in ( tll , tuu , tlu , tul )] tuself , tlself = [ self . _as_callable ( t , 2 ) for t in ( tuself , tlself )] assert all ( callable ( fn ) for fn in ( tll , tuu , tlu , tul , tuself , tlself ) ), \"Hopping parameters must be floats, ints, or callable functions.\" return tll , tuu , tlu , tul , tuself , tlself def generate_hamiltonian ( self , tll : Union [ float , int , Callable ] = None , tuu : Union [ float , int , Callable ] = None , tlu : Union [ float , int , Callable ] = None , tul : Union [ float , int , Callable ] = None , tuself : Union [ float , int , Callable ] = None , tlself : Union [ float , int , Callable ] = None , inter_layer_radius : float = 3.0 , data_type : np . dtype = np . float64 , ): k = self . orbitals n_lower = len ( self . lower_lattice . points ) n_upper = len ( self . upper_lattice . points ) total_dim = ( n_lower + n_upper ) * k tll , tuu , tlu , tul , tuself , tlself = self . _validate_hamiltonian_inputs ( tll , tuu , tlu , tul , tuself , tlself ) builder = COOBuilder () # 1. Lower Lattice Intra-layer (Indices: 0 to n_lower*k - 1) for i in range ( n_lower ): val = tlself ( self . lower_lattice . points [ i ], self . lower_lattice . point_types [ i ]) for o in range ( k ): builder . add ( i * k + o , i * k + o , val ) bigger_indices , indices , _ = self . lower_lattice . first_nearest_neighbours ( self . lower_lattice . points , self . lower_lattice . point_types ) for this_i in range ( n_lower ): this_coo , this_type = self . lower_lattice . points [ this_i ], self . lower_lattice . point_types [ this_i ] for phantom_neigh_i , neigh_i in zip ( bigger_indices [ this_i ], indices [ this_i ]): neigh_coo = self . lower_lattice . bigger_points [ phantom_neigh_i ] if self . pbc else self . lower_lattice . points [ neigh_i ] neigh_type = self . lower_lattice . point_types [ neigh_i ] val = tll ( this_coo , neigh_coo , this_type , neigh_type ) for o1 in range ( k ): for o2 in range ( k ): builder . add ( this_i * k + o1 , neigh_i * k + o2 , val ) # 2. Upper Lattice Intra-layer (Indices: n_lower*k to total_dim - 1) offset = n_lower * k for i in range ( n_upper ): val = tuself ( self . upper_lattice . points [ i ], self . upper_lattice . point_types [ i ]) for o in range ( k ): builder . add ( offset + i * k + o , offset + i * k + o , val ) bigger_indices , indices , _ = self . upper_lattice . first_nearest_neighbours ( self . upper_lattice . points , self . upper_lattice . point_types ) for this_i in range ( n_upper ): this_coo , this_type = self . upper_lattice . points [ this_i ], self . upper_lattice . point_types [ this_i ] for phantom_neigh_i , neigh_i in zip ( bigger_indices [ this_i ], indices [ this_i ]): neigh_coo = self . upper_lattice . bigger_points [ phantom_neigh_i ] if self . pbc else self . upper_lattice . points [ neigh_i ] neigh_type = self . upper_lattice . point_types [ neigh_i ] val = tuu ( this_coo , neigh_coo , this_type , neigh_type ) for o1 in range ( k ): for o2 in range ( k ): builder . add ( offset + this_i * k + o1 , offset + neigh_i * k + o2 , val ) # 3. Inter-layer (Radius Search) u_indices , l_indices , l_coords = self . lower_lattice . get_neighbors_within_radius ( self . upper_lattice . points , inter_layer_radius ) for i in range ( len ( u_indices )): u_idx , l_idx = u_indices [ i ], l_indices [ i ] u_pos , l_pos = self . upper_lattice . points [ u_idx ], l_coords [ i ] u_type , l_type = self . upper_lattice . point_types [ u_idx ], self . lower_lattice . point_types [ l_idx ] # tul: Upper -> Lower hopping val_ul = tul ( u_pos , l_pos , u_type , l_type ) # tlu: Lower -> Upper hopping (assuming Hermiticity if not provided) val_lu = tlu ( l_pos , u_pos , l_type , u_type ) for o1 in range ( k ): for o2 in range ( k ): # Upper row, Lower col (H_ul block) builder . add ( offset + u_idx * k + o1 , l_idx * k + o2 , val_ul ) # Lower row, Upper col (H_lu block) builder . add ( l_idx * k + o1 , offset + u_idx * k + o2 , val_lu ) from scipy.sparse import coo_matrix self . ham = coo_matrix (( builder . data , ( builder . rows , builder . cols )), shape = ( total_dim , total_dim ), dtype = data_type ) return self . ham . tocsc () def generate_k_space_hamiltonian ( self , k : np . ndarray , tll : Union [ float , int , Callable ] = None , tuu : Union [ float , int , Callable ] = None , tlu : Union [ float , int , Callable ] = None , tul : Union [ float , int , Callable ] = None , tuself : Union [ float , int , Callable ] = None , tlself : Union [ float , int , Callable ] = None , inter_layer_radius : float = 3.0 , suppress_nxny_warning : bool = False , suppress_pbc_warning : bool = False , ): if not suppress_nxny_warning and ( self . n1 != 1 or self . n2 != 1 ): print ( \"WARNING: n1 or n2 != 1. Momentum space is usually for n1=n2=1. Aborting mission. set suppress_nxny_warning=True to override this check.\" ) return if not suppress_pbc_warning and not self . pbc : print ( \"WARNING: k-space generation is only physically meaningful with pbc=True. Aborting mission. set suppress_pbc_warning=True to override this check.\" ) return # Validate and convert inputs to callables tll , tuu , tlu , tul , tuself , tlself = self . _validate_hamiltonian_inputs ( tll , tuu , tlu , tul , tuself , tlself ) # Bloch phase factor helper def part ( this_coo , neigh_coo ): return np . exp ( 1 j * ( k @ ( this_coo . squeeze () - neigh_coo . squeeze ()))) return self . generate_hamiltonian ( tll = lambda c1 , c2 , t1 , t2 : tll ( c1 , c2 , t1 , t2 ) * part ( c1 , c2 ), tuu = lambda c1 , c2 , t1 , t2 : tuu ( c1 , c2 , t1 , t2 ) * part ( c1 , c2 ), tlu = lambda c1 , c2 , t1 , t2 : tlu ( c1 , c2 , t1 , t2 ) * part ( c1 , c2 ), tul = lambda c1 , c2 , t1 , t2 : tul ( c1 , c2 , t1 , t2 ) * part ( c1 , c2 ), tuself = tuself , tlself = tlself , inter_layer_radius = inter_layer_radius , data_type = np . complex128 )","title":"BilayerMoireLattice"},{"location":"api/moire/#moirepy.moire.BilayerMoireLattice.__init__","text":"Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Parameters: latticetype ( Layer ) \u2013 A subclass of the Layer class representing the lattice type used for both layers. ll1, ll2, ul1, ul2 ( int ) \u2013 Values select from the AVC tool . n1 ( int , default: 1 ) \u2013 Number of moir\u00e9 cells along the first lattice vector. n2 ( int , default: 1 ) \u2013 Number of moir\u00e9 cells along the second lattice vector. translate_upper ( tuple , default: (0, 0) ) \u2013 Translation vector (dx, dy) applied to the upper layer before rotation. pbc ( bool , default: True ) \u2013 Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k ( int , default: 1 ) \u2013 Number of orbitals on each lattice point. Source code in moirepy/moire.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def __init__ ( self , latticetype : Layer , ll1 : int , ll2 : int , # lower lattice ul1 : int , ul2 : int , # upper lattice n1 : int = 1 , n2 : int = 1 , translate_upper = ( 0 , 0 ), pbc : bool = True , k : int = 1 , # number of orbitals verbose = True , ): \"\"\" Initializes a Moir\u00e9 lattice composed of two twisted layers of the same type. Args: latticetype (Layer): A subclass of the `Layer` class representing the lattice type used for both layers. ll1, ll2, ul1, ul2 (int): Values select from the [AVC tool](https://jabed-umar.github.io/MoirePy/theory/avc/). n1 (int, optional): Number of moir\u00e9 cells along the first lattice vector. n2 (int, optional): Number of moir\u00e9 cells along the second lattice vector. translate_upper (tuple, optional): Translation vector (dx, dy) applied to the upper layer before rotation. pbc (bool, optional): Whether to apply periodic boundary conditions. If False, open boundary conditions are used. k (int, optional): Number of orbitals on each lattice point. \"\"\" # study_proximity = 1 means only studying nearest neighbours will be enabled, # 2 means study of next nearest neighbours will be enabled too and so on, # always better to keep this value 1 or two more than what you will actually need. lower_lattice = latticetype ( pbc = pbc ) upper_lattice = latticetype ( pbc = pbc ) lv1 , lv2 = lower_lattice . lv1 , lower_lattice . lv2 # c = cos(theta) between lv1 and lv2 (60 degree for triangular, 90 for square and so on) c = np . dot ( lv1 , lv2 ) / ( np . linalg . norm ( lv1 ) * np . linalg . norm ( lv2 )) beta = np . arccos ( c ) mlv1 = ll1 * lv1 + ll2 * lv2 # because lower latice is fixed mlv2 = get_rotation_matrix ( beta ) . dot ( mlv1 ) # calculating the moire twist angle one = ll1 * lv1 + ll2 * lv2 # the coords of overlapping point in the lower lattice two = ul1 * lv1 + ul2 * lv2 # the coords of overlapping point in the upper lattice assert np . isclose ( np . linalg . norm ( one ), np . linalg . norm ( two )), \"INPUT ERROR: the two points are not overlapping, check ll1, ll2, ul1, ul2 values\" c = np . dot ( one , two ) / ( np . linalg . norm ( one ) * np . linalg . norm ( two )) theta = np . arccos ( c ) # in radians if verbose : print ( f \"twist angle = { theta : .4f } rad ( { np . rad2deg ( theta ) : .4f } deg)\" ) upper_lattice . perform_rotation_translation ( theta , translate_upper ) assert ( are_coeffs_integers ( lower_lattice . lv1 , lower_lattice . lv2 , mlv1 ) and are_coeffs_integers ( upper_lattice . lv1 , upper_lattice . lv2 , mlv1 ) ), \"FATAL ERROR: calculated mlv2 is incorrect\" lower_lattice . generate_points ( mlv1 , mlv2 , n1 , n2 ) upper_lattice . generate_points ( mlv1 , mlv2 , n1 , n2 ) # print(f\"{mlv1 = }\") # print(f\"{mlv2 = }\") self . ll1 = ll1 self . ll2 = ll2 self . ul1 = ul1 self . ul2 = ul2 self . n1 = n1 self . n2 = n2 self . translate_upper = translate_upper self . lower_lattice = lower_lattice self . upper_lattice = upper_lattice self . theta = theta self . mlv1 = mlv1 self . mlv2 = mlv2 self . pbc = pbc self . orbitals = k self . ham = None if verbose : print ( f \" { len ( self . upper_lattice . points ) } cells in upper lattice\" ) print ( f \" { len ( self . lower_lattice . points ) } cells in lower lattice\" ) assert len ( self . lower_lattice . points ) == len ( self . upper_lattice . points ), \"FATAL ERROR: number of cells in lower and upper lattice are not equal, report and take different ll1, ll2, ul1, ul2 values\"","title":"__init__"},{"location":"api/utils/","text":"are_coeffs_integers ( v1 , v2 , v3 , tol = 1e-08 ) Solves a v1 + b v2 = v3 for scalars a and b using Cramer's Rule, and checks if both are integers (within a tolerance). v1, v2, v3 are lists or tuples or np arrays of length 2 Source code in moirepy/utils.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def are_coeffs_integers ( v1 , v2 , v3 , tol = 1e-8 ): \"\"\" Solves a v1 + b v2 = v3 for scalars a and b using Cramer's Rule, and checks if both are integers (within a tolerance). v1, v2, v3 are lists or tuples or np arrays of length 2 \"\"\" a1 , a2 = v1 b1 , b2 = v2 c1 , c2 = v3 det = a1 * b2 - a2 * b1 if abs ( det ) < tol : return False # no unique solution a = ( c1 * b2 - c2 * b1 ) / det b = ( a1 * c2 - a2 * c1 ) / det ret = abs ( a - round ( a )) < tol and abs ( b - round ( b )) < tol return ret get_rotation_matrix ( theta_rad ) Computes a 2D rotation matrix for a given angle. Parameters: theta_rad ( float ) \u2013 The rotation angle in radians. Returns: ndarray \u2013 np.ndarray: A 2x2 rotation matrix that rotates a point counterclockwise by theta_rad . >>> get_rotation_matrix ( np . pi / 2 ) array ([[ 6.123234e-17 , - 1.000000e+00 ], [ 1.000000e+00 , 6.123234e-17 ]]) Source code in moirepy/utils.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def get_rotation_matrix ( theta_rad : float ) -> np . ndarray : \"\"\" Computes a 2D rotation matrix for a given angle. Args: theta_rad (float): The rotation angle in radians. Returns: np.ndarray: A 2x2 rotation matrix that rotates a point counterclockwise by `theta_rad`. ```python >>> get_rotation_matrix(np.pi/2) array([[ 6.123234e-17, -1.000000e+00], [ 1.000000e+00, 6.123234e-17]]) ``` \"\"\" return np . array ( [ [ np . cos ( theta_rad ), - np . sin ( theta_rad )], [ np . sin ( theta_rad ), np . cos ( theta_rad )] ] )","title":"Utils"},{"location":"api/utils/#moirepy.utils.are_coeffs_integers","text":"Solves a v1 + b v2 = v3 for scalars a and b using Cramer's Rule, and checks if both are integers (within a tolerance). v1, v2, v3 are lists or tuples or np arrays of length 2 Source code in moirepy/utils.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def are_coeffs_integers ( v1 , v2 , v3 , tol = 1e-8 ): \"\"\" Solves a v1 + b v2 = v3 for scalars a and b using Cramer's Rule, and checks if both are integers (within a tolerance). v1, v2, v3 are lists or tuples or np arrays of length 2 \"\"\" a1 , a2 = v1 b1 , b2 = v2 c1 , c2 = v3 det = a1 * b2 - a2 * b1 if abs ( det ) < tol : return False # no unique solution a = ( c1 * b2 - c2 * b1 ) / det b = ( a1 * c2 - a2 * c1 ) / det ret = abs ( a - round ( a )) < tol and abs ( b - round ( b )) < tol return ret","title":"are_coeffs_integers"},{"location":"api/utils/#moirepy.utils.get_rotation_matrix","text":"Computes a 2D rotation matrix for a given angle. Parameters: theta_rad ( float ) \u2013 The rotation angle in radians. Returns: ndarray \u2013 np.ndarray: A 2x2 rotation matrix that rotates a point counterclockwise by theta_rad . >>> get_rotation_matrix ( np . pi / 2 ) array ([[ 6.123234e-17 , - 1.000000e+00 ], [ 1.000000e+00 , 6.123234e-17 ]]) Source code in moirepy/utils.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def get_rotation_matrix ( theta_rad : float ) -> np . ndarray : \"\"\" Computes a 2D rotation matrix for a given angle. Args: theta_rad (float): The rotation angle in radians. Returns: np.ndarray: A 2x2 rotation matrix that rotates a point counterclockwise by `theta_rad`. ```python >>> get_rotation_matrix(np.pi/2) array([[ 6.123234e-17, -1.000000e+00], [ 1.000000e+00, 6.123234e-17]]) ``` \"\"\" return np . array ( [ [ np . cos ( theta_rad ), - np . sin ( theta_rad )], [ np . sin ( theta_rad ), np . cos ( theta_rad )] ] )","title":"get_rotation_matrix"},{"location":"getting_started/custom_hoppings/","text":"","title":"Designing Custom Hopping"},{"location":"getting_started/k_space_hamiltonian/","text":"K-Space Hamiltonian and Band Structure In this section, we will see how to generate the k-space Hamiltonian for a moir\u00e9 system and compute its band structure. This is essential for understanding the electronic properties of the system, such as the presence of flat bands or Dirac cones. 1. Recap and Setup To work in k-space, Periodic Boundary Conditions ( pbc=True ) are strictly required . Momentum is only a well-defined quantum number in a periodic system; without PBC, there is no Brillouin Zone to sample. import numpy as np import matplotlib.pyplot as plt from moirepy import BilayerMoireLattice , HexagonalLayer lattice = BilayerMoireLattice ( latticetype = HexagonalLayer , ll1 = 3 , ll2 = 4 , ul1 = 4 , ul2 = 3 , n1 = 1 , n2 = 1 , pbc = True # Mandatory for k-space ) 2. Single k-point Generation A k-space Hamiltonian represents the system's energy at a specific crystal momentum. Note that these matrices are complex-valued even if your hopping parameters are real numbers. k = np . array ([ 0.1 , 0.2 ]) # Matrices are smaller but complex: we use complex128 internally Hk = lattice . generate_k_space_hamiltonian ( k = k , tll = 1.0 , tuu = 1.0 , tul = 0.1 , tlu = 0.1 , # User must ensure tlu = conj(tul) for Hermiticity ) print ( f \"Matrix shape: { Hk . shape } \" ) Manual Hermiticity MoirePy gives you raw control over the hopping directions. To maintain a physical, Hermitian Hamiltonian, you must ensure your tlu (Lower to Upper) values are the complex conjugates of your tul (Upper to Lower) terms. 3. Band Structure Calculation (The Physics Payoff) The primary use of k-space is to visualize how energy levels evolve across the Moir\u00e9 Brillouin Zone (MBZ) . Step 1: Define the Path We sample the zone by interpolating between High-Symmetry points (). # Defined using the reciprocal lattice vectors of the moire system G = np . array ([ 0 , 0 ]) K = ( 1 / 3 ) * ( lattice . mlv1 + lattice . mlv2 ) M = ( 1 / 2 ) * lattice . mlv1 def get_path ( points , steps = 50 ): path = [] for i in range ( len ( points ) - 1 ): for t in np . linspace ( 0 , 1 , steps ): path . append ( points [ i ] * ( 1 - t ) + points [ i + 1 ] * t ) return np . array ( path ) k_path = get_path ([ G , K , M , G ]) Step 2: Iterative Solver Since k-space Hamiltonians represent a single unit cell, they are much smaller than real-space matrices. We can use dense solvers like np.linalg.eigvalsh for high precision. bands = [] for k in k_path : Hk = lattice . generate_k_space_hamiltonian ( k = k , tll = 1.0 , tuu = 1.0 , tul = 0.1 , tlu = 0.1 ) # Convert sparse k-matrix to dense for the eigensolver eigvals = np . linalg . eigvalsh ( Hk . toarray ()) bands . append ( eigvals ) bands = np . array ( bands ) Step 3: Visualization plt . figure ( figsize = ( 6 , 8 )) plt . plot ( bands , color = 'black' , linewidth = 1 ) # Mark the high-symmetry transitions plt . axvline ( x = 50 , linestyle = '--' , color = 'gray' , alpha = 0.5 ) plt . axvline ( x = 100 , linestyle = '--' , color = 'gray' , alpha = 0.5 ) plt . xticks ([ 0 , 50 , 100 , 150 ], [ r '$\\Gamma$' , 'K' , 'M' , r '$\\Gamma$' ]) plt . ylabel ( \"Energy (t)\" ) plt . title ( \"Moir\u00e9 Band Structure\" ) plt . grid ( axis = 'y' , alpha = 0.3 ) plt . show () Note Using constant hopping ( \\(t=1\\) ) over a large supercell results in a dense, folded band structure. To see the isolated flat bands characteristic of the Magic Angle, refer to the Replicated Papers section where we implement distance-dependent (exponential) hopping. Summary We constructed the k-space Hamiltonian from the same lattice definition We sampled momentum space along a high-symmetry path We computed and visualized the band structure This is the standard workflow for studying electronic structure in periodic moir\u00e9 systems. Next Steps OBC vs PBC : Understand how boundary conditions affect the Hamiltonian. Defining Custom Layers : Go beyond built-in lattices. Designing Custom Hopping : Introduce realistic physics. Tutorials and Replicated Papers : See full physical results.","title":"K-Space Hamiltonian Generation"},{"location":"getting_started/k_space_hamiltonian/#k-space-hamiltonian-and-band-structure","text":"In this section, we will see how to generate the k-space Hamiltonian for a moir\u00e9 system and compute its band structure. This is essential for understanding the electronic properties of the system, such as the presence of flat bands or Dirac cones.","title":"K-Space Hamiltonian and Band Structure"},{"location":"getting_started/k_space_hamiltonian/#1-recap-and-setup","text":"To work in k-space, Periodic Boundary Conditions ( pbc=True ) are strictly required . Momentum is only a well-defined quantum number in a periodic system; without PBC, there is no Brillouin Zone to sample. import numpy as np import matplotlib.pyplot as plt from moirepy import BilayerMoireLattice , HexagonalLayer lattice = BilayerMoireLattice ( latticetype = HexagonalLayer , ll1 = 3 , ll2 = 4 , ul1 = 4 , ul2 = 3 , n1 = 1 , n2 = 1 , pbc = True # Mandatory for k-space )","title":"1. Recap and Setup"},{"location":"getting_started/k_space_hamiltonian/#2-single-k-point-generation","text":"A k-space Hamiltonian represents the system's energy at a specific crystal momentum. Note that these matrices are complex-valued even if your hopping parameters are real numbers. k = np . array ([ 0.1 , 0.2 ]) # Matrices are smaller but complex: we use complex128 internally Hk = lattice . generate_k_space_hamiltonian ( k = k , tll = 1.0 , tuu = 1.0 , tul = 0.1 , tlu = 0.1 , # User must ensure tlu = conj(tul) for Hermiticity ) print ( f \"Matrix shape: { Hk . shape } \" ) Manual Hermiticity MoirePy gives you raw control over the hopping directions. To maintain a physical, Hermitian Hamiltonian, you must ensure your tlu (Lower to Upper) values are the complex conjugates of your tul (Upper to Lower) terms.","title":"2. Single k-point Generation"},{"location":"getting_started/k_space_hamiltonian/#3-band-structure-calculation-the-physics-payoff","text":"The primary use of k-space is to visualize how energy levels evolve across the Moir\u00e9 Brillouin Zone (MBZ) .","title":"3. Band Structure Calculation (The Physics Payoff)"},{"location":"getting_started/k_space_hamiltonian/#step-1-define-the-path","text":"We sample the zone by interpolating between High-Symmetry points (). # Defined using the reciprocal lattice vectors of the moire system G = np . array ([ 0 , 0 ]) K = ( 1 / 3 ) * ( lattice . mlv1 + lattice . mlv2 ) M = ( 1 / 2 ) * lattice . mlv1 def get_path ( points , steps = 50 ): path = [] for i in range ( len ( points ) - 1 ): for t in np . linspace ( 0 , 1 , steps ): path . append ( points [ i ] * ( 1 - t ) + points [ i + 1 ] * t ) return np . array ( path ) k_path = get_path ([ G , K , M , G ])","title":"Step 1: Define the Path"},{"location":"getting_started/k_space_hamiltonian/#step-2-iterative-solver","text":"Since k-space Hamiltonians represent a single unit cell, they are much smaller than real-space matrices. We can use dense solvers like np.linalg.eigvalsh for high precision. bands = [] for k in k_path : Hk = lattice . generate_k_space_hamiltonian ( k = k , tll = 1.0 , tuu = 1.0 , tul = 0.1 , tlu = 0.1 ) # Convert sparse k-matrix to dense for the eigensolver eigvals = np . linalg . eigvalsh ( Hk . toarray ()) bands . append ( eigvals ) bands = np . array ( bands )","title":"Step 2: Iterative Solver"},{"location":"getting_started/k_space_hamiltonian/#step-3-visualization","text":"plt . figure ( figsize = ( 6 , 8 )) plt . plot ( bands , color = 'black' , linewidth = 1 ) # Mark the high-symmetry transitions plt . axvline ( x = 50 , linestyle = '--' , color = 'gray' , alpha = 0.5 ) plt . axvline ( x = 100 , linestyle = '--' , color = 'gray' , alpha = 0.5 ) plt . xticks ([ 0 , 50 , 100 , 150 ], [ r '$\\Gamma$' , 'K' , 'M' , r '$\\Gamma$' ]) plt . ylabel ( \"Energy (t)\" ) plt . title ( \"Moir\u00e9 Band Structure\" ) plt . grid ( axis = 'y' , alpha = 0.3 ) plt . show () Note Using constant hopping ( \\(t=1\\) ) over a large supercell results in a dense, folded band structure. To see the isolated flat bands characteristic of the Magic Angle, refer to the Replicated Papers section where we implement distance-dependent (exponential) hopping.","title":"Step 3: Visualization"},{"location":"getting_started/k_space_hamiltonian/#summary","text":"We constructed the k-space Hamiltonian from the same lattice definition We sampled momentum space along a high-symmetry path We computed and visualized the band structure This is the standard workflow for studying electronic structure in periodic moir\u00e9 systems.","title":"Summary"},{"location":"getting_started/k_space_hamiltonian/#next-steps","text":"OBC vs PBC : Understand how boundary conditions affect the Hamiltonian. Defining Custom Layers : Go beyond built-in lattices. Designing Custom Hopping : Introduce realistic physics. Tutorials and Replicated Papers : See full physical results.","title":"Next Steps"},{"location":"getting_started/obc_vs_pbc/","text":"Simulating Lattices: OBC vs. PBC In this section, you will learn how to simulate both Periodic Boundary Conditions (PBC) and Open Boundary Conditions (OBC) using MoirePy. Understanding the transition between these two is vital for distinguishing between bulk properties and edge-specific phenomena. 1. Physical Difference: Bulk vs. Flake PBC ( pbc=True ) : Represents an infinite periodic system . Atoms at the boundary \"wrap around\" to connect with atoms on the opposite side of the moir\u00e9 unit cell, simulating an endless bulk material. OBC ( pbc=False ) : Represents a finite flake or nanostructure . Atoms at the boundaries have fewer neighbors because the lattice physically ends, creating edges. 2. Minimal Setup We define the same lattice geometry once, toggling only the pbc flag to see how it changes the connectivity. import numpy as np import matplotlib.pyplot as plt from moirepy import BilayerMoireLattice , HexagonalLayer # Parameters for a ~9.43 degree twist params = { \"latticetype\" : HexagonalLayer , \"ll1\" : 3 , \"ll2\" : 4 , \"ul1\" : 4 , \"ul2\" : 3 , \"n1\" : 1 , \"n2\" : 1 } # yes, u can do this in python # 1. Open Boundary Conditions (Finite Flake) lattice_obc = BilayerMoireLattice ( ** params , pbc = False ) # 2. Periodic Boundary Conditions (Infinite Bulk) lattice_pbc = BilayerMoireLattice ( ** params , pbc = True ) 3. Hamiltonian and Connectivity The internal logic for finding neighbors changes significantly. In PBC, MoirePy uses a KDTree on a set of \"ghost\" atoms (bigger lattice) to ensure that atoms near the edge find their counterparts on the other side. # Generate Hamiltonians with identical hopping parameters ham_obc = lattice_obc . generate_hamiltonian ( tll = 1.0 , tuu = 1.0 , tul = 0.1 , tlu = 0.1 ) ham_pbc = lattice_pbc . generate_hamiltonian ( tll = 1.0 , tuu = 1.0 , tul = 0.1 , tlu = 0.1 ) print ( f \"OBC Non-zero entries: { ham_obc . nnz } \" ) # 6062 print ( f \"PBC Non-zero entries: { ham_pbc . nnz } \" ) # 9728 Info In PBC , an atom at the far right edge connects to a neighbor at the far left edge. MoirePy handles this mapping automatically. You don't need to manually calculate wrapped coordinates. This results in a higher number of non-zero entries ( nnz ) in the PBC Hamiltonian. 4. Visual Comparison (Hamiltonian Structure) Let's plot the hamiltonian matrices and let's see how they look like: plt . imshow ( ham_obc . toarray (), cmap = \"gray\" ) plt . imshow ( ham_pbc . toarray (), cmap = \"gray\" ) 5. Spectrum Comparison The choice of boundary conditions significantly affects the energy eigenvalues. OBC introduces \"edge states\" that may appear in gaps where the bulk (PBC) system has no states. from scipy.sparse.linalg import eigsh def get_spectrum ( ham ): # Get 100 eigenvalues near zero energy vals = eigsh ( ham , k = 100 , which = 'LM' , sigma = 0 , return_eigenvectors = False ) return np . sort ( vals ) spec_obc = get_spectrum ( ham_obc ) spec_pbc = get_spectrum ( ham_pbc ) plt . plot ( spec_obc , 'ro' , label = 'OBC (Edges)' , markersize = 4 ) plt . plot ( spec_pbc , 'k.' , label = 'PBC (Bulk)' , markersize = 4 ) plt . legend () plt . ylabel ( \"Energy\" ) plt . title ( \"Spectrum Comparison\" ) plt . show () What We Did Constructed the same lattice with OBC and PBC Observed how connectivity changes at the boundaries Compared Hamiltonians and resulting spectra This demonstrates how boundary conditions control whether you simulate a finite system or an infinite periodic system. Next Steps K-Space & Band Structures : Work in momentum space for periodic systems. Defining Custom Layers : Build your own lattice geometries. Designing Custom Hopping : Add realistic physics. Tutorials and Replicated Papers : See full physical results.","title":"Simulating Lattices in Open vs. Periodic Boundary Conditions"},{"location":"getting_started/obc_vs_pbc/#simulating-lattices-obc-vs-pbc","text":"In this section, you will learn how to simulate both Periodic Boundary Conditions (PBC) and Open Boundary Conditions (OBC) using MoirePy. Understanding the transition between these two is vital for distinguishing between bulk properties and edge-specific phenomena.","title":"Simulating Lattices: OBC vs. PBC"},{"location":"getting_started/obc_vs_pbc/#1-physical-difference-bulk-vs-flake","text":"PBC ( pbc=True ) : Represents an infinite periodic system . Atoms at the boundary \"wrap around\" to connect with atoms on the opposite side of the moir\u00e9 unit cell, simulating an endless bulk material. OBC ( pbc=False ) : Represents a finite flake or nanostructure . Atoms at the boundaries have fewer neighbors because the lattice physically ends, creating edges.","title":"1. Physical Difference: Bulk vs. Flake"},{"location":"getting_started/obc_vs_pbc/#2-minimal-setup","text":"We define the same lattice geometry once, toggling only the pbc flag to see how it changes the connectivity. import numpy as np import matplotlib.pyplot as plt from moirepy import BilayerMoireLattice , HexagonalLayer # Parameters for a ~9.43 degree twist params = { \"latticetype\" : HexagonalLayer , \"ll1\" : 3 , \"ll2\" : 4 , \"ul1\" : 4 , \"ul2\" : 3 , \"n1\" : 1 , \"n2\" : 1 } # yes, u can do this in python # 1. Open Boundary Conditions (Finite Flake) lattice_obc = BilayerMoireLattice ( ** params , pbc = False ) # 2. Periodic Boundary Conditions (Infinite Bulk) lattice_pbc = BilayerMoireLattice ( ** params , pbc = True )","title":"2. Minimal Setup"},{"location":"getting_started/obc_vs_pbc/#3-hamiltonian-and-connectivity","text":"The internal logic for finding neighbors changes significantly. In PBC, MoirePy uses a KDTree on a set of \"ghost\" atoms (bigger lattice) to ensure that atoms near the edge find their counterparts on the other side. # Generate Hamiltonians with identical hopping parameters ham_obc = lattice_obc . generate_hamiltonian ( tll = 1.0 , tuu = 1.0 , tul = 0.1 , tlu = 0.1 ) ham_pbc = lattice_pbc . generate_hamiltonian ( tll = 1.0 , tuu = 1.0 , tul = 0.1 , tlu = 0.1 ) print ( f \"OBC Non-zero entries: { ham_obc . nnz } \" ) # 6062 print ( f \"PBC Non-zero entries: { ham_pbc . nnz } \" ) # 9728 Info In PBC , an atom at the far right edge connects to a neighbor at the far left edge. MoirePy handles this mapping automatically. You don't need to manually calculate wrapped coordinates. This results in a higher number of non-zero entries ( nnz ) in the PBC Hamiltonian.","title":"3. Hamiltonian and Connectivity"},{"location":"getting_started/obc_vs_pbc/#4-visual-comparison-hamiltonian-structure","text":"Let's plot the hamiltonian matrices and let's see how they look like: plt . imshow ( ham_obc . toarray (), cmap = \"gray\" ) plt . imshow ( ham_pbc . toarray (), cmap = \"gray\" )","title":"4. Visual Comparison (Hamiltonian Structure)"},{"location":"getting_started/obc_vs_pbc/#5-spectrum-comparison","text":"The choice of boundary conditions significantly affects the energy eigenvalues. OBC introduces \"edge states\" that may appear in gaps where the bulk (PBC) system has no states. from scipy.sparse.linalg import eigsh def get_spectrum ( ham ): # Get 100 eigenvalues near zero energy vals = eigsh ( ham , k = 100 , which = 'LM' , sigma = 0 , return_eigenvectors = False ) return np . sort ( vals ) spec_obc = get_spectrum ( ham_obc ) spec_pbc = get_spectrum ( ham_pbc ) plt . plot ( spec_obc , 'ro' , label = 'OBC (Edges)' , markersize = 4 ) plt . plot ( spec_pbc , 'k.' , label = 'PBC (Bulk)' , markersize = 4 ) plt . legend () plt . ylabel ( \"Energy\" ) plt . title ( \"Spectrum Comparison\" ) plt . show ()","title":"5. Spectrum Comparison"},{"location":"getting_started/obc_vs_pbc/#what-we-did","text":"Constructed the same lattice with OBC and PBC Observed how connectivity changes at the boundaries Compared Hamiltonians and resulting spectra This demonstrates how boundary conditions control whether you simulate a finite system or an infinite periodic system.","title":"What We Did"},{"location":"getting_started/obc_vs_pbc/#next-steps","text":"K-Space & Band Structures : Work in momentum space for periodic systems. Defining Custom Layers : Build your own lattice geometries. Designing Custom Hopping : Add realistic physics. Tutorials and Replicated Papers : See full physical results.","title":"Next Steps"},{"location":"getting_started/prepare_layers/","text":"","title":"Defining Custom Layers"},{"location":"getting_started/quickstart_tbg/","text":"Quickstart: Twisted Bilayer Graphene in 5 Minutes In this tutorial, you will simulate Twisted Bilayer Graphene (TBG) from scratch. MoirePy abstracts the geometric complexity of commensurate lattice construction, allowing you to go from a twist angle to a Hamiltonian in seconds. 1. Minimal Installation pip install moirepy 2. Construct the Moire Lattice We use the built-in HexagonalLayer (Graphene) to construct the bilayer. While this example focuses on graphene, MoirePy includes several other built-in geometries: SquareLayer TriangularLayer KagomeLayer Rhombus60Layer You can also define your own entirely unique geometries; see Defining Custom Layers for more. import numpy as np import matplotlib.pyplot as plt from moirepy import BilayerMoireLattice , HexagonalLayer # Define a commensurate TBG lattice lattice = BilayerMoireLattice ( latticetype = HexagonalLayer , # Indices for a ~9.43 degree twist # Find these via our tool: https://jabed-umar.github.io/MoirePy/theory/avc/ ll1 = 3 , ll2 = 4 , ul1 = 4 , ul2 = 3 , n1 = 1 , n2 = 1 , # Number of moir\u00e9 unit cells pbc = True , # Periodic Boundary Conditions, set False for OBC verbose = True # Displays twist angle and atom counts ) # Visualize the atomistic structure lattice . plot_lattice () plt . show () 3. Generate the Hamiltonian MoirePy separates geometry (KDTree-based neighbor search) from physics (hopping values). You can pass constants or custom functions for every term. Real-Space Hamiltonian Ideal for studying local defects or large-scale samples under Open Boundary Conditions (OBC) . # Returns a scipy.sparse.csc_matrix ham = lattice . generate_hamiltonian ( tll = 1.0 , # Lower-layer intra-layer hopping tuu = 1.0 , # Upper-layer intra-layer hopping tul = 0.1 , # Inter-layer hopping (Upper -> Lower) tlu = 0.1 , # Inter-layer hopping (Lower -> Upper) tlself = 0.0 , # Lower-layer onsite potential tuself = 0.0 , # Upper-layer onsite potential inter_layer_radius = 3 # Cut-off circle for interlayer search ) print ( f \"Hamiltonian Dimension: { ham . shape } \" ) # Output: Hamiltonian Dimension: (148, 148) Warning For a Hermitian system, ensure that your tlu function/value is the complex conjugate of tul . MoirePy does not enforce this automatically by design. k-Space Hamiltonian Essential for band structure calculations. Switching to momentum space requires no structural changes to your logic. # k-point at the Gamma point (0, 0) kham = lattice . generate_k_space_hamiltonian ( k = np . array ([ 0 , 0 ]), tll = 1.0 , tuu = 1.0 , tul = 0.1 , tlu = 0.1 , tlself = 0.0 , tuself = 0.0 ) 4. Compute Low-Energy States Because the Hamiltonian is returned as a standard SciPy sparse matrix, it integrates perfectly with the scientific Python ecosystem. from scipy.sparse.linalg import eigsh # Find the 20 eigenvalues closest to zero eigenvalues = eigsh ( ham , k = 50 , which = 'LM' , sigma = 0 , return_eigenvectors = False ) plt . scatter ( range ( len ( eigenvalues )), np . sort ( eigenvalues ), color = 'black' ) plt . ylabel ( \"Energy (t)\" ) plt . title ( \"Low-energy spectrum near Fermi level\" ) plt . show () The \"Getting Started\" Roadmap Now that you've built your first lattice, dive deeper into the core mechanics: K-Space & Band Structures : How to generate k-space Hamiltonians and compute band structures. OBC vs PBC : How we can simulate both infinite and finite systems using PBC and OBC respectively. Defining Custom Layers : Move beyond graphene to MoS2, Square lattices, or Kagome. Designing Custom Hopping : How to implement distance-dependent (exponential) hopping or strain. Tutorials and Replicated Papers : See full physical results.","title":"Quickstart TBG in 5 Minutes"},{"location":"getting_started/quickstart_tbg/#quickstart-twisted-bilayer-graphene-in-5-minutes","text":"In this tutorial, you will simulate Twisted Bilayer Graphene (TBG) from scratch. MoirePy abstracts the geometric complexity of commensurate lattice construction, allowing you to go from a twist angle to a Hamiltonian in seconds.","title":"Quickstart: Twisted Bilayer Graphene in 5 Minutes"},{"location":"getting_started/quickstart_tbg/#1-minimal-installation","text":"pip install moirepy","title":"1. Minimal Installation"},{"location":"getting_started/quickstart_tbg/#2-construct-the-moire-lattice","text":"We use the built-in HexagonalLayer (Graphene) to construct the bilayer. While this example focuses on graphene, MoirePy includes several other built-in geometries: SquareLayer TriangularLayer KagomeLayer Rhombus60Layer You can also define your own entirely unique geometries; see Defining Custom Layers for more. import numpy as np import matplotlib.pyplot as plt from moirepy import BilayerMoireLattice , HexagonalLayer # Define a commensurate TBG lattice lattice = BilayerMoireLattice ( latticetype = HexagonalLayer , # Indices for a ~9.43 degree twist # Find these via our tool: https://jabed-umar.github.io/MoirePy/theory/avc/ ll1 = 3 , ll2 = 4 , ul1 = 4 , ul2 = 3 , n1 = 1 , n2 = 1 , # Number of moir\u00e9 unit cells pbc = True , # Periodic Boundary Conditions, set False for OBC verbose = True # Displays twist angle and atom counts ) # Visualize the atomistic structure lattice . plot_lattice () plt . show ()","title":"2. Construct the Moire Lattice"},{"location":"getting_started/quickstart_tbg/#3-generate-the-hamiltonian","text":"MoirePy separates geometry (KDTree-based neighbor search) from physics (hopping values). You can pass constants or custom functions for every term.","title":"3. Generate the Hamiltonian"},{"location":"getting_started/quickstart_tbg/#real-space-hamiltonian","text":"Ideal for studying local defects or large-scale samples under Open Boundary Conditions (OBC) . # Returns a scipy.sparse.csc_matrix ham = lattice . generate_hamiltonian ( tll = 1.0 , # Lower-layer intra-layer hopping tuu = 1.0 , # Upper-layer intra-layer hopping tul = 0.1 , # Inter-layer hopping (Upper -> Lower) tlu = 0.1 , # Inter-layer hopping (Lower -> Upper) tlself = 0.0 , # Lower-layer onsite potential tuself = 0.0 , # Upper-layer onsite potential inter_layer_radius = 3 # Cut-off circle for interlayer search ) print ( f \"Hamiltonian Dimension: { ham . shape } \" ) # Output: Hamiltonian Dimension: (148, 148) Warning For a Hermitian system, ensure that your tlu function/value is the complex conjugate of tul . MoirePy does not enforce this automatically by design.","title":"Real-Space Hamiltonian"},{"location":"getting_started/quickstart_tbg/#k-space-hamiltonian","text":"Essential for band structure calculations. Switching to momentum space requires no structural changes to your logic. # k-point at the Gamma point (0, 0) kham = lattice . generate_k_space_hamiltonian ( k = np . array ([ 0 , 0 ]), tll = 1.0 , tuu = 1.0 , tul = 0.1 , tlu = 0.1 , tlself = 0.0 , tuself = 0.0 )","title":"k-Space Hamiltonian"},{"location":"getting_started/quickstart_tbg/#4-compute-low-energy-states","text":"Because the Hamiltonian is returned as a standard SciPy sparse matrix, it integrates perfectly with the scientific Python ecosystem. from scipy.sparse.linalg import eigsh # Find the 20 eigenvalues closest to zero eigenvalues = eigsh ( ham , k = 50 , which = 'LM' , sigma = 0 , return_eigenvectors = False ) plt . scatter ( range ( len ( eigenvalues )), np . sort ( eigenvalues ), color = 'black' ) plt . ylabel ( \"Energy (t)\" ) plt . title ( \"Low-energy spectrum near Fermi level\" ) plt . show ()","title":"4. Compute Low-Energy States"},{"location":"getting_started/quickstart_tbg/#the-getting-started-roadmap","text":"Now that you've built your first lattice, dive deeper into the core mechanics: K-Space & Band Structures : How to generate k-space Hamiltonians and compute band structures. OBC vs PBC : How we can simulate both infinite and finite systems using PBC and OBC respectively. Defining Custom Layers : Move beyond graphene to MoS2, Square lattices, or Kagome. Designing Custom Hopping : How to implement distance-dependent (exponential) hopping or strain. Tutorials and Replicated Papers : See full physical results.","title":"The \"Getting Started\" Roadmap"},{"location":"theory/angle_calculation_process/","text":".section{ text-align: justify; } Angle Calculation Process When two single layers of a 2D material are stacked with a small misalignment, they produce a moir\u00e9 pattern with a length scale much larger than the periodicity of either individual layer. At specific twist angles, this results in a commensurate moir\u00e9 pattern ; a structure where atoms from one layer align exactly with those of the other. In this section, we describe how MoirePy calculates the commensurate rotation angles between two lattices confined to a bounded region. The goal is to identify angles where the lattices align periodically, producing well-ordered moir\u00e9 patterns that are physically observable. 1. Problem Statement Let lattices \\(A\\) and \\(B\\) be two periodic point sets in two dimensions, each defined by their respective lattice vectors. We address the following geometric question: Given a rotation angle \\(\\theta\\) , does there exist a point \\(\\mathbf{p} \\in A\\) and a point \\(\\mathbf{q} \\in B\\) such that \\[ \\mathbf{p} = R(\\theta)\\mathbf{q} \\tag{1.1} \\] where \\(R(\\theta)\\) denotes the standard rotation matrix. In 2D, this matrix is defined as: \\[ R(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\tag{1.2} \\] To bound the computation, we restrict our analysis to a finite region by considering only lattice points within a circular region of radius \\(r\\) . Let the truncated sets be \\(A_r = A \\cap \\text{circle}(r)\\) and \\(B_r = B \\cap \\text{circle}(r)\\) . Our goal is to determine the set of angles \\(\\theta\\) (including the corresponding points) for which there exists a pair of points \\(\\mathbf{p} \\in A_r\\) and \\(\\mathbf{q} \\in B_r\\) satisfying Equation 1.1. These angles correspond to commensurate alignments between the two lattices, yielding physically observable moir\u00e9 patterns. 2. Traditional Diophantine Equation Approach In commensurate moir\u00e9 superlattices, specific periodic points exist where atoms from the top and bottom layers align exactly. To analyze these alignments, let \\((\\vec{a}, \\vec{b})\\) and \\((\\vec{m}, \\vec{n})\\) denote the primitive lattice vectors of the lower and upper layers, respectively. The atomic positions in each layer are given by: \\[ \\vec{R}^1_{p,q} = a\\vec{a} + b\\vec{b} \\quad \\text{and} \\quad \\vec{R}^2_{m,n} = R(\\theta)(m\\vec{m} + n\\vec{n}), \\quad a, b, m, n \\in \\mathbb{Z} \\] Fig 1: Illustration of vector matching for commensurate moir\u00e9 patterns. Here vectors m and n are already rotated by angle theta. For a commensurate moir\u00e9 superlattice to form, there must exist integers \\(a, b, m, n\\) such that: \\[\\vec{R}^1_{p,q} = \\vec{R}^2_{m,n}\\] This leads to a condition based on vector magnitudes and orientations: \\[ \\vec{a} \\cdot \\vec{b} = \\vec{m} \\cdot \\vec{n} = \\cos{\\beta} = \\frac{m^2 + n^2 - a^2 - b^2}{2(ab - mn)} \\tag{2.1} \\] We need to find all integer quadruples (a, b, m, n) satisfying Equation 2.1. Then, the corresponding twist angle \\(\\theta\\) can then be computed. The computation proceeds as follows. The length of the moir\u00e9 lattice vector \\(\\vec{r}\\) connecting equivalent lattice points is: \\[ r = |\\vec{r}| = \\sqrt{a^2 + b^2 + 2ab\\cos\\beta} \\] Using the Law of Sines, we calculate the intermediate angles \\(\\alpha\\) and \\(\\gamma\\) : \\[ \\frac{b}{\\sin\\alpha} = \\frac{r}{\\sin(180^\\circ - \\beta)} \\quad \\Rightarrow \\quad \\alpha = \\sin^{-1}\\left(\\frac{b \\sin\\beta}{r}\\right) \\tag{2.2} \\] \\[ \\frac{n}{\\sin\\gamma} = \\frac{r}{\\sin(180^\\circ - \\beta)} \\quad \\Rightarrow \\quad \\gamma = \\sin^{-1}\\left(\\frac{n \\sin\\beta}{r}\\right) \\tag{2.3} \\] The twist angle \\(\\theta\\) between the two layers is then: \\[ \\theta = \\alpha - \\gamma = \\sin^{-1}\\left(\\frac{b \\sin\\beta}{r}\\right) - \\sin^{-1}\\left(\\frac{n \\sin\\beta}{r}\\right) \\] This classical Diophantine approach provides a rigorous framework for determining commensurate twist angles where the lattice vectors form periodic overlaps. Time Complexity The general approach involves iterating over all possible values of the first three variables ( \\(a\\) , \\(b\\) , \\(m\\) ) and computing the fourth variable ( \\(n\\) ) based on the condition in Equation 2.1. A valid solution exists when \\(n\\) is an integer. This brute-force search results in a time complexity of \\(O(n^3)\\) , where \\(n\\) represents the maximum value of the variables (starting from 0). For large \\(n\\) (i.e., when considering dense lattice points), this cubic complexity becomes computationally prohibitive. We wanted to find a better solution. Observations About Lattice Structure When examining regularly spaced lattices (like triangular or square lattices), we observed several useful structural properties. As shown in Fig. 2, lattice points naturally organize into concentric circles around the origin. If we sort all points by their distance from the origin, we see distinct discrete levels forming - similar to a step function. Each level (corresponding to a specific radius) contains symmetrically arranged points. For instance, in triangular lattices, each level contains a multiple of 6 points due to the lattice's 6-fold rotational symmetry (Fig. 3). (Similarly we see in Square lattice, a multiple of 4 points per level.) Fig 2: Lattice points reside in concentric circles Fig 3: Number of points in each shell is a multiple of 6 (Triangle lattice) This symmetric distribution has an important consequence: when two lattices share the same radial level, we only need to align one pair of points at that level. The remaining 5 symmetric points will automatically align due to the lattice symmetry, significantly reducing the computational effort needed to find commensurate angles. Our Method Our approach leverages lattice geometry and symmetry rather than algebraic equations to identify commensurate rotation angles. The method operates directly on the spatial distribution of lattice points, and hence is applicable for any regular lattice structure even stacking two different ones. Algorithm Overview Let \\(A_r\\) and \\(B_r\\) be the sets of lattice points (from lattice A and B respectively) within radius \\(r\\) from the origin. Group points by radius : For each point ( \\(\\mathbf{p}\\) ) in \\(A_r\\) and \\(B_r\\) , compute its distance \\(d = \\|\\mathbf{p}\\|\\) from the origin. In each lattice, group points that lie at the same radius into levels . Identify shared levels : Let \\(D = \\{d \\mid d \\text{ occurs in both } A_r \\text{ and } B_r \\} \\setminus \\{0\\}\\) . These are the radii at which both lattices have points. Filter by angular sector : For each \\(d \\in D\\) , consider only those points \\(\\{\\mathbf{p}\\} \\in A_r\\) and \\(\\{\\mathbf{q}\\} \\in B_r\\) on level \\(d\\) such that \\[ 0 < \\angle\\mathbf{p} \\le \\theta_\\text{max}, \\quad 0 < \\angle\\mathbf{q} \\le \\theta_\\text{max} \\] where \\(\\theta_\\text{max}\\) is the lattice's symmetry sector (e.g., \\(60^\\circ\\) for triangular lattices, \\(90^\\circ\\) for square lattices). Although till now we have discussed as if the upper lattice and lower lattice can be different, in practice we have never tested this code on different lattices. Neither do we know if those cases will yield any commensurate angles. For now, we will assume that both lattices are the same. So here when we say lattice's symmetry sector, we mean the symmetry sectors of both are same. Compute angle differences : Now we will pair points from \\(\\{\\mathbf{p}\\}\\) with \\(\\{\\mathbf{q}\\}\\) at each common level \\(D\\) . For each point from \\(\\{\\mathbf{p}\\}\\) , we will pair it with every point from \\(\\{\\mathbf{q}\\}\\) . For each pair, compute the angle differences. This procedure ensures we collect unique, minimal-angle configurations that could align under rotation, constrained to the symmetry of the lattice. Some Practical Optimizations In Step 4 after calculating the angle difference (say \\(\\theta\\)), we keep the angle only if it is in the range \\(0 < \\theta < \\theta_\\text{max}\\). Note that we exclude \\(0\\) because it corresponds to the trivial case where no rotation is applied, and we exclude \\(\\theta_\\text{max}\\) because it corresponds to the case where the two lattices are again perfectly aligned, as if no rotation is applied. Also we do not take angles more than \\(\\theta_\\text{max}\\) because they are equivalent to angles less than \\(\\theta_\\text{max}\\) due to periodicity. In Step 1 , when using same lattice as both upper and lower layer, after grouping points that lie at the same distance from the origin, we discard those \\(d\\)s who just have 6 points (4 points for square lattice). This is because it will lead us to no rotation anyway. We keep only those \\(d\\)s which have more than 6 points (12, 18, etc. for triangular lattice; 8, 12, etc. for square lattice) where we can form pairs of points that yield non-trivial angles. Time Complexity If the number points is of the order \\(O(n^2)\\) and they are sorted by distance, the time complexity of this part becomes \\(O(n^2 \\log n^2)\\) . Apart from this all other steps are multiple order smaller than this cost, hence can be ignored. That makes this algorithm much less than the \\(O(n^3)\\) of the Diophantine approach and arguably more intuitive. Calculating the lattice vectors given the overlapping points Summary We avoided solving Diophantine equations by leaning on geometry and symmetry: Points are grouped by radius Only overlapping radii are considered Pairwise angle differences yield the commensurate angles This makes MoirePy 's angle detection both fast and visual , and opens up room for further optimizations or generalizations.","title":"Angle Calculation Logic"},{"location":"theory/angle_calculation_process/#angle-calculation-process","text":"When two single layers of a 2D material are stacked with a small misalignment, they produce a moir\u00e9 pattern with a length scale much larger than the periodicity of either individual layer. At specific twist angles, this results in a commensurate moir\u00e9 pattern ; a structure where atoms from one layer align exactly with those of the other. In this section, we describe how MoirePy calculates the commensurate rotation angles between two lattices confined to a bounded region. The goal is to identify angles where the lattices align periodically, producing well-ordered moir\u00e9 patterns that are physically observable.","title":"Angle Calculation Process"},{"location":"theory/angle_calculation_process/#1-problem-statement","text":"Let lattices \\(A\\) and \\(B\\) be two periodic point sets in two dimensions, each defined by their respective lattice vectors. We address the following geometric question: Given a rotation angle \\(\\theta\\) , does there exist a point \\(\\mathbf{p} \\in A\\) and a point \\(\\mathbf{q} \\in B\\) such that \\[ \\mathbf{p} = R(\\theta)\\mathbf{q} \\tag{1.1} \\] where \\(R(\\theta)\\) denotes the standard rotation matrix. In 2D, this matrix is defined as: \\[ R(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\tag{1.2} \\] To bound the computation, we restrict our analysis to a finite region by considering only lattice points within a circular region of radius \\(r\\) . Let the truncated sets be \\(A_r = A \\cap \\text{circle}(r)\\) and \\(B_r = B \\cap \\text{circle}(r)\\) . Our goal is to determine the set of angles \\(\\theta\\) (including the corresponding points) for which there exists a pair of points \\(\\mathbf{p} \\in A_r\\) and \\(\\mathbf{q} \\in B_r\\) satisfying Equation 1.1. These angles correspond to commensurate alignments between the two lattices, yielding physically observable moir\u00e9 patterns.","title":"1. Problem Statement"},{"location":"theory/angle_calculation_process/#2-traditional-diophantine-equation-approach","text":"In commensurate moir\u00e9 superlattices, specific periodic points exist where atoms from the top and bottom layers align exactly. To analyze these alignments, let \\((\\vec{a}, \\vec{b})\\) and \\((\\vec{m}, \\vec{n})\\) denote the primitive lattice vectors of the lower and upper layers, respectively. The atomic positions in each layer are given by: \\[ \\vec{R}^1_{p,q} = a\\vec{a} + b\\vec{b} \\quad \\text{and} \\quad \\vec{R}^2_{m,n} = R(\\theta)(m\\vec{m} + n\\vec{n}), \\quad a, b, m, n \\in \\mathbb{Z} \\] Fig 1: Illustration of vector matching for commensurate moir\u00e9 patterns. Here vectors m and n are already rotated by angle theta. For a commensurate moir\u00e9 superlattice to form, there must exist integers \\(a, b, m, n\\) such that: \\[\\vec{R}^1_{p,q} = \\vec{R}^2_{m,n}\\] This leads to a condition based on vector magnitudes and orientations: \\[ \\vec{a} \\cdot \\vec{b} = \\vec{m} \\cdot \\vec{n} = \\cos{\\beta} = \\frac{m^2 + n^2 - a^2 - b^2}{2(ab - mn)} \\tag{2.1} \\] We need to find all integer quadruples (a, b, m, n) satisfying Equation 2.1. Then, the corresponding twist angle \\(\\theta\\) can then be computed. The computation proceeds as follows. The length of the moir\u00e9 lattice vector \\(\\vec{r}\\) connecting equivalent lattice points is: \\[ r = |\\vec{r}| = \\sqrt{a^2 + b^2 + 2ab\\cos\\beta} \\] Using the Law of Sines, we calculate the intermediate angles \\(\\alpha\\) and \\(\\gamma\\) : \\[ \\frac{b}{\\sin\\alpha} = \\frac{r}{\\sin(180^\\circ - \\beta)} \\quad \\Rightarrow \\quad \\alpha = \\sin^{-1}\\left(\\frac{b \\sin\\beta}{r}\\right) \\tag{2.2} \\] \\[ \\frac{n}{\\sin\\gamma} = \\frac{r}{\\sin(180^\\circ - \\beta)} \\quad \\Rightarrow \\quad \\gamma = \\sin^{-1}\\left(\\frac{n \\sin\\beta}{r}\\right) \\tag{2.3} \\] The twist angle \\(\\theta\\) between the two layers is then: \\[ \\theta = \\alpha - \\gamma = \\sin^{-1}\\left(\\frac{b \\sin\\beta}{r}\\right) - \\sin^{-1}\\left(\\frac{n \\sin\\beta}{r}\\right) \\] This classical Diophantine approach provides a rigorous framework for determining commensurate twist angles where the lattice vectors form periodic overlaps.","title":"2. Traditional Diophantine Equation Approach"},{"location":"theory/angle_calculation_process/#time-complexity","text":"The general approach involves iterating over all possible values of the first three variables ( \\(a\\) , \\(b\\) , \\(m\\) ) and computing the fourth variable ( \\(n\\) ) based on the condition in Equation 2.1. A valid solution exists when \\(n\\) is an integer. This brute-force search results in a time complexity of \\(O(n^3)\\) , where \\(n\\) represents the maximum value of the variables (starting from 0). For large \\(n\\) (i.e., when considering dense lattice points), this cubic complexity becomes computationally prohibitive. We wanted to find a better solution.","title":"Time Complexity"},{"location":"theory/angle_calculation_process/#observations-about-lattice-structure","text":"When examining regularly spaced lattices (like triangular or square lattices), we observed several useful structural properties. As shown in Fig. 2, lattice points naturally organize into concentric circles around the origin. If we sort all points by their distance from the origin, we see distinct discrete levels forming - similar to a step function. Each level (corresponding to a specific radius) contains symmetrically arranged points. For instance, in triangular lattices, each level contains a multiple of 6 points due to the lattice's 6-fold rotational symmetry (Fig. 3). (Similarly we see in Square lattice, a multiple of 4 points per level.) Fig 2: Lattice points reside in concentric circles Fig 3: Number of points in each shell is a multiple of 6 (Triangle lattice) This symmetric distribution has an important consequence: when two lattices share the same radial level, we only need to align one pair of points at that level. The remaining 5 symmetric points will automatically align due to the lattice symmetry, significantly reducing the computational effort needed to find commensurate angles.","title":"Observations About Lattice Structure"},{"location":"theory/angle_calculation_process/#our-method","text":"Our approach leverages lattice geometry and symmetry rather than algebraic equations to identify commensurate rotation angles. The method operates directly on the spatial distribution of lattice points, and hence is applicable for any regular lattice structure even stacking two different ones.","title":"Our Method"},{"location":"theory/angle_calculation_process/#algorithm-overview","text":"Let \\(A_r\\) and \\(B_r\\) be the sets of lattice points (from lattice A and B respectively) within radius \\(r\\) from the origin. Group points by radius : For each point ( \\(\\mathbf{p}\\) ) in \\(A_r\\) and \\(B_r\\) , compute its distance \\(d = \\|\\mathbf{p}\\|\\) from the origin. In each lattice, group points that lie at the same radius into levels . Identify shared levels : Let \\(D = \\{d \\mid d \\text{ occurs in both } A_r \\text{ and } B_r \\} \\setminus \\{0\\}\\) . These are the radii at which both lattices have points. Filter by angular sector : For each \\(d \\in D\\) , consider only those points \\(\\{\\mathbf{p}\\} \\in A_r\\) and \\(\\{\\mathbf{q}\\} \\in B_r\\) on level \\(d\\) such that \\[ 0 < \\angle\\mathbf{p} \\le \\theta_\\text{max}, \\quad 0 < \\angle\\mathbf{q} \\le \\theta_\\text{max} \\] where \\(\\theta_\\text{max}\\) is the lattice's symmetry sector (e.g., \\(60^\\circ\\) for triangular lattices, \\(90^\\circ\\) for square lattices). Although till now we have discussed as if the upper lattice and lower lattice can be different, in practice we have never tested this code on different lattices. Neither do we know if those cases will yield any commensurate angles. For now, we will assume that both lattices are the same. So here when we say lattice's symmetry sector, we mean the symmetry sectors of both are same. Compute angle differences : Now we will pair points from \\(\\{\\mathbf{p}\\}\\) with \\(\\{\\mathbf{q}\\}\\) at each common level \\(D\\) . For each point from \\(\\{\\mathbf{p}\\}\\) , we will pair it with every point from \\(\\{\\mathbf{q}\\}\\) . For each pair, compute the angle differences. This procedure ensures we collect unique, minimal-angle configurations that could align under rotation, constrained to the symmetry of the lattice. Some Practical Optimizations In Step 4 after calculating the angle difference (say \\(\\theta\\)), we keep the angle only if it is in the range \\(0 < \\theta < \\theta_\\text{max}\\). Note that we exclude \\(0\\) because it corresponds to the trivial case where no rotation is applied, and we exclude \\(\\theta_\\text{max}\\) because it corresponds to the case where the two lattices are again perfectly aligned, as if no rotation is applied. Also we do not take angles more than \\(\\theta_\\text{max}\\) because they are equivalent to angles less than \\(\\theta_\\text{max}\\) due to periodicity. In Step 1 , when using same lattice as both upper and lower layer, after grouping points that lie at the same distance from the origin, we discard those \\(d\\)s who just have 6 points (4 points for square lattice). This is because it will lead us to no rotation anyway. We keep only those \\(d\\)s which have more than 6 points (12, 18, etc. for triangular lattice; 8, 12, etc. for square lattice) where we can form pairs of points that yield non-trivial angles.","title":"Algorithm Overview"},{"location":"theory/angle_calculation_process/#time-complexity_1","text":"If the number points is of the order \\(O(n^2)\\) and they are sorted by distance, the time complexity of this part becomes \\(O(n^2 \\log n^2)\\) . Apart from this all other steps are multiple order smaller than this cost, hence can be ignored. That makes this algorithm much less than the \\(O(n^3)\\) of the Diophantine approach and arguably more intuitive.","title":"Time Complexity"},{"location":"theory/angle_calculation_process/#calculating-the-lattice-vectors-given-the-overlapping-points","text":"","title":"Calculating the lattice vectors given the overlapping points"},{"location":"theory/angle_calculation_process/#summary","text":"We avoided solving Diophantine equations by leaning on geometry and symmetry: Points are grouped by radius Only overlapping radii are considered Pairwise angle differences yield the commensurate angles This makes MoirePy 's angle detection both fast and visual , and opens up room for further optimizations or generalizations.","title":"Summary"},{"location":"theory/avc/","text":".input-form { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; } input, select, button { font-size: 16px; padding: 5px; } button { cursor: pointer; background-color: rgb(41, 128, 185); color: white; border: none; padding: 10px; } table { width: 100%; border-collapse: collapse; margin-top: 20px; } th, td { padding: 8px; text-align: center; border: 1px solid #ddd; } thead { background-color: #f2f2f2; } .hidden { display: none; } .vector-inputs input { width: 80px; margin: 5px; } #end, #start { border: 1px solid #000; border-radius: 5px; padding: 8px; width: 100px; font-size: 16px; } .section{ text-align: justify; } Angle Value Calculator The Moir\u00e9 Angle Calculator finds all possible commensurate angles between two stacked lattices by trimming both layers within a given radius and checking for periodic overlaps following the Angle Calculation Process . After calculation, it provides a list of angles with their corresponding ll1 , ll2 , ul1 , ul2 values that define the rotation between the two lattices along with the number of points in each cell of the Moir\u00e9 lattice. Since most angles are irrational and can't be precisely represented, the rotation is defined using these coordinate pairs instead, they mark the overlapping points between the two lattices. Once you've selected an angle from the list, just copy the ll1 , ll2 , ul1 , and ul2 values into your code. The system will figure out the exact rotation angle from that. This also makes it easy to calculate the moire lattice vectors. Some Guidelines A radius must be specified to define the extent of the circular region centred at the origin. This value is used to truncate both the upper and lower lattices. Larger radius Includes more lattice points, potentially giving more precise calculations and revealing smaller angles, but increases computation time. Smaller radius Produces faster results, yet may detect only larger angle values. Currently supported systems: Both layers 60 \\(^\\circ\\) (Triangular, Hexagonal and Kagome lattices) Both layers 90 \\(^\\circ\\) (Square lattice) Custom mode ( experimental ) Possible problems - Erroneous or nonsensical output - Unresponsiveness or infinite loops - Unexpected program behaviour Proceed only if you believe the results yielded by the Angle Calculation Process are correct and meaningful for your custom lattice vectors. Larger Value of points per cell More points per cell in the lattice means larger hamiltonian matrix, which can lead to longer computation times and higher memory usage. Especially if planning to invert the hamiltonian matrix and find eigenvalues and eigenvectors later. Number of Points has been calculated assuming only one point per unit cell. If you are using lattices which have multiple points per unit cell like hexagonal (2) or kagome (3), multiply this value by the number of points per unit cell in your lattice to get the actual number of points in the Moir\u00e9 lattice. Precision has NO effect on the calculation . It only affects the output format of the results. (In the calculation, we stick to integer values to avoid floating point errors). Calculator Radius: Lattice Type: both layers 60 degree (Triangular, Hexagonal and Kagome lattice) both layers 90 degree (Square lattice) Custom (experimental) Lattice Vectors for Layer 1: lv1: x + y lv2: x + y Lattice Vectors for Layer 2: lv1: x + y lv2: x + y WARNING: RESULTS MIGHT BE MEANINGLESS OR INACCURATE Precision: 6 CALCULATE Note The last column (number of points per unit cell in the Moir\u00e9 lattice) has been calculated assuming only one point per unit cell. If you are using lattices which have multiple points per unit cell like hexagonal (2) or kagome (3), multiply this value by the number of points per unit cell in your lattice to get the actual number of points in the Moir\u00e9 lattice. angle (deg) angle (rad) ll1 ll2 ul1 ul2 points/cell let root3 = Math.sqrt(3); const latticeDefaults = { HexagonalLayer: [1, 0, 0.5, root3 / 2], SquareLayer: [1, 0, 0, 1], RhombusLayer: [1, 0, 0.5, root3 / 2], TriangularLayer: [1, 0, 0.5, root3 / 2], KagomeLayer: [1, 0, 0.5, root3 / 2], }; document.getElementById(\"precision\").addEventListener(\"input\", function() { document.getElementById(\"precision-value\").textContent = this.value; }); function updateLatticeVectors() { const type = document.getElementById(\"latticeType\").value; const customDiv = document.getElementById(\"custom-vectors\"); if (type === \"Custom\") { customDiv.classList.remove(\"hidden\"); } else { customDiv.classList.add(\"hidden\"); const vec = latticeDefaults[type] || [1, 1, 1, 1]; // Set both layers with the same vectors document.getElementById(\"layer1-lv1x\").value = vec[0]; document.getElementById(\"layer1-lv1y\").value = vec[1]; document.getElementById(\"layer1-lv2x\").value = vec[2]; document.getElementById(\"layer1-lv2y\").value = vec[3]; document.getElementById(\"layer2-lv1x\").value = vec[0]; document.getElementById(\"layer2-lv1y\").value = vec[1]; document.getElementById(\"layer2-lv2x\").value = vec[2]; document.getElementById(\"layer2-lv2y\").value = vec[3]; } } function gcd(x, y) { if (y === 0) return x; else return gcd(y, x % y); } function angleId(p1, p2) { // Dot product const dot = p1[0] * p2[0] + p1[1] * p2[1]; const dotSq = dot * dot; // Norms squared const norm1Sq = p1[0] ** 2 + p1[1] ** 2; const norm2Sq = p2[0] ** 2 + p2[1] ** 2; const denom = norm1Sq * norm2Sq; // Reduce the fraction dotSq / denom const commonDivisor = gcd(dotSq, denom); const num = dotSq / commonDivisor; const den = denom / commonDivisor; // Return as a string ID return `${num}/${den}`; } function calculate() { const radius = parseInt(document.getElementById(\"radius\").value); const layer1Vectors = [ parseFloat(document.getElementById(\"layer1-lv1x\").value), parseFloat(document.getElementById(\"layer1-lv1y\").value), parseFloat(document.getElementById(\"layer1-lv2x\").value), parseFloat(document.getElementById(\"layer1-lv2y\").value) ]; const layer2Vectors = [ parseFloat(document.getElementById(\"layer2-lv1x\").value), parseFloat(document.getElementById(\"layer2-lv1y\").value), parseFloat(document.getElementById(\"layer2-lv2x\").value), parseFloat(document.getElementById(\"layer2-lv2y\").value) ]; const precision = parseInt(document.getElementById(\"precision\").value); // console.log(radius, layer1Vectors, layer2Vectors); const results = find_values(radius, layer1Vectors, layer2Vectors, tol=precision); console.log(results); console.log(\"Number of results:\", results.length); displayResults_(results); } function calc_indices(p, lv1, lv2) { const [a, b] = lv1; const [c, d] = lv2; const [x, y] = p; const det = (a * d - b * c); const nx = (d * x - c * y) / det; const ny = (a * y - b * x) / det; if (Math.abs(Math.round(nx) - nx) > 1e-5 || Math.abs(Math.round(ny) - ny) > 1e-5) { throw new Error(`Calculation error for indices: ${nx}, ${ny}`); } return [Math.round(nx), Math.round(ny)]; } function generate_lattice_points(lv1, lv2, radius) { const points = []; const maxGridSize = Math.floor(radius / Math.abs(lv2[1])) + 5; // console.log(radius, lv1, lv2, maxGridSize); for (let i = -maxGridSize; i <= maxGridSize; i++) { for (let j = -maxGridSize; j <= maxGridSize; j++) { // console.log(i, j); const point = [i * lv1[0] + j * lv2[0], i * lv1[1] + j * lv2[1]]; const dist = Math.sqrt(point[0] ** 2 + point[1] ** 2); if (dist <= radius) points.push(point); } } return points; } function angle_from_x(p) { return Math.atan2(p[1], p[0]) * 180 / Math.PI; } function process_lattice(points, tol) { const distances = points.map(p => Math.hypot(p[0], p[1])); const distMap = new Map(); // console.log(distMap); for (let i = 0; i < points.length; i++) { const d = parseFloat(distances[i].toFixed(tol)); if (!distMap.has(d)) distMap.set(d, {}); distMap.get(d)[i] = points[i]; } return [distMap, new Set([...distMap.keys()])]; } function find_values(radius, layer1Vectors, layer2Vectors, tol = 6) { const [a1x, a1y, b1x, b1y] = layer1Vectors; const [a2x, a2y, b2x, b2y] = layer2Vectors; if (JSON.stringify(layer1Vectors) !== JSON.stringify(layer2Vectors)) { alert(\"Warning: Vectors are not identical! Results might be inaccurate or meaningless.\"); } const lv1 = [a1x, a1y]; const lv2 = [b1x, b1y]; const lattice1 = generate_lattice_points(lv1, lv2, radius); const lattice2 = generate_lattice_points(lv1, lv2, radius); const [dict1, dist_set1] = process_lattice(lattice1, tol); const [dict2, dist_set2] = process_lattice(lattice2, tol); const common_dists = [...dist_set1].filter(d => dist_set2.has(d)).sort((a, b) => a - b).slice(1); const angle_dict = {}; const lattice_angle = angle_from_x(lv2) - angle_from_x(lv1); const isValidTheta = (theta) => theta > 0 && theta < lattice_angle; for (const d of common_dists) { // console.log(d) const pts1 = Object.values(dict1.get(d)).filter(p => isValidTheta(angle_from_x(p))); const pts2 = Object.values(dict2.get(d)).filter(p => isValidTheta(angle_from_x(p))); for (const p1 of pts1) { const theta1 = parseFloat(angle_from_x(p1).toFixed(tol)); for (const p2 of pts2) { const theta2 = parseFloat(angle_from_x(p2)); const angle = parseFloat((theta2 - theta1)); // use cos theta square between p1 and p2 as uid const uid = angleId(p1, p2); if ( theta2 <= theta1 || angle < Math.pow(10, -tol) || uid in angle_dict ) continue; angle_dict[uid] = [p1, p2, angle]; } } } const results = Object.entries(angle_dict) .sort(([, a], [, b]) => parseFloat(a[2]) - parseFloat(b[2])) // ascending by angle .map(([k, [p1, p2, angle]]) => { const thetaRad = (parseFloat(angle) * Math.PI) / 180; const thetaDeg = parseFloat(angle); const [i1, j1] = calc_indices(p1, lv1, lv2); const [i2, j2] = calc_indices(p2, lv1, lv2); const num_pts = 2*(p1[0] * p1[0] + p1[1] * p1[1]) * 1; // 1 for one point per unit cell return [thetaDeg.toFixed(tol), thetaRad.toFixed(tol), i2, j2, i1, j1, num_pts]; }); return results; } function displayResults_(results) { const resultsBody = document.getElementById(\"results-body\"); resultsBody.innerHTML = \"\"; // Clear previous results results.forEach((tuple, index) => { const row = document.createElement(\"tr\"); const cell = document.createElement(\"td\"); cell.textContent = index + 1; // add the index row.appendChild(cell); tuple.forEach(value => { const cell = document.createElement(\"td\"); cell.textContent = value; row.appendChild(cell); }); resultsBody.appendChild(row); }); } updateLatticeVectors('layer1'); updateLatticeVectors('layer2');","title":"Angle Value Calculator"},{"location":"theory/avc/#angle-value-calculator","text":"The Moir\u00e9 Angle Calculator finds all possible commensurate angles between two stacked lattices by trimming both layers within a given radius and checking for periodic overlaps following the Angle Calculation Process . After calculation, it provides a list of angles with their corresponding ll1 , ll2 , ul1 , ul2 values that define the rotation between the two lattices along with the number of points in each cell of the Moir\u00e9 lattice. Since most angles are irrational and can't be precisely represented, the rotation is defined using these coordinate pairs instead, they mark the overlapping points between the two lattices. Once you've selected an angle from the list, just copy the ll1 , ll2 , ul1 , and ul2 values into your code. The system will figure out the exact rotation angle from that. This also makes it easy to calculate the moire lattice vectors. Some Guidelines A radius must be specified to define the extent of the circular region centred at the origin. This value is used to truncate both the upper and lower lattices. Larger radius Includes more lattice points, potentially giving more precise calculations and revealing smaller angles, but increases computation time. Smaller radius Produces faster results, yet may detect only larger angle values. Currently supported systems: Both layers 60 \\(^\\circ\\) (Triangular, Hexagonal and Kagome lattices) Both layers 90 \\(^\\circ\\) (Square lattice) Custom mode ( experimental ) Possible problems - Erroneous or nonsensical output - Unresponsiveness or infinite loops - Unexpected program behaviour Proceed only if you believe the results yielded by the Angle Calculation Process are correct and meaningful for your custom lattice vectors. Larger Value of points per cell More points per cell in the lattice means larger hamiltonian matrix, which can lead to longer computation times and higher memory usage. Especially if planning to invert the hamiltonian matrix and find eigenvalues and eigenvectors later. Number of Points has been calculated assuming only one point per unit cell. If you are using lattices which have multiple points per unit cell like hexagonal (2) or kagome (3), multiply this value by the number of points per unit cell in your lattice to get the actual number of points in the Moir\u00e9 lattice. Precision has NO effect on the calculation . It only affects the output format of the results. (In the calculation, we stick to integer values to avoid floating point errors).","title":"Angle Value Calculator"},{"location":"theory/avc/#calculator","text":"Radius: Lattice Type: both layers 60 degree (Triangular, Hexagonal and Kagome lattice) both layers 90 degree (Square lattice) Custom (experimental) Lattice Vectors for Layer 1: lv1: x + y lv2: x + y Lattice Vectors for Layer 2: lv1: x + y lv2: x + y WARNING: RESULTS MIGHT BE MEANINGLESS OR INACCURATE Precision: 6 CALCULATE Note The last column (number of points per unit cell in the Moir\u00e9 lattice) has been calculated assuming only one point per unit cell. If you are using lattices which have multiple points per unit cell like hexagonal (2) or kagome (3), multiply this value by the number of points per unit cell in your lattice to get the actual number of points in the Moir\u00e9 lattice. angle (deg) angle (rad) ll1 ll2 ul1 ul2 points/cell let root3 = Math.sqrt(3); const latticeDefaults = { HexagonalLayer: [1, 0, 0.5, root3 / 2], SquareLayer: [1, 0, 0, 1], RhombusLayer: [1, 0, 0.5, root3 / 2], TriangularLayer: [1, 0, 0.5, root3 / 2], KagomeLayer: [1, 0, 0.5, root3 / 2], }; document.getElementById(\"precision\").addEventListener(\"input\", function() { document.getElementById(\"precision-value\").textContent = this.value; }); function updateLatticeVectors() { const type = document.getElementById(\"latticeType\").value; const customDiv = document.getElementById(\"custom-vectors\"); if (type === \"Custom\") { customDiv.classList.remove(\"hidden\"); } else { customDiv.classList.add(\"hidden\"); const vec = latticeDefaults[type] || [1, 1, 1, 1]; // Set both layers with the same vectors document.getElementById(\"layer1-lv1x\").value = vec[0]; document.getElementById(\"layer1-lv1y\").value = vec[1]; document.getElementById(\"layer1-lv2x\").value = vec[2]; document.getElementById(\"layer1-lv2y\").value = vec[3]; document.getElementById(\"layer2-lv1x\").value = vec[0]; document.getElementById(\"layer2-lv1y\").value = vec[1]; document.getElementById(\"layer2-lv2x\").value = vec[2]; document.getElementById(\"layer2-lv2y\").value = vec[3]; } } function gcd(x, y) { if (y === 0) return x; else return gcd(y, x % y); } function angleId(p1, p2) { // Dot product const dot = p1[0] * p2[0] + p1[1] * p2[1]; const dotSq = dot * dot; // Norms squared const norm1Sq = p1[0] ** 2 + p1[1] ** 2; const norm2Sq = p2[0] ** 2 + p2[1] ** 2; const denom = norm1Sq * norm2Sq; // Reduce the fraction dotSq / denom const commonDivisor = gcd(dotSq, denom); const num = dotSq / commonDivisor; const den = denom / commonDivisor; // Return as a string ID return `${num}/${den}`; } function calculate() { const radius = parseInt(document.getElementById(\"radius\").value); const layer1Vectors = [ parseFloat(document.getElementById(\"layer1-lv1x\").value), parseFloat(document.getElementById(\"layer1-lv1y\").value), parseFloat(document.getElementById(\"layer1-lv2x\").value), parseFloat(document.getElementById(\"layer1-lv2y\").value) ]; const layer2Vectors = [ parseFloat(document.getElementById(\"layer2-lv1x\").value), parseFloat(document.getElementById(\"layer2-lv1y\").value), parseFloat(document.getElementById(\"layer2-lv2x\").value), parseFloat(document.getElementById(\"layer2-lv2y\").value) ]; const precision = parseInt(document.getElementById(\"precision\").value); // console.log(radius, layer1Vectors, layer2Vectors); const results = find_values(radius, layer1Vectors, layer2Vectors, tol=precision); console.log(results); console.log(\"Number of results:\", results.length); displayResults_(results); } function calc_indices(p, lv1, lv2) { const [a, b] = lv1; const [c, d] = lv2; const [x, y] = p; const det = (a * d - b * c); const nx = (d * x - c * y) / det; const ny = (a * y - b * x) / det; if (Math.abs(Math.round(nx) - nx) > 1e-5 || Math.abs(Math.round(ny) - ny) > 1e-5) { throw new Error(`Calculation error for indices: ${nx}, ${ny}`); } return [Math.round(nx), Math.round(ny)]; } function generate_lattice_points(lv1, lv2, radius) { const points = []; const maxGridSize = Math.floor(radius / Math.abs(lv2[1])) + 5; // console.log(radius, lv1, lv2, maxGridSize); for (let i = -maxGridSize; i <= maxGridSize; i++) { for (let j = -maxGridSize; j <= maxGridSize; j++) { // console.log(i, j); const point = [i * lv1[0] + j * lv2[0], i * lv1[1] + j * lv2[1]]; const dist = Math.sqrt(point[0] ** 2 + point[1] ** 2); if (dist <= radius) points.push(point); } } return points; } function angle_from_x(p) { return Math.atan2(p[1], p[0]) * 180 / Math.PI; } function process_lattice(points, tol) { const distances = points.map(p => Math.hypot(p[0], p[1])); const distMap = new Map(); // console.log(distMap); for (let i = 0; i < points.length; i++) { const d = parseFloat(distances[i].toFixed(tol)); if (!distMap.has(d)) distMap.set(d, {}); distMap.get(d)[i] = points[i]; } return [distMap, new Set([...distMap.keys()])]; } function find_values(radius, layer1Vectors, layer2Vectors, tol = 6) { const [a1x, a1y, b1x, b1y] = layer1Vectors; const [a2x, a2y, b2x, b2y] = layer2Vectors; if (JSON.stringify(layer1Vectors) !== JSON.stringify(layer2Vectors)) { alert(\"Warning: Vectors are not identical! Results might be inaccurate or meaningless.\"); } const lv1 = [a1x, a1y]; const lv2 = [b1x, b1y]; const lattice1 = generate_lattice_points(lv1, lv2, radius); const lattice2 = generate_lattice_points(lv1, lv2, radius); const [dict1, dist_set1] = process_lattice(lattice1, tol); const [dict2, dist_set2] = process_lattice(lattice2, tol); const common_dists = [...dist_set1].filter(d => dist_set2.has(d)).sort((a, b) => a - b).slice(1); const angle_dict = {}; const lattice_angle = angle_from_x(lv2) - angle_from_x(lv1); const isValidTheta = (theta) => theta > 0 && theta < lattice_angle; for (const d of common_dists) { // console.log(d) const pts1 = Object.values(dict1.get(d)).filter(p => isValidTheta(angle_from_x(p))); const pts2 = Object.values(dict2.get(d)).filter(p => isValidTheta(angle_from_x(p))); for (const p1 of pts1) { const theta1 = parseFloat(angle_from_x(p1).toFixed(tol)); for (const p2 of pts2) { const theta2 = parseFloat(angle_from_x(p2)); const angle = parseFloat((theta2 - theta1)); // use cos theta square between p1 and p2 as uid const uid = angleId(p1, p2); if ( theta2 <= theta1 || angle < Math.pow(10, -tol) || uid in angle_dict ) continue; angle_dict[uid] = [p1, p2, angle]; } } } const results = Object.entries(angle_dict) .sort(([, a], [, b]) => parseFloat(a[2]) - parseFloat(b[2])) // ascending by angle .map(([k, [p1, p2, angle]]) => { const thetaRad = (parseFloat(angle) * Math.PI) / 180; const thetaDeg = parseFloat(angle); const [i1, j1] = calc_indices(p1, lv1, lv2); const [i2, j2] = calc_indices(p2, lv1, lv2); const num_pts = 2*(p1[0] * p1[0] + p1[1] * p1[1]) * 1; // 1 for one point per unit cell return [thetaDeg.toFixed(tol), thetaRad.toFixed(tol), i2, j2, i1, j1, num_pts]; }); return results; } function displayResults_(results) { const resultsBody = document.getElementById(\"results-body\"); resultsBody.innerHTML = \"\"; // Clear previous results results.forEach((tuple, index) => { const row = document.createElement(\"tr\"); const cell = document.createElement(\"td\"); cell.textContent = index + 1; // add the index row.appendChild(cell); tuple.forEach(value => { const cell = document.createElement(\"td\"); cell.textContent = value; row.appendChild(cell); }); resultsBody.appendChild(row); }); } updateLatticeVectors('layer1'); updateLatticeVectors('layer2');","title":"Calculator"},{"location":"theory/search_algorithm_kdtree/","text":"Searching Algorithm & KDTree","title":"Searching Algorithm & KDTree"},{"location":"theory/search_algorithm_kdtree/#searching-algorithm-kdtree","text":"","title":"Searching Algorithm &amp; KDTree"},{"location":"theory/theory_intro/","text":"Theoretical Background The discovery that twisting two atomically-thin layers, like graphene, by a small angle can induce superconductivity and other correlated phases has transformed condensed matter physics. At the heart of this transformation lies the moir\u00e9 pattern : a long-wavelength lattice emerging from the interference of two periodic structures. These patterns reshape the electronic landscape, giving rise to flat bands, topological states, and strong interaction effects absent in the individual layers. Simulating such systems demands a careful balance between atomistic resolution and large-scale periodicity . Full ab-initio methods become computationally infeasible at moir\u00e9 scales, while naive tight-binding models often miss crucial geometrical and symmetry constraints. MoirePy is designed to bridge this gap, converting clean geometric input into efficient, flexible, and physically grounded tight-binding models for commensurate moir\u00e9 lattices. Purpose of This Section This section documents the theoretical models and computational strategies implemented in MoirePy. From the construction of tight-binding Hamiltonians and their real- and \\(k\\) -space formulations , to geometry-based neighbor search algorithms and quantized twist-angle calculations , we outline the core principles underlying the package. We believe in transparent scientific software , and this section is written not just for end users, but also for researchers and developers who want to understand, modify, or build upon MoirePy. Whether you're reviewing our assumptions, adapting our algorithms, or simply learning the methods behind moir\u00e9 modeling, these notes aim to make the theoretical foundations as clear and open as possible.","title":"Theoretical Background"},{"location":"theory/theory_intro/#theoretical-background","text":"The discovery that twisting two atomically-thin layers, like graphene, by a small angle can induce superconductivity and other correlated phases has transformed condensed matter physics. At the heart of this transformation lies the moir\u00e9 pattern : a long-wavelength lattice emerging from the interference of two periodic structures. These patterns reshape the electronic landscape, giving rise to flat bands, topological states, and strong interaction effects absent in the individual layers. Simulating such systems demands a careful balance between atomistic resolution and large-scale periodicity . Full ab-initio methods become computationally infeasible at moir\u00e9 scales, while naive tight-binding models often miss crucial geometrical and symmetry constraints. MoirePy is designed to bridge this gap, converting clean geometric input into efficient, flexible, and physically grounded tight-binding models for commensurate moir\u00e9 lattices.","title":"Theoretical Background"},{"location":"theory/theory_intro/#purpose-of-this-section","text":"This section documents the theoretical models and computational strategies implemented in MoirePy. From the construction of tight-binding Hamiltonians and their real- and \\(k\\) -space formulations , to geometry-based neighbor search algorithms and quantized twist-angle calculations , we outline the core principles underlying the package. We believe in transparent scientific software , and this section is written not just for end users, but also for researchers and developers who want to understand, modify, or build upon MoirePy. Whether you're reviewing our assumptions, adapting our algorithms, or simply learning the methods behind moir\u00e9 modeling, these notes aim to make the theoretical foundations as clear and open as possible.","title":"Purpose of This Section"},{"location":"theory/tight_binding_ham/","text":"Tight Binding Moir\u00e9 Hamiltonian Construction The tight-binding Hamiltonian 1 is a widely used model in solid-state physics and quantum chemistry to describe the electronic structure of solids, specially in crystals and layered materials. In this model, electrons are considered localized around atomic sites but can hop to neighbouring atoms. To describe such a Hamiltonian for a Moir\u00e9 system , we use the second quantized 2 form: \\[ H = \\sum_{\\alpha, \\beta;\\, r,r' \\in L} t^1_{rr', \\alpha\\beta}c^{\\dagger}_{r,\\beta}c_{r',\\alpha} + \\sum_{\\alpha, \\beta;\\, r,r' \\in U} t^2_{rr', \\alpha\\beta}d^{\\dagger}_{r,\\beta}d_{r',\\alpha} + \\sum_{\\alpha, \\beta;\\, r,r'} t^{\\perp}_{rr', \\alpha\\beta}c^{\\dagger}_{r,\\beta}d_{r',\\alpha} + \\text{h.c.} \\] Here, \\(c^{\\dagger}_{r,\\beta}\\) and \\(c_{r',\\alpha}\\) denote the electron creation and annihilation operators at lattice sites \\(r\\) and \\(r'\\) in the lower layer ( \\(L\\) ), associated with orbitals \\(\\beta\\) and \\(\\alpha\\) , respectively. Likewise, \\(d^{\\dagger}_{r,\\beta}\\) and \\(d_{r',\\alpha}\\) are the corresponding operators in the upper layer ( \\(U\\) ). The terms \\(t^1_{rr', \\alpha\\beta}\\) and \\(t^2_{rr', \\alpha\\beta}\\) represent the intralayer hopping amplitudes , describing electron tunneling from orbital \\(\\alpha\\) at site \\(r'\\) to orbital \\(\\beta\\) at site \\(r\\) within the lower and upper layers, respectively. In the special case where \\(r = r'\\) and \\(\\alpha = \\beta\\) , these terms correspond to the on-site potential , the energy of an electron residing in a particular orbital. The interlayer coupling is described by \\(t^{\\perp}_{rr', \\alpha\\beta}\\) , which governs the hopping of an electron from orbital \\(\\alpha\\) at site \\(r'\\) in the upper layer to orbital \\(\\beta\\) at site \\(r\\) in the lower layer. For simplicity, consider only nearest-neighbour hopping with a single orbital per site ( MoirePy can handle any arbitrary number of orbital systems). In such cases, the orbital indices \\( \\alpha \\) and \\( \\beta \\) can be omitted to simplify the notation. We can define the basis as: \\[ \\Psi^{\\dagger} = (c^{\\dagger}_{1}, c^{\\dagger}_{2}, \\dots, c^{\\dagger}_{n}, d^{\\dagger}_{1}, d^{\\dagger}_{2}, \\dots, d^{\\dagger}_{n}) \\] Here, \\( c^{\\dagger}_{i} \\) ( \\( d^{\\dagger}_{i} \\) ) is the creation operator at site \\( i \\) in the lower (upper) layer. Then, the Hamiltonian takes the block matrix form: \\[ H = \\Psi^{\\dagger} \\begin{pmatrix} h_{LL} & h_{LU} \\\\ h_{UL} & h_{UU} \\end{pmatrix} \\Psi \\] Here, \\( h_{LL} \\) and \\( h_{UU} \\) are the first-quantized \\( n \\times n \\) Hamiltonians of the lower and upper layers, respectively. The blocks \\( h_{LU} \\) and \\( h_{UL} \\) represent interlayer couplings. Neil W. Ashcroft and N. David Mermin. Solid State Physics . Saunders College Publishing, 1976. \u21a9 Henrik Bruus and Karsten Flensberg. Many-Body Quantum Theory in Condensed Matter Physics: An Introduction . Oxford University Press, Oxford, 2004. \u21a9","title":"Tight Binding Formulation"},{"location":"theory/tight_binding_ham/#tight-binding-moire-hamiltonian-construction","text":"The tight-binding Hamiltonian 1 is a widely used model in solid-state physics and quantum chemistry to describe the electronic structure of solids, specially in crystals and layered materials. In this model, electrons are considered localized around atomic sites but can hop to neighbouring atoms. To describe such a Hamiltonian for a Moir\u00e9 system , we use the second quantized 2 form: \\[ H = \\sum_{\\alpha, \\beta;\\, r,r' \\in L} t^1_{rr', \\alpha\\beta}c^{\\dagger}_{r,\\beta}c_{r',\\alpha} + \\sum_{\\alpha, \\beta;\\, r,r' \\in U} t^2_{rr', \\alpha\\beta}d^{\\dagger}_{r,\\beta}d_{r',\\alpha} + \\sum_{\\alpha, \\beta;\\, r,r'} t^{\\perp}_{rr', \\alpha\\beta}c^{\\dagger}_{r,\\beta}d_{r',\\alpha} + \\text{h.c.} \\] Here, \\(c^{\\dagger}_{r,\\beta}\\) and \\(c_{r',\\alpha}\\) denote the electron creation and annihilation operators at lattice sites \\(r\\) and \\(r'\\) in the lower layer ( \\(L\\) ), associated with orbitals \\(\\beta\\) and \\(\\alpha\\) , respectively. Likewise, \\(d^{\\dagger}_{r,\\beta}\\) and \\(d_{r',\\alpha}\\) are the corresponding operators in the upper layer ( \\(U\\) ). The terms \\(t^1_{rr', \\alpha\\beta}\\) and \\(t^2_{rr', \\alpha\\beta}\\) represent the intralayer hopping amplitudes , describing electron tunneling from orbital \\(\\alpha\\) at site \\(r'\\) to orbital \\(\\beta\\) at site \\(r\\) within the lower and upper layers, respectively. In the special case where \\(r = r'\\) and \\(\\alpha = \\beta\\) , these terms correspond to the on-site potential , the energy of an electron residing in a particular orbital. The interlayer coupling is described by \\(t^{\\perp}_{rr', \\alpha\\beta}\\) , which governs the hopping of an electron from orbital \\(\\alpha\\) at site \\(r'\\) in the upper layer to orbital \\(\\beta\\) at site \\(r\\) in the lower layer. For simplicity, consider only nearest-neighbour hopping with a single orbital per site ( MoirePy can handle any arbitrary number of orbital systems). In such cases, the orbital indices \\( \\alpha \\) and \\( \\beta \\) can be omitted to simplify the notation. We can define the basis as: \\[ \\Psi^{\\dagger} = (c^{\\dagger}_{1}, c^{\\dagger}_{2}, \\dots, c^{\\dagger}_{n}, d^{\\dagger}_{1}, d^{\\dagger}_{2}, \\dots, d^{\\dagger}_{n}) \\] Here, \\( c^{\\dagger}_{i} \\) ( \\( d^{\\dagger}_{i} \\) ) is the creation operator at site \\( i \\) in the lower (upper) layer. Then, the Hamiltonian takes the block matrix form: \\[ H = \\Psi^{\\dagger} \\begin{pmatrix} h_{LL} & h_{LU} \\\\ h_{UL} & h_{UU} \\end{pmatrix} \\Psi \\] Here, \\( h_{LL} \\) and \\( h_{UU} \\) are the first-quantized \\( n \\times n \\) Hamiltonians of the lower and upper layers, respectively. The blocks \\( h_{LU} \\) and \\( h_{UL} \\) represent interlayer couplings. Neil W. Ashcroft and N. David Mermin. Solid State Physics . Saunders College Publishing, 1976. \u21a9 Henrik Bruus and Karsten Flensberg. Many-Body Quantum Theory in Condensed Matter Physics: An Introduction . Oxford University Press, Oxford, 2004. \u21a9","title":"Tight Binding Moir\u00e9 Hamiltonian Construction"}]}