<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://jabed-umar.github.io/MoirePy/angle_calculation_process/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Angle calculation process - MoirePy – Python Library for Moiré Lattice Simulation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
        <link href="../assets/style.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Angle calculation process";
        var mkdocs_page_input_path = "angle_calculation_process.md";
        var mkdocs_page_url = "/MoirePy/angle_calculation_process/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> MoirePy – Python Library for Moiré Lattice Simulation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../installation/">Installation</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../getting_started/">Getting Started</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Angle calculation process</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#1-problem-statement">1. Problem Statement</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#2-traditional-diophantine-equation-approach">2. Traditional Diophantine Equation Approach</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#time-complexity">Time Complexity</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#observations-about-lattice-structure">Observations About Lattice Structure</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#our-method">Our Method</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#algorithm-overview">Algorithm Overview</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#time-complexity_1">Time Complexity</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#calculating-the-lattice-vectors-given-the-overlapping-points">Calculating the lattice vectors given the overlapping points</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../find_theta/">Find theta</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../examples/">Learning Moire Physics Through Examples</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">API Reference</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../api/layers/">Layers</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../api/moire/">Moire</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../api/utils/">Utils</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">MoirePy – Python Library for Moiré Lattice Simulation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Angle calculation process</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/jabed-umar/MoirePy/edit/master/docs/angle_calculation_process.md">Edit on jabed-umar/MoirePy</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <style>
  .section{
    text-align: justify;
  }
</style>

<h1 id="angle-calculation-process">Angle Calculation Process</h1>
<p>When two single layers of a 2D material are stacked with a small misalignment, they produce a moiré pattern with a length scale much larger than the periodicity of either individual layer. At specific twist angles, this results in a <strong><em>commensurate moiré pattern</em></strong>—a structure where atoms from one layer align exactly with those of the other.</p>
<p>In this section, we describe how <strong>MoirePy</strong> calculates the <strong><em>commensurate rotation angles</em></strong> between two lattices confined to a bounded region. The goal is to identify angles where the lattices align periodically, producing well-ordered moiré patterns that are physically observable.</p>
<h2 id="1-problem-statement">1. Problem Statement</h2>
<p>Let lattices <span class="arithmatex">\(A\)</span> and <span class="arithmatex">\(B\)</span> be two periodic point sets in two dimensions, each defined by their respective lattice vectors.</p>
<p>We address the following geometric question:</p>
<p><strong>Given</strong> a rotation angle <span class="arithmatex">\(\theta\)</span>, <strong>does there exist</strong> a point <span class="arithmatex">\(\mathbf{p} \in A\)</span> and a point <span class="arithmatex">\(\mathbf{q} \in B\)</span> such that</p>
<div class="arithmatex">\[
\mathbf{p} = R(\theta)\mathbf{q}
\tag{1.1}
\]</div>
<p>where <span class="arithmatex">\(R(\theta)\)</span> denotes the standard rotation matrix. In 2D, this matrix is defined as:</p>
<div class="arithmatex">\[
R(\theta) =
\begin{bmatrix}
\cos\theta &amp; -\sin\theta \\
\sin\theta &amp; \cos\theta
\end{bmatrix}
\tag{1.2}
\]</div>
<p>To bound the computation, we restrict our analysis to a finite region by considering only lattice points within a circular region of radius <span class="arithmatex">\(r\)</span>. Let the truncated sets be <span class="arithmatex">\(A_r = A \cap \text{circle}(r)\)</span> and <span class="arithmatex">\(B_r = B \cap \text{circle}(r)\)</span>.</p>
<p>Our goal is to determine the set of angles <span class="arithmatex">\(\theta\)</span> (including the corresponding points) for which there exists a pair of points <span class="arithmatex">\(\mathbf{p} \in A_r\)</span> and <span class="arithmatex">\(\mathbf{q} \in B_r\)</span> satisfying Equation 1.1.</p>
<p>These angles correspond to commensurate alignments between the two lattices, yielding physically observable moiré patterns.</p>
<h2 id="2-traditional-diophantine-equation-approach">2. Traditional Diophantine Equation Approach</h2>
<p>In commensurate moiré superlattices, specific periodic points exist where atoms from the top and bottom layers align exactly. To analyze these alignments, let <span class="arithmatex">\((\vec{a}, \vec{b})\)</span> and <span class="arithmatex">\((\vec{m}, \vec{n})\)</span> denote the primitive lattice vectors of the lower and upper layers, respectively. The atomic positions in each layer are given by:</p>
<div class="arithmatex">\[
\vec{R}^1_{p,q} = a\vec{a} + b\vec{b} \quad \text{and} \quad
\vec{R}^2_{m,n} = R(\theta)(m\vec{m} + n\vec{n}), \quad a, b, m, n \in \mathbb{Z}
\]</div>
<p><img src="../images/angle_calculation_process/moire.svg" alt="Moiré Diagram" style="max-width: 100%; width: 600px; margin: auto; display: block;"></p>
<p><em><center><strong>Fig 1:</strong> Illustration of vector matching for commensurate moiré patterns. Here vectors m and n are already rotated by angle theta. </center></em></p>
<p>For a commensurate moiré superlattice to form, there must exist integers <span class="arithmatex">\(a, b, m, n\)</span> such that:</p>
<div class="arithmatex">\[\vec{R}^1_{p,q} = \vec{R}^2_{m,n}\]</div>
<p>This leads to a condition based on vector magnitudes and orientations:</p>
<div class="arithmatex">\[
\vec{a} \cdot \vec{b} = \vec{m} \cdot \vec{n} = \cos{\beta} = \frac{m^2 + n^2 - a^2 - b^2}{2(ab - mn)}
\tag{2.1}
\]</div>
<p>We need to find all integer quadruples (a, b, m, n) satisfying Equation 2.1. Then, the corresponding twist angle <span class="arithmatex">\(\theta\)</span> can then be computed.</p>
<p>The computation proceeds as follows. The length of the moiré lattice vector <span class="arithmatex">\(\vec{r}\)</span> connecting equivalent lattice points is:</p>
<div class="arithmatex">\[
r = |\vec{r}| = \sqrt{a^2 + b^2 + 2ab\cos\beta}
\]</div>
<p>Using the Law of Sines, we calculate the intermediate angles <span class="arithmatex">\(\alpha\)</span> and <span class="arithmatex">\(\gamma\)</span>:</p>
<div class="arithmatex">\[
\frac{b}{\sin\alpha} = \frac{r}{\sin(180^\circ - \beta)} \quad \Rightarrow \quad
\alpha = \sin^{-1}\left(\frac{b \sin\beta}{r}\right)
\tag{2.2}
\]</div>
<div class="arithmatex">\[
\frac{n}{\sin\gamma} = \frac{r}{\sin(180^\circ - \beta)} \quad \Rightarrow \quad
\gamma = \sin^{-1}\left(\frac{n \sin\beta}{r}\right)
\tag{2.3}
\]</div>
<p>The twist angle <span class="arithmatex">\(\theta\)</span> between the two layers is then:</p>
<div class="arithmatex">\[
\theta = \alpha - \gamma = \sin^{-1}\left(\frac{b \sin\beta}{r}\right) - \sin^{-1}\left(\frac{n \sin\beta}{r}\right)
\]</div>
<p>This classical Diophantine approach provides a rigorous framework for determining commensurate twist angles where the lattice vectors form periodic overlaps.</p>
<h3 id="time-complexity">Time Complexity</h3>
<p>The general approach involves iterating over all possible values of the first three variables (<span class="arithmatex">\(a\)</span>, <span class="arithmatex">\(b\)</span>, <span class="arithmatex">\(m\)</span>) and computing the fourth variable (<span class="arithmatex">\(n\)</span>) based on the condition in Equation 2.1. A valid solution exists when <span class="arithmatex">\(n\)</span> is an integer.</p>
<p>This brute-force search results in a time complexity of <span class="arithmatex">\(O(n^3)\)</span>, where <span class="arithmatex">\(n\)</span> represents the maximum value of the variables (starting from 0). For large <span class="arithmatex">\(n\)</span> (i.e., when considering dense lattice points), this cubic complexity becomes computationally prohibitive. We wanted to find a better solution.</p>
<h2 id="observations-about-lattice-structure">Observations About Lattice Structure</h2>
<p>When examining regularly spaced lattices (like triangular or square lattices), we observed several useful structural properties. As shown in Fig. 2, lattice points naturally organize into concentric circles around the origin. If we sort all points by their distance from the origin, we see distinct discrete levels forming - similar to a step function. Each level (corresponding to a specific radius) contains symmetrically arranged points. For instance, in triangular lattices, each level contains a multiple of 6 points due to the lattice's 6-fold rotational symmetry (Fig. 3). (Similarly we see in Square lattice, a multiple of 4 points per level.)</p>
<div style="display: flex; justify-content: center; gap: 20px; align-items: flex-start; flex-wrap: wrap;">

  <figure style="margin: 0; text-align: center;">
    <img src="../images/angle_calculation_process/concentric_shells.svg" alt="Concentric Lattice Points" style="max-width: 100%; width: 300px;">
    <figcaption style="margin-top: 8px; font-style: italic;"><strong>Fig 2:</strong> Lattice points reside in concentric circles</figcaption>
  </figure>

  <figure style="margin: 0; text-align: center;">
    <img src="../images/angle_calculation_process/points_per_radius.svg" alt="Number of Points per Radius Level" style="max-width: 100%; width: 300px;">
    <figcaption style="margin-top: 8px; font-style: italic;"><strong>Fig 3:</strong> Number of points in each shell is<br>a multiple of 6 (Triangle lattice)</figcaption>
  </figure>

</div>

<p>This symmetric distribution has an important consequence: when two lattices share the same radial level, we only need to align one pair of points at that level. The remaining 5 symmetric points will automatically align due to the lattice symmetry, significantly reducing the computational effort needed to find commensurate angles.</p>
<h2 id="our-method">Our Method</h2>
<p>Our approach leverages lattice geometry and symmetry rather than algebraic equations to identify commensurate rotation angles. The method operates directly on the spatial distribution of lattice points, and hence is applicable for any regular lattice structure even stacking two different ones.</p>
<h3 id="algorithm-overview">Algorithm Overview</h3>
<p>Let <span class="arithmatex">\(A_r\)</span> and <span class="arithmatex">\(B_r\)</span> be the sets of lattice points (from lattice A and B respectively) within radius <span class="arithmatex">\(r\)</span> from the origin.</p>
<ol>
<li>
<p><strong>Group points by radius</strong>:
    For each point (<span class="arithmatex">\(\mathbf{p}\)</span>) in <span class="arithmatex">\(A_r\)</span> and <span class="arithmatex">\(B_r\)</span>, compute its distance <span class="arithmatex">\(d = \|\mathbf{p}\|\)</span> from the origin.
    In each lattice, group points that lie at the same radius into <em>levels</em>.</p>
</li>
<li>
<p><strong>Identify shared levels</strong>:
    Let <span class="arithmatex">\(D = \{d \mid d \text{ occurs in both } A_r \text{ and } B_r \} \setminus \{0\}\)</span>.
    These are the radii at which both lattices have points.</p>
</li>
<li>
<p><strong>Filter by angular sector</strong>:
    For each <span class="arithmatex">\(d \in D\)</span>, consider only those points <span class="arithmatex">\(\{\mathbf{p}\} \in A_r\)</span> and <span class="arithmatex">\(\{\mathbf{q}\} \in B_r\)</span> on level <span class="arithmatex">\(d\)</span> such that</p>
<div class="arithmatex">\[
0 &lt; \angle\mathbf{p} \le \theta_\text{max}, \quad
0 &lt; \angle\mathbf{q} \le \theta_\text{max}
\]</div>
<p>where <span class="arithmatex">\(\theta_\text{max}\)</span> is the lattice's symmetry sector (e.g., <span class="arithmatex">\(60^\circ\)</span> for triangular lattices, <span class="arithmatex">\(90^\circ\)</span> for square lattices). Although till now we have discussed as if the upper lattice and lower lattice can be different, in practice we have never tested this code on different lattices. Neither do we know if those cases will yield any commensurate angles. For now, we will assume that both lattices are the same. So here when we say lattice's symmetry sector, we mean the symmetry sectors of both are same.</p>
</li>
<li>
<p><strong>Compute angle differences</strong>:
   Now we will pair points from <span class="arithmatex">\(\{\mathbf{p}\}\)</span> with <span class="arithmatex">\(\{\mathbf{q}\}\)</span> at each common level <span class="arithmatex">\(D\)</span>. For each point from <span class="arithmatex">\(\{\mathbf{p}\}\)</span>, we will pair it with every point from <span class="arithmatex">\(\{\mathbf{q}\}\)</span>. For each pair, compute the angle differences. </p>
</li>
</ol>
<p>This procedure ensures we collect unique, minimal-angle configurations that could align under rotation, constrained to the symmetry of the lattice.</p>
<details>
  <summary>Some Practical Optimizations</summary>

    <ul>
        <li>
          In <strong>Step 4</strong> after calculating the angle difference (say \(\theta\)), we keep the angle only if it is in the range \(0 < \theta < \theta_\text{max}\). Note that we exclude \(0\) because it corresponds to the trivial case where no rotation is applied, and we exclude \(\theta_\text{max}\) because it corresponds to the case where the two lattices are again perfectly aligned, as if no rotation is applied. Also we do not take angles more than \(\theta_\text{max}\) because they are equivalent to angles less than \(\theta_\text{max}\) due to periodicity.
        </li>
        <li>
          In <strong>Step 1</strong>, when using same lattice as both upper and lower layer, after grouping points that lie at the same distance from the origin, we discard those \(d\)s who just have 6 points (4 points for square lattice). This is because it will lead us to no rotation anyway. We keep only those \(d\)s which have more than 6 points (12, 18, etc. for triangular lattice; 8, 12, etc. for square lattice) where we can form pairs of points that yield non-trivial angles.
        </li>
    </ul>

</details>

<p><br></p>
<h3 id="time-complexity_1">Time Complexity</h3>
<p>If the number points is of the order <span class="arithmatex">\(O(n^2)\)</span> and they are sorted by distance, the time complexity of this part becomes <span class="arithmatex">\(O(n^2 \log n^2)\)</span>. Apart from this all other steps are multiple order smaller than this cost, hence can be ignored. That makes this algorithm much less than the <span class="arithmatex">\(O(n^3)\)</span> of the Diophantine approach and arguably more intuitive.</p>
<h3 id="calculating-the-lattice-vectors-given-the-overlapping-points">Calculating the lattice vectors given the overlapping points</h3>
<h2 id="summary">Summary</h2>
<p>We avoided solving Diophantine equations by leaning on geometry and symmetry:</p>
<ul>
<li>Points are grouped by radius</li>
<li>Only overlapping radii are considered</li>
<li>Pairwise angle differences yield the commensurate angles</li>
</ul>
<p>This makes <strong>MoirePy</strong>’s angle detection both <strong>fast and visual</strong>, and opens up room for further optimizations or generalizations.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../getting_started/" class="btn btn-neutral float-left" title="Getting Started"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../find_theta/" class="btn btn-neutral float-right" title="Find theta">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/jabed-umar/MoirePy" class="fa fa-code-fork" style="color: #fcfcfc"> jabed-umar/MoirePy</a>
        </span>
    
    
      <span><a href="../getting_started/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../find_theta/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
