<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Layers - MoirePy</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Layers";
        var mkdocs_page_input_path = "api/layers.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> MoirePy
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../installation/">Installation</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../find_theta/">Angle Value Calculator</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">API Reference</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Layers</a>
    <ul class="current">
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../moire/">Moire</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../utils/">Utils</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">MoirePy</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">API Reference</li>
      <li class="breadcrumb-item active">Layers</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <div class="doc doc-object doc-module">



<a id="moirepy.layers"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="moirepy.layers.Layer" class="doc doc-heading">
            <code>Layer</code>


</h2>


    <div class="doc doc-contents ">







              <details class="quote">
                <summary>Source code in <code>moirepy/layers.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Layer</span><span class="p">:</span>  <span class="c1"># parent class</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">study_proximity</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the Layer object</span>

<span class="sd">        Args:</span>
<span class="sd">            pbc (bool): Flag to indicate if periodic boundary conditions</span>
<span class="sd">                (PBC) are applied. Defaults to False.</span>
<span class="sd">            study_proximity (int): Scaling factor for proximity calculations,</span>
<span class="sd">                **enabiling** the number of nearest neighbors. This is the upper</span>
<span class="sd">                bound for the number of nearest neighbours you will be calculating</span>
<span class="sd">                throughout the code. If you try to calculate higher order neighbours,</span>
<span class="sd">                it might lead to errors, or worse give wrong answers without complaining.</span>
<span class="sd">                Defaults to 1.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `lv1` is not along the x-axis</span>
<span class="sd">                or if `lv2` has a negative y-component.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        layer = Layer(pbc=True, study_proximity=2)</span>
<span class="sd">        Create a Layer object with PBC and study of second nearest neighbours</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;lv1 was expected to be along the x-axis,</span>
<span class="sd">                and lv2 should have a +ve y component</span>
<span class="sd">                Please refer to the documentation for more information: https://example.com</span>
<span class="sd">                &quot;&quot;&quot;</span>  <span class="c1"># @jabed add link to documentation we will write this</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rot_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span> <span class="o">=</span> <span class="n">study_proximity</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">perform_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rot</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates the lattice layer and its components by a specified angle.</span>

<span class="sd">        Args:</span>
<span class="sd">            rot (float): The rotation angle in radians. Default to `None`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: The function modifies the rotation matrix</span>
<span class="sd">            and updates the lattice points and neighbors in place.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        layer.perform_rotation(np.pi/4)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot_m</span> <span class="o">=</span> <span class="n">get_rotation_matrix</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rot_m</span> <span class="o">=</span> <span class="n">rot_m</span>

        <span class="c1"># Rotate lv1 and lv2 vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span> <span class="o">=</span> <span class="n">rot_m</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span> <span class="o">=</span> <span class="n">rot_m</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span>

        <span class="c1"># Rotate lattice_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="o">*</span><span class="p">(</span><span class="n">rot_m</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])),</span> <span class="n">atom_type</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">atom_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span>
        <span class="p">]</span>

        <span class="c1"># Rotate neighbours</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">atom_type</span><span class="p">:</span> <span class="p">[</span><span class="n">rot_m</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">neighbour_list</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">atom_type</span><span class="p">,</span> <span class="n">neighbour_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_points</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">mlv1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
            <span class="n">mlv2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
            <span class="n">mln1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">mln2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># bring_to_center = False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates points for a Moiré lattice based on the given lattice</span>
<span class="sd">        vectors and the number of unit cells along each direction.</span>

<span class="sd">        Args:</span>
<span class="sd">            mlv1 (np.array): The first Moiré lattice vector.</span>
<span class="sd">            mlv2 (np.array): The second Moiré lattice vector.</span>
<span class="sd">            mln1 (int, optional): The number of Moiré unit cells</span>
<span class="sd">                along the first lattice vector. Defaults to 1.</span>
<span class="sd">            mln2 (int, optional): The number of Moiré unit</span>
<span class="sd">                cells along the second lattice vector. Defaults to 1.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: The function modifies the object state and</span>
<span class="sd">            stores the generated points and their types.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the number of unit cells is non-positive.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        lattice = MoireLattice()</span>
<span class="sd">        lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=3, mln2=2)</span>
<span class="sd">        print(lattice.points)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">=</span> <span class="n">mlv1</span>  <span class="c1"># Moire lattice vector 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span> <span class="o">=</span> <span class="n">mlv2</span>  <span class="c1"># Moire lattice vector 2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">=</span> <span class="n">mln1</span>  <span class="c1"># Number of moire unit cells along mlv1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">=</span> <span class="n">mln2</span>  <span class="c1"># Number of moire unit cells along mlv2</span>

        <span class="c1"># Step 1: Find the maximum distance to determine the grid resolution</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">mlv1</span><span class="p">,</span> <span class="n">mlv2</span><span class="p">,</span> <span class="n">mlv1</span> <span class="o">+</span> <span class="n">mlv2</span><span class="p">]</span>
        <span class="n">max_distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
        <span class="p">)</span>

        <span class="c1"># Calculate number of grid points based on maximum distance and lattice vectors</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_distance</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="c1"># print(f&quot;Calculated grid size: {n}&quot;)</span>

        <span class="c1"># Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`)</span>
        <span class="n">step1_points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold points inside the unit cell</span>
        <span class="n">step1_names</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold the names of the points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Iterate along mlv1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Iterate along mlv2</span>
                <span class="c1"># Calculate the lattice point inside the unit cell</span>
                <span class="n">point_o</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span>
                <span class="k">for</span> <span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="p">:</span>
                    <span class="n">point</span> <span class="o">=</span> <span class="n">point_o</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span><span class="p">])</span>
                    <span class="n">step1_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                    <span class="n">step1_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">step1_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">step1_points</span><span class="p">)</span>
        <span class="n">step1_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">step1_names</span><span class="p">)</span>

        <span class="c1"># Apply the boundary check method (inside_boundaries) to filter the points</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_boundaries</span><span class="p">(</span><span class="n">step1_points</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">step1_points</span> <span class="o">=</span> <span class="n">step1_points</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">step1_names</span> <span class="o">=</span> <span class="n">step1_names</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># Step 3: Copy and translate the unit cell to create the full moire pattern</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold all the moire points</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mln1</span><span class="p">):</span>  <span class="c1"># Translate along mlv1 direction</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mln2</span><span class="p">):</span>  <span class="c1"># Translate along mlv2 direction</span>
                <span class="n">translation_vector</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">mlv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">mlv2</span>
                <span class="n">translated_points</span> <span class="o">=</span> <span class="n">step1_points</span> <span class="o">+</span> <span class="n">translation_vector</span>  <span class="c1"># Translate points</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">translated_points</span><span class="p">)</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step1_names</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="c1"># print(f&quot;{self.point_types.shape=}, {self.points.shape=}&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_kdtree</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_point_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the position of each point relative to a parallelogram defined by vectors A and B.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray): Array of points to be analyzed.</span>
<span class="sd">            A (np.ndarray): The first vector of the parallelogram.</span>
<span class="sd">            B (np.ndarray): The second vector of the parallelogram.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array indicating the position of each point:</span>
<span class="sd">                - (0, 0) for points inside the parallelogram.</span>
<span class="sd">                - (-1, 1) or (1, -1) for points outside on specific sides.</span>
<span class="sd">                left side and right side will give -1 and 1 respectively</span>
<span class="sd">                top side and bottom side will give -1 and 1 respectively</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        points = np.array([[0, 0], [1, 1], [-1, -1]])</span>
<span class="sd">        A = np.array([1, 0])</span>
<span class="sd">        B = np.array([0, 1])</span>
<span class="sd">        positions = _point_positions(points, A, B)</span>
<span class="sd">        print(positions)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute determinants for positions relative to OA and BC</span>
        <span class="n">det_OA</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
        <span class="n">det_BC</span> <span class="o">=</span> <span class="p">((</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
        <span class="n">position_y</span> <span class="o">=</span> <span class="n">det_OA</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="n">det_BC</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Compute determinants for positions relative to OB and AC</span>
        <span class="n">det_OB</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
        <span class="n">det_AC</span> <span class="o">=</span> <span class="p">((</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
        <span class="n">position_x</span> <span class="o">=</span> <span class="n">det_OB</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="n">det_AC</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">position_x</span><span class="p">,</span> <span class="n">position_y</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inside_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if each point is inside a polygon using the ray-casting method.</span>


<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray): Array of points to check.</span>
<span class="sd">            polygon (np.ndarray): Vertices of the polygon to</span>
<span class="sd">                test against, in counterclockwise order.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A boolean array where True indicates</span>
<span class="sd">                that the point is inside the polygon.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        points = np.array([[0.5, 0.5], [1, 1], [-1, -1]])</span>
<span class="sd">        polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])</span>
<span class="sd">        inside = _inside_polygon(points, polygon)</span>
<span class="sd">        print(inside)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">px_next</span><span class="p">,</span> <span class="n">py_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">edge_cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="n">py_next</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="n">py_next</span><span class="p">))</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">xinters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">py</span> <span class="o">!=</span> <span class="n">py_next</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">py</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">px_next</span> <span class="o">-</span> <span class="n">px</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">py_next</span> <span class="o">-</span> <span class="n">py</span><span class="p">)</span> <span class="o">+</span> <span class="n">px</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">ray_crosses</span> <span class="o">=</span> <span class="n">edge_cond</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xinters</span><span class="p">)</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ray_crosses</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">inside</span>  <span class="c1"># mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inside_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mln1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mln2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if the given points lie within the boundaries of the Moiré lattice pattern.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray): Array of points to check.</span>
<span class="sd">            mln1 (int, optional): The number of unit cells along the first direction.</span>
<span class="sd">                Defaults to the object&#39;s current value.</span>
<span class="sd">            mln2 (int, optional): The number of unit cells along the second direction.</span>
<span class="sd">                Defaults to the object&#39;s current value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A boolean array where True indicates that</span>
<span class="sd">                the point is within the boundaries of the lattice.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the points array has an invalid shape.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        points = np.array([[0.5, 0.5], [2, 2], [-1, -1]])</span>
<span class="sd">        lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3)</span>
<span class="sd">        print(lattice_boundaries)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="p">(</span><span class="n">mln1</span> <span class="k">if</span> <span class="n">mln1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="p">(</span><span class="n">mln2</span> <span class="k">if</span> <span class="n">mln2</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">p3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">p4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_polygon</span><span class="p">(</span>
            <span class="n">points</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">p3</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-4</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_kdtree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a KDTree for spatial queries of points in the Moiré lattice.</span>
<span class="sd">        If PBC is enabled, additional points outside the primary unit cell are</span>
<span class="sd">        considered for accurate queries (same numbers of neigbours for all atoms).</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: The function modifies the object state by generating</span>
<span class="sd">                a KDTree for spatial queries.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the points in the lattice are not defined.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        lattice = MoireLattice()</span>
<span class="sd">        lattice.generate_kdtree()</span>
<span class="sd">        kdtree = lattice.kdtree</span>
<span class="sd">        print(kdtree)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>  <span class="c1"># OBC is easy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># in case of periodic boundary conditions, we need to generate a bigger set of points</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_point_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">all_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">)</span>
                <span class="n">all_point_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_types</span><span class="p">)</span>

        <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
        <span class="n">all_point_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">all_point_names</span><span class="p">)</span>

        <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span>

        <span class="n">neigh_pad_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
        <span class="n">neigh_pad_2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_polygon</span><span class="p">(</span><span class="n">all_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
            <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
        <span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">all_points</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">point_names</span> <span class="o">=</span> <span class="n">all_point_names</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bigger_point_types</span> <span class="o">=</span> <span class="n">point_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="c1"># # plot the points but with colours based on the point_positions</span>
        <span class="c1"># # - point_positions = [0, 0] -&gt; black</span>
        <span class="c1"># # - point_positions = [1, 0] -&gt; red</span>
        <span class="c1"># # - do not plot the rest of the points at all</span>

        <span class="c1"># plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], &#39;k.&#39;)</span>
        <span class="c1"># plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], &#39;r.&#39;)</span>

        <span class="c1"># plt.plot(*all_points.T, &quot;ro&quot;)</span>
        <span class="c1"># plt.plot(*points.T, &quot;b.&quot;)</span>

        <span class="c1"># # parallellogram around the whole lattice</span>
        <span class="c1"># plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>

        <span class="c1"># # just plot mlv1 and mlv2 parallellogram</span>
        <span class="c1"># plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>

        <span class="c1"># plt.grid()</span>
        <span class="c1"># plt.show()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_generate_mapping</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a mapping between two sets of points (larger and smaller lattices) based on their positions</span>
<span class="sd">        and computes the distances between corresponding points. If the distance between a point in the larger lattice</span>
<span class="sd">        and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots</span>
<span class="sd">        the lattice points for visualization.</span>

<span class="sd">        This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice.</span>
<span class="sd">        It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points`</span>
<span class="sd">        and values are the corresponding indices in `self.points`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        my_lattice._generate_mapping()</span>
<span class="sd">        ```</span>
<span class="sd">        The function performs the following steps:</span>
<span class="sd">        1. Initializes an empty dictionary `self.mappings`.</span>
<span class="sd">        2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`).</span>
<span class="sd">        3. Computes the translation needed for each point based on a lattice scaling factor.</span>
<span class="sd">        4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points.</span>
<span class="sd">        5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`.</span>
<span class="sd">        6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization.</span>

<span class="sd">        Note:</span>
<span class="sd">            - The function assumes `self.points` and `self.bigger_points`</span>
<span class="sd">            are defined as numpy arrays with the coordinates of the points in the lattices.</span>
<span class="sd">            - The translations used in the function are calculated based on `mln1`, `mln2`,</span>
<span class="sd">            `mlv1`, and `mlv2`, which define the lattice scaling and vectors.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mappings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="n">translations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_positions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">translations</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span><span class="p">)</span>
            <span class="n">distance</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance </span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2"> exceeds tolerance for point </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> at location </span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s2"> with translation (</span><span class="si">{</span><span class="n">dx</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">dy</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;ko&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;k.&quot;</span><span class="p">)</span>
                <span class="c1"># plt.plot(*self.bigger_points[i], &quot;b.&quot;)</span>
                <span class="c1"># plt.plot(*point, &quot;r.&quot;)</span>
                <span class="c1"># plt.plot(*self.points[index], &quot;g.&quot;)</span>
                <span class="c1"># parallellogram around the whole lattice</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># just plot mlv1 and mlv2 parallellogram</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span>            <span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># for index, point in enumerate(self.bigger_points):</span>
                <span class="c1">#     plt.text(*point, f&quot;{index}&quot;, fontsize=6)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">distance</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

                <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FATAL ERROR: Distance </span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2"> exceeds tolerance for point </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> at location </span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mappings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

        <span class="c1"># point positions... for each point in self.point, point position is a array of length 2 (x, y)</span>
        <span class="c1"># where the elemnts are -1, 0 and 1... this is what their value mean about their position</span>
        <span class="c1"># (-1, 1) | (0, 1) | (1, 1)</span>
        <span class="c1"># -----------------------------</span>
        <span class="c1"># (-1, 0) | (0, 0) | (1, 0)</span>
        <span class="c1"># -----------------------------</span>
        <span class="c1"># (-1,-1) | (0,-1) | (1,-1)</span>
        <span class="c1"># -----------------------------</span>
        <span class="c1"># (0, 0) is our actual lattice part...</span>
        <span class="c1"># do this for all points in self.bigger_points:</span>
        <span class="c1"># all point with point_positions = (x, y) need to be translated by</span>
        <span class="c1"># (-x*self.mlv1*self.mln1 - y*self.mlv2*self.mln2) to get the corresponding point inside the lattice</span>
        <span class="c1"># then you would need to run a query on a newly kdtree of the smaller points...</span>
        <span class="c1"># to the get the index of the corresponding point inside the lattice (distance should be zero, just saying)</span>
        <span class="c1"># now we already know the index of the point in the self.bigger_points... so we can map that to the index of the point in the self.points</span>
        <span class="c1"># then we will store that in `self.mappings``</span>
        <span class="c1"># self.mapppings will be a dictionary with keys as the indices in the</span>
        <span class="c1"># self.bigger_points (unique) and values as the indices in the self.points (not unique)</span>

    <span class="c1"># def kth_nearest_neighbours(self, points, types, k = 1) -&gt; None:</span>
    <span class="c1">#     distance_matrix = self.kdtree.sparse_distance_matrix(self.kdtree, k)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">first_nearest_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">types</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the first nearest neighbors for each point in the given array.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors.</span>
<span class="sd">            types (np.ndarray): An (N,) array of types corresponding to each point in `points`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: A tuple containing:</span>
<span class="sd">                - distances_list (list): A list of lists, where each inner list contains the distances</span>
<span class="sd">                to the nearest neighbors for the corresponding point.</span>
<span class="sd">                - indices_list (list): A list of lists, where each inner list contains the indices</span>
<span class="sd">                of the nearest neighbors in `self.points`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssertionError: If `self.kdtree` is not initialized.</span>
<span class="sd">            AssertionError: If the number of points does not match the number of types.</span>
<span class="sd">            ValueError: If a point type is not defined in `self.neighbours`.</span>
<span class="sd">            ValueError: If PBC is enabled and a distance exceeds</span>
<span class="sd">            the specified tolerance.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        &gt;&gt;&gt; layer = Layer()</span>
<span class="sd">        &gt;&gt;&gt; layer.generate_kdtree()</span>
<span class="sd">        &gt;&gt;&gt; points = np.array([[0.5, 0.5], [1.0, 1.0]])</span>
<span class="sd">        &gt;&gt;&gt; types = np.array([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; distances, indices = layer.first_nearest_neighbours(points, types)</span>
<span class="sd">    ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Generate the KDTree first by calling `Layer.generate_kdtree()`.&quot;</span>
        <span class="k">assert</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Mismatch between number of points and types.&quot;</span>

        <span class="n">distances_list</span><span class="p">,</span> <span class="n">indices_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">point</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Point type &#39;</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">&#39; is not defined in self.neighbours.&quot;</span><span class="p">)</span>

            <span class="n">relative_neighbours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
            <span class="n">absolute_neighbours</span> <span class="o">=</span> <span class="n">point</span> <span class="o">+</span> <span class="n">relative_neighbours</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">absolute_neighbours</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">filtered_distances</span><span class="p">,</span> <span class="n">filtered_indices</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dist</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="mf">1e-2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance </span><span class="si">{</span><span class="n">dist</span><span class="si">}</span><span class="s2"> exceeds tolerance.&quot;</span><span class="p">)</span>
                    <span class="n">filtered_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="n">filtered_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mappings</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if dist &gt; 1e-2 * self.toll_scale:</span>
                    <span class="c1">#     raise ValueError(f&quot;Distance {dist} exceeds tolerance.&quot;)</span>
                    <span class="n">filtered_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="n">filtered_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

            <span class="n">distances_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtered_distances</span><span class="p">)</span>
            <span class="n">indices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtered_indices</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">distances_list</span><span class="p">,</span> <span class="n">indices_list</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors.</span>
<span class="sd">            k (int, optional): The number of nearest neighbors to query. Defaults to 1.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">                - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors.</span>
<span class="sd">                - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors</span>
<span class="sd">                in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssertionError: If `self.kdtree` is not initialized.</span>
<span class="sd">            RuntimeError: If PBC is enabled and the mapping process fails.</span>
<span class="sd">            RuntimeError: If there are uneven row lengths in the returned arrays due to inconsistent filtering.</span>

<span class="sd">        Behavior:</span>
<span class="sd">            - If `self.pbc` is False, the function returns the nearest neighbors as given by KDTree.</span>
<span class="sd">            - If `self.pbc` is True, the function applies `self.mappings` to remap indices according</span>
<span class="sd">            to periodic boundary conditions.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        &gt;&gt;&gt; layer = Layer()</span>
<span class="sd">        &gt;&gt;&gt; layer.generate_kdtree()</span>
<span class="sd">        &gt;&gt;&gt; points = np.array([[0.5, 0.5], [1.0, 1.0]])</span>
<span class="sd">        &gt;&gt;&gt; distances, indices = layer.query(points, k=2)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1:</span>
        <span class="c1"># - get a normal query from KDTree</span>
        <span class="c1"># - distance, index = self.kdtree.query(points, k=k)</span>
        <span class="c1"># - remove all the points farther than (1+0.1*toll_scale) * min distance</span>
        <span class="c1"># - return here just that if OBC</span>

        <span class="c1"># Step 2: it will come here if PBC is True</span>
        <span class="c1"># - for all the points map them using self.mappings</span>
        <span class="c1"># - replace the indices with the mapped indices</span>
        <span class="c1"># - return the mapped indices and distances (distance will be the same)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Generate the KDTree first by calling `Layer.generate_kdtree()`.&quot;</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># for k=1, it returns squeezed arrays... so we need to unsqueeze them</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="n">distances_list</span><span class="p">,</span> <span class="n">indices_list</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">indices</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Set minimum distance threshold</span>
            <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span><span class="p">)</span> <span class="o">*</span> <span class="n">min_distance</span>
            <span class="c1"># print(f&quot;{min_distance = }, {threshold = }&quot;)</span>

            <span class="c1"># Filter distances and indices based on thresholds</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances_list</span><span class="p">)):</span>
                <span class="k">while</span> <span class="n">distances_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">distances_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
                    <span class="n">distances_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">indices_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances_list</span><span class="p">,</span> <span class="n">indices_list</span>

        <span class="c1"># Convert lists back to numpy arrays for PBC</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distances_list</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices_list</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;FATAL ERROR: Uneven row lengths in PBC.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="c1"># Apply mappings</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">vectorized_fn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mappings</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
            <span class="n">remapped_indices</span> <span class="o">=</span> <span class="n">vectorized_fn</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;FATAL ERROR: Mapping failed during vectorization. Check if all indices are valid.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">return</span> <span class="n">distances</span><span class="p">,</span> <span class="n">remapped_indices</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">query_non_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the KDTree for the k nearest neighbors of given points, excluding the point itself.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors.</span>
<span class="sd">            k (int, optional): The number of nearest neighbors to query (excluding the point itself).</span>
<span class="sd">                Defaults to 1.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">                - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors.</span>
<span class="sd">                - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors</span>
<span class="sd">                    in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`.</span>

<span class="sd">        Behavior:</span>
<span class="sd">            - Calls `self.query(points, k=k+1)` to get `k+1` neighbors, including the point itself.</span>
<span class="sd">            - Removes the first neighbor (which is the query point itself) from both distances and indices.</span>
<span class="sd">            - If `self.pbc` is False, it processes the lists iteratively.</span>
<span class="sd">            - If `self.pbc` is True, it slices the arrays to exclude the self-point.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        &gt;&gt;&gt; layer = Layer()</span>
<span class="sd">        &gt;&gt;&gt; layer.generate_kdtree()</span>
<span class="sd">        &gt;&gt;&gt; points = np.array([[0.5, 0.5], [1.0, 1.0]])</span>
<span class="sd">        &gt;&gt;&gt; distances, indices = layer.query_non_self(points, k=2)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># return distances[:, 1:], indices[:, 1:]</span>
        <span class="k">return</span> <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">plot_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_connections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">plot_unit_cell</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the lattice points and optionally the connections between them and the unit cell structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            plot_connections (bool, optional): If True, plots the connections between nearest neighbors.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            plot_unit_cell (bool, optional): If True, overlays the unit cell grid on the lattice.</span>
<span class="sd">                Defaults to False.</span>

<span class="sd">        Behavior:</span>
<span class="sd">            - Plots all lattice points grouped by atom type.</span>
<span class="sd">            - If `plot_connections` is True, it draws dashed red lines between nearest neighbors.</span>
<span class="sd">            - If `plot_unit_cell` is True, it overlays the unit cell using the lattice vectors `lv1` and `lv2`.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        &gt;&gt;&gt; lattice = Lattice()</span>
<span class="sd">        &gt;&gt;&gt; lattice.generate_points()</span>
<span class="sd">        &gt;&gt;&gt; lattice.plot_lattice(plot_connections=True, plot_unit_cell=True)</span>
<span class="sd">        ```</span>

<span class="sd">        Visualization Details:</span>
<span class="sd">            - Lattice points are plotted as small dots.</span>
<span class="sd">            - Nearest neighbor connections (if enabled) are shown as dashed red lines.</span>
<span class="sd">            - The unit cell grid (if enabled) is displayed as dotted black lines with reduced opacity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># plt.figure(figsize=(8, 8))</span>
        <span class="k">for</span> <span class="n">atom_type</span><span class="p">,</span> <span class="n">atom_points</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">x_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">atom_points</span><span class="p">]</span>
            <span class="n">y_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">atom_points</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">plot_connections</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">atom_points</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="p">[</span><span class="n">atom_type</span><span class="p">]:</span>
                        <span class="n">connection</span> <span class="o">=</span> <span class="n">point</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">connection</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                            <span class="p">[</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">connection</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                            <span class="s2">&quot;r--&quot;</span><span class="p">,</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                        <span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_unit_cell</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># line from (lv1*0 + lv2*i) to (lv1*nx + lv2*i)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span>
                    <span class="s2">&quot;k:&quot;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># line from (lv1*i + lv2*0) to (lv1*i + lv2*ny)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">],</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">],</span>
                    <span class="s2">&quot;k:&quot;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Lattice Points&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X Coordinate&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Y Coordinate&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">study_proximity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Initializes the Layer object</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>pbc</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>Flag to indicate if periodic boundary conditions
(PBC) are applied. Defaults to False.</p>
              </div>
            </li>
            <li>
              <b><code>study_proximity</code></b>
                  (<code>int</code>, default:
                      <code>1</code>
)
              –
              <div class="doc-md-description">
                <p>Scaling factor for proximity calculations,
<strong>enabiling</strong> the number of nearest neighbors. This is the upper
bound for the number of nearest neighbours you will be calculating
throughout the code. If you try to calculate higher order neighbours,
it might lead to errors, or worse give wrong answers without complaining.
Defaults to 1.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>ValueError</code>
              –
              <div class="doc-md-description">
                <p>If <code>lv1</code> is not along the x-axis
or if <code>lv2</code> has a negative y-component.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Example:</p>
<pre><code class="language-python">layer = Layer(pbc=True, study_proximity=2)
Create a Layer object with PBC and study of second nearest neighbours
</code></pre>

            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">study_proximity</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes the Layer object</span>

<span class="sd">    Args:</span>
<span class="sd">        pbc (bool): Flag to indicate if periodic boundary conditions</span>
<span class="sd">            (PBC) are applied. Defaults to False.</span>
<span class="sd">        study_proximity (int): Scaling factor for proximity calculations,</span>
<span class="sd">            **enabiling** the number of nearest neighbors. This is the upper</span>
<span class="sd">            bound for the number of nearest neighbours you will be calculating</span>
<span class="sd">            throughout the code. If you try to calculate higher order neighbours,</span>
<span class="sd">            it might lead to errors, or worse give wrong answers without complaining.</span>
<span class="sd">            Defaults to 1.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `lv1` is not along the x-axis</span>
<span class="sd">            or if `lv2` has a negative y-component.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    layer = Layer(pbc=True, study_proximity=2)</span>
<span class="sd">    Create a Layer object with PBC and study of second nearest neighbours</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;lv1 was expected to be along the x-axis,</span>
<span class="sd">            and lv2 should have a +ve y component</span>
<span class="sd">            Please refer to the documentation for more information: https://example.com</span>
<span class="sd">            &quot;&quot;&quot;</span>  <span class="c1"># @jabed add link to documentation we will write this</span>
        <span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">rot_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span> <span class="o">=</span> <span class="n">study_proximity</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer._generate_mapping" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_generate_mapping</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Generates a mapping between two sets of points (larger and smaller lattices) based on their positions
and computes the distances between corresponding points. If the distance between a point in the larger lattice
and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a <code>ValueError</code> and plots
the lattice points for visualization.</p>
<p>This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice.
It stores the resulting mappings in the <code>self.mappings</code> dictionary, where keys are indices in <code>self.bigger_points</code>
and values are the corresponding indices in <code>self.points</code>.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>ValueError</code>
              –
              <div class="doc-md-description">
                <p>If the distance between a point and its nearest neighbor exceeds the tolerance defined by <code>self.toll_scale</code>.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Example:</p>
<pre><code class="language-python">my_lattice._generate_mapping()
</code></pre>
<p>The function performs the following steps:
1. Initializes an empty dictionary <code>self.mappings</code>.
2. Uses a KDTree to query the neighbors for each point in the larger lattice (<code>self.bigger_points</code>).
3. Computes the translation needed for each point based on a lattice scaling factor.
4. If the distance between the corresponding points exceeds the tolerance, it raises a <code>ValueError</code> and plots the points.
5. Stores the index mappings of the larger lattice points to smaller lattice points in <code>self.mappings</code>.
6. The lattice plots show the parallelograms formed by <code>mlv1</code> and <code>mlv2</code> vectors for visualization.</p>


<details class="note" open>
  <summary>Note</summary>
  <ul>
<li>The function assumes <code>self.points</code> and <code>self.bigger_points</code>
are defined as numpy arrays with the coordinates of the points in the lattices.</li>
<li>The translations used in the function are calculated based on <code>mln1</code>, <code>mln2</code>,
<code>mlv1</code>, and <code>mlv2</code>, which define the lattice scaling and vectors.</li>
</ul>
</details>
            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_generate_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a mapping between two sets of points (larger and smaller lattices) based on their positions</span>
<span class="sd">    and computes the distances between corresponding points. If the distance between a point in the larger lattice</span>
<span class="sd">    and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots</span>
<span class="sd">    the lattice points for visualization.</span>

<span class="sd">    This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice.</span>
<span class="sd">    It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points`</span>
<span class="sd">    and values are the corresponding indices in `self.points`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    my_lattice._generate_mapping()</span>
<span class="sd">    ```</span>
<span class="sd">    The function performs the following steps:</span>
<span class="sd">    1. Initializes an empty dictionary `self.mappings`.</span>
<span class="sd">    2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`).</span>
<span class="sd">    3. Computes the translation needed for each point based on a lattice scaling factor.</span>
<span class="sd">    4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points.</span>
<span class="sd">    5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`.</span>
<span class="sd">    6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization.</span>

<span class="sd">    Note:</span>
<span class="sd">        - The function assumes `self.points` and `self.bigger_points`</span>
<span class="sd">        are defined as numpy arrays with the coordinates of the points in the lattices.</span>
<span class="sd">        - The translations used in the function are calculated based on `mln1`, `mln2`,</span>
<span class="sd">        `mlv1`, and `mlv2`, which define the lattice scaling and vectors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mappings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">translations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_positions</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">translations</span><span class="p">):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span><span class="p">)</span>
        <span class="n">distance</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance </span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2"> exceeds tolerance for point </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> at location </span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s2"> with translation (</span><span class="si">{</span><span class="n">dx</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">dy</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;ko&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;k.&quot;</span><span class="p">)</span>
            <span class="c1"># plt.plot(*self.bigger_points[i], &quot;b.&quot;)</span>
            <span class="c1"># plt.plot(*point, &quot;r.&quot;)</span>
            <span class="c1"># plt.plot(*self.points[index], &quot;g.&quot;)</span>
            <span class="c1"># parallellogram around the whole lattice</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># just plot mlv1 and mlv2 parallellogram</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span>            <span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># for index, point in enumerate(self.bigger_points):</span>
            <span class="c1">#     plt.text(*point, f&quot;{index}&quot;, fontsize=6)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">distance</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FATAL ERROR: Distance </span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2"> exceeds tolerance for point </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> at location </span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mappings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer._inside_boundaries" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_inside_boundaries</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">mln1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mln2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Determines if the given points lie within the boundaries of the Moiré lattice pattern.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>points</code></b>
                  (<code><span title="numpy.ndarray">ndarray</span></code>)
              –
              <div class="doc-md-description">
                <p>Array of points to check.</p>
              </div>
            </li>
            <li>
              <b><code>mln1</code></b>
                  (<code>int</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>The number of unit cells along the first direction.
Defaults to the object's current value.</p>
              </div>
            </li>
            <li>
              <b><code>mln2</code></b>
                  (<code>int</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>The number of unit cells along the second direction.
Defaults to the object's current value.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="numpy.ndarray">ndarray</span></code>
              –
              <div class="doc-md-description">
                <p>np.ndarray: A boolean array where True indicates that
the point is within the boundaries of the lattice.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>ValueError</code>
              –
              <div class="doc-md-description">
                <p>If the points array has an invalid shape.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Example:</p>
<pre><code class="language-python">points = np.array([[0.5, 0.5], [2, 2], [-1, -1]])
lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3)
print(lattice_boundaries)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_inside_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mln1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mln2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if the given points lie within the boundaries of the Moiré lattice pattern.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): Array of points to check.</span>
<span class="sd">        mln1 (int, optional): The number of unit cells along the first direction.</span>
<span class="sd">            Defaults to the object&#39;s current value.</span>
<span class="sd">        mln2 (int, optional): The number of unit cells along the second direction.</span>
<span class="sd">            Defaults to the object&#39;s current value.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A boolean array where True indicates that</span>
<span class="sd">            the point is within the boundaries of the lattice.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the points array has an invalid shape.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    points = np.array([[0.5, 0.5], [2, 2], [-1, -1]])</span>
<span class="sd">    lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3)</span>
<span class="sd">    print(lattice_boundaries)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="p">(</span><span class="n">mln1</span> <span class="k">if</span> <span class="n">mln1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="p">(</span><span class="n">mln2</span> <span class="k">if</span> <span class="n">mln2</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span>

    <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">p4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_polygon</span><span class="p">(</span>
        <span class="n">points</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">p3</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-4</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer._inside_polygon" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_inside_polygon</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">polygon</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Determines if each point is inside a polygon using the ray-casting method.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>points</code></b>
                  (<code><span title="numpy.ndarray">ndarray</span></code>)
              –
              <div class="doc-md-description">
                <p>Array of points to check.</p>
              </div>
            </li>
            <li>
              <b><code>polygon</code></b>
                  (<code><span title="numpy.ndarray">ndarray</span></code>)
              –
              <div class="doc-md-description">
                <p>Vertices of the polygon to
test against, in counterclockwise order.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="numpy.ndarray">ndarray</span></code>
              –
              <div class="doc-md-description">
                <p>np.ndarray: A boolean array where True indicates
that the point is inside the polygon.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Example:</p>
<pre><code class="language-python">points = np.array([[0.5, 0.5], [1, 1], [-1, -1]])
polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])
inside = _inside_polygon(points, polygon)
print(inside)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_inside_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if each point is inside a polygon using the ray-casting method.</span>


<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): Array of points to check.</span>
<span class="sd">        polygon (np.ndarray): Vertices of the polygon to</span>
<span class="sd">            test against, in counterclockwise order.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A boolean array where True indicates</span>
<span class="sd">            that the point is inside the polygon.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    points = np.array([[0.5, 0.5], [1, 1], [-1, -1]])</span>
<span class="sd">    polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])</span>
<span class="sd">    inside = _inside_polygon(points, polygon)</span>
<span class="sd">    print(inside)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">px_next</span><span class="p">,</span> <span class="n">py_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">edge_cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="n">py_next</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="n">py_next</span><span class="p">))</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">xinters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">py</span> <span class="o">!=</span> <span class="n">py_next</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">py</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">px_next</span> <span class="o">-</span> <span class="n">px</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">py_next</span> <span class="o">-</span> <span class="n">py</span><span class="p">)</span> <span class="o">+</span> <span class="n">px</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">ray_crosses</span> <span class="o">=</span> <span class="n">edge_cond</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xinters</span><span class="p">)</span>
    <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ray_crosses</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">inside</span>  <span class="c1"># mask</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer._point_positions" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">_point_positions</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Determines the position of each point relative to a parallelogram defined by vectors A and B.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>points</code></b>
                  (<code><span title="numpy.ndarray">ndarray</span></code>)
              –
              <div class="doc-md-description">
                <p>Array of points to be analyzed.</p>
              </div>
            </li>
            <li>
              <b><code>A</code></b>
                  (<code><span title="numpy.ndarray">ndarray</span></code>)
              –
              <div class="doc-md-description">
                <p>The first vector of the parallelogram.</p>
              </div>
            </li>
            <li>
              <b><code>B</code></b>
                  (<code><span title="numpy.ndarray">ndarray</span></code>)
              –
              <div class="doc-md-description">
                <p>The second vector of the parallelogram.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="numpy.ndarray">ndarray</span></code>
              –
              <div class="doc-md-description">
                <p>np.ndarray: An array indicating the position of each point:
- (0, 0) for points inside the parallelogram.
- (-1, 1) or (1, -1) for points outside on specific sides.
left side and right side will give -1 and 1 respectively
top side and bottom side will give -1 and 1 respectively</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Example:</p>
<pre><code class="language-python">points = np.array([[0, 0], [1, 1], [-1, -1]])
A = np.array([1, 0])
B = np.array([0, 1])
positions = _point_positions(points, A, B)
print(positions)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">_point_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the position of each point relative to a parallelogram defined by vectors A and B.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): Array of points to be analyzed.</span>
<span class="sd">        A (np.ndarray): The first vector of the parallelogram.</span>
<span class="sd">        B (np.ndarray): The second vector of the parallelogram.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: An array indicating the position of each point:</span>
<span class="sd">            - (0, 0) for points inside the parallelogram.</span>
<span class="sd">            - (-1, 1) or (1, -1) for points outside on specific sides.</span>
<span class="sd">            left side and right side will give -1 and 1 respectively</span>
<span class="sd">            top side and bottom side will give -1 and 1 respectively</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    points = np.array([[0, 0], [1, 1], [-1, -1]])</span>
<span class="sd">    A = np.array([1, 0])</span>
<span class="sd">    B = np.array([0, 1])</span>
<span class="sd">    positions = _point_positions(points, A, B)</span>
<span class="sd">    print(positions)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute determinants for positions relative to OA and BC</span>
    <span class="n">det_OA</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
    <span class="n">det_BC</span> <span class="o">=</span> <span class="p">((</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
    <span class="n">position_y</span> <span class="o">=</span> <span class="n">det_OA</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="n">det_BC</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Compute determinants for positions relative to OB and AC</span>
    <span class="n">det_OB</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
    <span class="n">det_AC</span> <span class="o">=</span> <span class="p">((</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
    <span class="n">position_x</span> <span class="o">=</span> <span class="n">det_OB</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="n">det_AC</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">position_x</span><span class="p">,</span> <span class="n">position_y</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.first_nearest_neighbours" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">first_nearest_neighbours</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <pre><code>Finds the first nearest neighbors for each point in the given array.

Args:
    points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors.
    types (np.ndarray): An (N,) array of types corresponding to each point in `points`.

Returns:
    tuple: A tuple containing:
        - distances_list (list): A list of lists, where each inner list contains the distances
        to the nearest neighbors for the corresponding point.
        - indices_list (list): A list of lists, where each inner list contains the indices
        of the nearest neighbors in `self.points`.

Raises:
    AssertionError: If `self.kdtree` is not initialized.
    AssertionError: If the number of points does not match the number of types.
    ValueError: If a point type is not defined in `self.neighbours`.
    ValueError: If PBC is enabled and a distance exceeds
    the specified tolerance.

Example:
```python
&gt;&gt;&gt; layer = Layer()
&gt;&gt;&gt; layer.generate_kdtree()
&gt;&gt;&gt; points = np.array([[0.5, 0.5], [1.0, 1.0]])
&gt;&gt;&gt; types = np.array([0, 1])
&gt;&gt;&gt; distances, indices = layer.first_nearest_neighbours(points, types)
</code></pre>
<p>```</p>

            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">first_nearest_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">types</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the first nearest neighbors for each point in the given array.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): An (N, 2) array of N points for which to find nearest neighbors.</span>
<span class="sd">        types (np.ndarray): An (N,) array of types corresponding to each point in `points`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing:</span>
<span class="sd">            - distances_list (list): A list of lists, where each inner list contains the distances</span>
<span class="sd">            to the nearest neighbors for the corresponding point.</span>
<span class="sd">            - indices_list (list): A list of lists, where each inner list contains the indices</span>
<span class="sd">            of the nearest neighbors in `self.points`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: If `self.kdtree` is not initialized.</span>
<span class="sd">        AssertionError: If the number of points does not match the number of types.</span>
<span class="sd">        ValueError: If a point type is not defined in `self.neighbours`.</span>
<span class="sd">        ValueError: If PBC is enabled and a distance exceeds</span>
<span class="sd">        the specified tolerance.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt;&gt;&gt; layer = Layer()</span>
<span class="sd">    &gt;&gt;&gt; layer.generate_kdtree()</span>
<span class="sd">    &gt;&gt;&gt; points = np.array([[0.5, 0.5], [1.0, 1.0]])</span>
<span class="sd">    &gt;&gt;&gt; types = np.array([0, 1])</span>
<span class="sd">    &gt;&gt;&gt; distances, indices = layer.first_nearest_neighbours(points, types)</span>
<span class="sd">```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Generate the KDTree first by calling `Layer.generate_kdtree()`.&quot;</span>
    <span class="k">assert</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Mismatch between number of points and types.&quot;</span>

    <span class="n">distances_list</span><span class="p">,</span> <span class="n">indices_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">point</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Point type &#39;</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">&#39; is not defined in self.neighbours.&quot;</span><span class="p">)</span>

        <span class="n">relative_neighbours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
        <span class="n">absolute_neighbours</span> <span class="o">=</span> <span class="n">point</span> <span class="o">+</span> <span class="n">relative_neighbours</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">absolute_neighbours</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">filtered_distances</span><span class="p">,</span> <span class="n">filtered_indices</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dist</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="mf">1e-2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance </span><span class="si">{</span><span class="n">dist</span><span class="si">}</span><span class="s2"> exceeds tolerance.&quot;</span><span class="p">)</span>
                <span class="n">filtered_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                <span class="n">filtered_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mappings</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if dist &gt; 1e-2 * self.toll_scale:</span>
                <span class="c1">#     raise ValueError(f&quot;Distance {dist} exceeds tolerance.&quot;)</span>
                <span class="n">filtered_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                <span class="n">filtered_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">distances_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtered_distances</span><span class="p">)</span>
        <span class="n">indices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtered_indices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">distances_list</span><span class="p">,</span> <span class="n">indices_list</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.generate_kdtree" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">generate_kdtree</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Generates a KDTree for spatial queries of points in the Moiré lattice.
If PBC is enabled, additional points outside the primary unit cell are
considered for accurate queries (same numbers of neigbours for all atoms).</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>None</code></b>(                  <code>None</code>
)              –
              <div class="doc-md-description">
                <p>The function modifies the object state by generating
a KDTree for spatial queries.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>ValueError</code>
              –
              <div class="doc-md-description">
                <p>If the points in the lattice are not defined.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Example:</p>
<pre><code class="language-python">lattice = MoireLattice()
lattice.generate_kdtree()
kdtree = lattice.kdtree
print(kdtree)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_kdtree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a KDTree for spatial queries of points in the Moiré lattice.</span>
<span class="sd">    If PBC is enabled, additional points outside the primary unit cell are</span>
<span class="sd">    considered for accurate queries (same numbers of neigbours for all atoms).</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: The function modifies the object state by generating</span>
<span class="sd">            a KDTree for spatial queries.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the points in the lattice are not defined.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    lattice = MoireLattice()</span>
<span class="sd">    lattice.generate_kdtree()</span>
<span class="sd">    kdtree = lattice.kdtree</span>
<span class="sd">    print(kdtree)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>  <span class="c1"># OBC is easy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># in case of periodic boundary conditions, we need to generate a bigger set of points</span>
    <span class="n">all_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_point_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">all_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">)</span>
            <span class="n">all_point_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_types</span><span class="p">)</span>

    <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
    <span class="n">all_point_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">all_point_names</span><span class="p">)</span>

    <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span>

    <span class="n">neigh_pad_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
    <span class="n">neigh_pad_2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_polygon</span><span class="p">(</span><span class="n">all_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
        <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
    <span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">all_points</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">point_names</span> <span class="o">=</span> <span class="n">all_point_names</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span> <span class="o">=</span> <span class="n">points</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bigger_point_types</span> <span class="o">=</span> <span class="n">point_names</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="c1"># # plot the points but with colours based on the point_positions</span>
    <span class="c1"># # - point_positions = [0, 0] -&gt; black</span>
    <span class="c1"># # - point_positions = [1, 0] -&gt; red</span>
    <span class="c1"># # - do not plot the rest of the points at all</span>

    <span class="c1"># plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], &#39;k.&#39;)</span>
    <span class="c1"># plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], &#39;r.&#39;)</span>

    <span class="c1"># plt.plot(*all_points.T, &quot;ro&quot;)</span>
    <span class="c1"># plt.plot(*points.T, &quot;b.&quot;)</span>

    <span class="c1"># # parallellogram around the whole lattice</span>
    <span class="c1"># plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], &#39;k&#39;, linewidth=1)</span>
    <span class="c1"># plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
    <span class="c1"># plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
    <span class="c1"># plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>

    <span class="c1"># # just plot mlv1 and mlv2 parallellogram</span>
    <span class="c1"># plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], &#39;k&#39;, linewidth=1)</span>
    <span class="c1"># plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
    <span class="c1"># plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
    <span class="c1"># plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>

    <span class="c1"># plt.grid()</span>
    <span class="c1"># plt.show()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_generate_mapping</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.generate_points" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">generate_points</span><span class="p">(</span><span class="n">mlv1</span><span class="p">,</span> <span class="n">mlv2</span><span class="p">,</span> <span class="n">mln1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mln2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Generates points for a Moiré lattice based on the given lattice
vectors and the number of unit cells along each direction.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>mlv1</code></b>
                  (<code><span title="numpy.array">array</span></code>)
              –
              <div class="doc-md-description">
                <p>The first Moiré lattice vector.</p>
              </div>
            </li>
            <li>
              <b><code>mlv2</code></b>
                  (<code><span title="numpy.array">array</span></code>)
              –
              <div class="doc-md-description">
                <p>The second Moiré lattice vector.</p>
              </div>
            </li>
            <li>
              <b><code>mln1</code></b>
                  (<code>int</code>, default:
                      <code>1</code>
)
              –
              <div class="doc-md-description">
                <p>The number of Moiré unit cells
along the first lattice vector. Defaults to 1.</p>
              </div>
            </li>
            <li>
              <b><code>mln2</code></b>
                  (<code>int</code>, default:
                      <code>1</code>
)
              –
              <div class="doc-md-description">
                <p>The number of Moiré unit
cells along the second lattice vector. Defaults to 1.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>None</code></b>(                  <code>None</code>
)              –
              <div class="doc-md-description">
                <p>The function modifies the object state and</p>
              </div>
            </li>
            <li>
                  <code>None</code>
              –
              <div class="doc-md-description">
                <p>stores the generated points and their types.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>ValueError</code>
              –
              <div class="doc-md-description">
                <p>If the number of unit cells is non-positive.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Example:</p>
<pre><code class="language-python">lattice = MoireLattice()
lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=3, mln2=2)
print(lattice.points)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mlv1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">mlv2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">mln1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">mln2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># bring_to_center = False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates points for a Moiré lattice based on the given lattice</span>
<span class="sd">    vectors and the number of unit cells along each direction.</span>

<span class="sd">    Args:</span>
<span class="sd">        mlv1 (np.array): The first Moiré lattice vector.</span>
<span class="sd">        mlv2 (np.array): The second Moiré lattice vector.</span>
<span class="sd">        mln1 (int, optional): The number of Moiré unit cells</span>
<span class="sd">            along the first lattice vector. Defaults to 1.</span>
<span class="sd">        mln2 (int, optional): The number of Moiré unit</span>
<span class="sd">            cells along the second lattice vector. Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: The function modifies the object state and</span>
<span class="sd">        stores the generated points and their types.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the number of unit cells is non-positive.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    lattice = MoireLattice()</span>
<span class="sd">    lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=3, mln2=2)</span>
<span class="sd">    print(lattice.points)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">=</span> <span class="n">mlv1</span>  <span class="c1"># Moire lattice vector 1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span> <span class="o">=</span> <span class="n">mlv2</span>  <span class="c1"># Moire lattice vector 2</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">=</span> <span class="n">mln1</span>  <span class="c1"># Number of moire unit cells along mlv1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">=</span> <span class="n">mln2</span>  <span class="c1"># Number of moire unit cells along mlv2</span>

    <span class="c1"># Step 1: Find the maximum distance to determine the grid resolution</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">mlv1</span><span class="p">,</span> <span class="n">mlv2</span><span class="p">,</span> <span class="n">mlv1</span> <span class="o">+</span> <span class="n">mlv2</span><span class="p">]</span>
    <span class="n">max_distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
    <span class="p">)</span>

    <span class="c1"># Calculate number of grid points based on maximum distance and lattice vectors</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_distance</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="c1"># print(f&quot;Calculated grid size: {n}&quot;)</span>

    <span class="c1"># Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`)</span>
    <span class="n">step1_points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold points inside the unit cell</span>
    <span class="n">step1_names</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold the names of the points</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Iterate along mlv1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Iterate along mlv2</span>
            <span class="c1"># Calculate the lattice point inside the unit cell</span>
            <span class="n">point_o</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span>
            <span class="k">for</span> <span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="p">:</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">point_o</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span><span class="p">])</span>
                <span class="n">step1_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                <span class="n">step1_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">step1_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">step1_points</span><span class="p">)</span>
    <span class="n">step1_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">step1_names</span><span class="p">)</span>

    <span class="c1"># Apply the boundary check method (inside_boundaries) to filter the points</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_boundaries</span><span class="p">(</span><span class="n">step1_points</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">step1_points</span> <span class="o">=</span> <span class="n">step1_points</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">step1_names</span> <span class="o">=</span> <span class="n">step1_names</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

    <span class="c1"># Step 3: Copy and translate the unit cell to create the full moire pattern</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold all the moire points</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mln1</span><span class="p">):</span>  <span class="c1"># Translate along mlv1 direction</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mln2</span><span class="p">):</span>  <span class="c1"># Translate along mlv2 direction</span>
            <span class="n">translation_vector</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">mlv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">mlv2</span>
            <span class="n">translated_points</span> <span class="o">=</span> <span class="n">step1_points</span> <span class="o">+</span> <span class="n">translation_vector</span>  <span class="c1"># Translate points</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">translated_points</span><span class="p">)</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step1_names</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">point_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
    <span class="c1"># print(f&quot;{self.point_types.shape=}, {self.points.shape=}&quot;)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">generate_kdtree</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.perform_rotation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">perform_rotation</span><span class="p">(</span><span class="n">rot</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Rotates the lattice layer and its components by a specified angle.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>rot</code></b>
                  (<code>float</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>The rotation angle in radians. Default to <code>None</code>.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>None</code></b>(                  <code>None</code>
)              –
              <div class="doc-md-description">
                <p>The function modifies the rotation matrix</p>
              </div>
            </li>
            <li>
                  <code>None</code>
              –
              <div class="doc-md-description">
                <p>and updates the lattice points and neighbors in place.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Example:</p>
<pre><code class="language-python">layer.perform_rotation(np.pi/4)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">perform_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rot</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotates the lattice layer and its components by a specified angle.</span>

<span class="sd">    Args:</span>
<span class="sd">        rot (float): The rotation angle in radians. Default to `None`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: The function modifies the rotation matrix</span>
<span class="sd">        and updates the lattice points and neighbors in place.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    layer.perform_rotation(np.pi/4)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot_m</span> <span class="o">=</span> <span class="n">get_rotation_matrix</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">rot_m</span> <span class="o">=</span> <span class="n">rot_m</span>

    <span class="c1"># Rotate lv1 and lv2 vectors</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span> <span class="o">=</span> <span class="n">rot_m</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span> <span class="o">=</span> <span class="n">rot_m</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span>

    <span class="c1"># Rotate lattice_points</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="o">*</span><span class="p">(</span><span class="n">rot_m</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])),</span> <span class="n">atom_type</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">atom_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span>
    <span class="p">]</span>

    <span class="c1"># Rotate neighbours</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">atom_type</span><span class="p">:</span> <span class="p">[</span><span class="n">rot_m</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">neighbour_list</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">atom_type</span><span class="p">,</span> <span class="n">neighbour_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.plot_lattice" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_lattice</span><span class="p">(</span><span class="n">plot_connections</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_unit_cell</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Plots the lattice points and optionally the connections between them and the unit cell structure.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>plot_connections</code></b>
                  (<code>bool</code>, default:
                      <code>True</code>
)
              –
              <div class="doc-md-description">
                <p>If True, plots the connections between nearest neighbors.
Defaults to True.</p>
              </div>
            </li>
            <li>
              <b><code>plot_unit_cell</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>If True, overlays the unit cell grid on the lattice.
Defaults to False.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<details class="behavior" open>
  <summary>Behavior</summary>
  <ul>
<li>Plots all lattice points grouped by atom type.</li>
<li>If <code>plot_connections</code> is True, it draws dashed red lines between nearest neighbors.</li>
<li>If <code>plot_unit_cell</code> is True, it overlays the unit cell using the lattice vectors <code>lv1</code> and <code>lv2</code>.</li>
</ul>
</details>        <p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; lattice = Lattice()
&gt;&gt;&gt; lattice.generate_points()
&gt;&gt;&gt; lattice.plot_lattice(plot_connections=True, plot_unit_cell=True)
</code></pre>


<details class="visualization-details" open>
  <summary>Visualization Details</summary>
  <ul>
<li>Lattice points are plotted as small dots.</li>
<li>Nearest neighbor connections (if enabled) are shown as dashed red lines.</li>
<li>The unit cell grid (if enabled) is displayed as dotted black lines with reduced opacity.</li>
</ul>
</details>
            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">plot_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_connections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">plot_unit_cell</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the lattice points and optionally the connections between them and the unit cell structure.</span>

<span class="sd">    Args:</span>
<span class="sd">        plot_connections (bool, optional): If True, plots the connections between nearest neighbors.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        plot_unit_cell (bool, optional): If True, overlays the unit cell grid on the lattice.</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">    Behavior:</span>
<span class="sd">        - Plots all lattice points grouped by atom type.</span>
<span class="sd">        - If `plot_connections` is True, it draws dashed red lines between nearest neighbors.</span>
<span class="sd">        - If `plot_unit_cell` is True, it overlays the unit cell using the lattice vectors `lv1` and `lv2`.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt;&gt;&gt; lattice = Lattice()</span>
<span class="sd">    &gt;&gt;&gt; lattice.generate_points()</span>
<span class="sd">    &gt;&gt;&gt; lattice.plot_lattice(plot_connections=True, plot_unit_cell=True)</span>
<span class="sd">    ```</span>

<span class="sd">    Visualization Details:</span>
<span class="sd">        - Lattice points are plotted as small dots.</span>
<span class="sd">        - Nearest neighbor connections (if enabled) are shown as dashed red lines.</span>
<span class="sd">        - The unit cell grid (if enabled) is displayed as dotted black lines with reduced opacity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># plt.figure(figsize=(8, 8))</span>
    <span class="k">for</span> <span class="n">atom_type</span><span class="p">,</span> <span class="n">atom_points</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">x_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">atom_points</span><span class="p">]</span>
        <span class="n">y_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">atom_points</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_connections</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">atom_points</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="p">[</span><span class="n">atom_type</span><span class="p">]:</span>
                    <span class="n">connection</span> <span class="o">=</span> <span class="n">point</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">connection</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="p">[</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">connection</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="s2">&quot;r--&quot;</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                    <span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_unit_cell</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># line from (lv1*0 + lv2*i) to (lv1*nx + lv2*i)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span>
                <span class="s2">&quot;k:&quot;</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># line from (lv1*i + lv2*0) to (lv1*i + lv2*ny)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">],</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">],</span>
                <span class="s2">&quot;k:&quot;</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Lattice Points&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X Coordinate&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Y Coordinate&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.query" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>points</code></b>
                  (<code><span title="numpy.ndarray">ndarray</span></code>)
              –
              <div class="doc-md-description">
                <p>An (N, 2) array of points for which to find the nearest neighbors.</p>
              </div>
            </li>
            <li>
              <b><code>k</code></b>
                  (<code>int</code>, default:
                      <code>1</code>
)
              –
              <div class="doc-md-description">
                <p>The number of nearest neighbors to query. Defaults to 1.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="typing.Tuple">Tuple</span>[<span title="numpy.ndarray">ndarray</span>, <span title="numpy.ndarray">ndarray</span>]</code>
              –
              <div class="doc-md-description">
                <p>Tuple[np.ndarray, np.ndarray]:
- distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors.
- indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors
in <code>self.points</code>. If PBC is enabled, the indices are remapped using <code>self.mappings</code>.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>AssertionError</code>
              –
              <div class="doc-md-description">
                <p>If <code>self.kdtree</code> is not initialized.</p>
              </div>
            </li>
            <li>
                  <code>RuntimeError</code>
              –
              <div class="doc-md-description">
                <p>If PBC is enabled and the mapping process fails.</p>
              </div>
            </li>
            <li>
                  <code>RuntimeError</code>
              –
              <div class="doc-md-description">
                <p>If there are uneven row lengths in the returned arrays due to inconsistent filtering.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<details class="behavior" open>
  <summary>Behavior</summary>
  <ul>
<li>If <code>self.pbc</code> is False, the function returns the nearest neighbors as given by KDTree.</li>
<li>If <code>self.pbc</code> is True, the function applies <code>self.mappings</code> to remap indices according
to periodic boundary conditions.</li>
</ul>
</details>        <p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; layer = Layer()
&gt;&gt;&gt; layer.generate_kdtree()
&gt;&gt;&gt; points = np.array([[0.5, 0.5], [1.0, 1.0]])
&gt;&gt;&gt; distances, indices = layer.query(points, k=2)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Queries the KDTree for the nearest neighbors of given points and applies PBC if enabled.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors.</span>
<span class="sd">        k (int, optional): The number of nearest neighbors to query. Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors.</span>
<span class="sd">            - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors</span>
<span class="sd">            in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: If `self.kdtree` is not initialized.</span>
<span class="sd">        RuntimeError: If PBC is enabled and the mapping process fails.</span>
<span class="sd">        RuntimeError: If there are uneven row lengths in the returned arrays due to inconsistent filtering.</span>

<span class="sd">    Behavior:</span>
<span class="sd">        - If `self.pbc` is False, the function returns the nearest neighbors as given by KDTree.</span>
<span class="sd">        - If `self.pbc` is True, the function applies `self.mappings` to remap indices according</span>
<span class="sd">        to periodic boundary conditions.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt;&gt;&gt; layer = Layer()</span>
<span class="sd">    &gt;&gt;&gt; layer.generate_kdtree()</span>
<span class="sd">    &gt;&gt;&gt; points = np.array([[0.5, 0.5], [1.0, 1.0]])</span>
<span class="sd">    &gt;&gt;&gt; distances, indices = layer.query(points, k=2)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1:</span>
    <span class="c1"># - get a normal query from KDTree</span>
    <span class="c1"># - distance, index = self.kdtree.query(points, k=k)</span>
    <span class="c1"># - remove all the points farther than (1+0.1*toll_scale) * min distance</span>
    <span class="c1"># - return here just that if OBC</span>

    <span class="c1"># Step 2: it will come here if PBC is True</span>
    <span class="c1"># - for all the points map them using self.mappings</span>
    <span class="c1"># - replace the indices with the mapped indices</span>
    <span class="c1"># - return the mapped indices and distances (distance will be the same)</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Generate the KDTree first by calling `Layer.generate_kdtree()`.&quot;</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># for k=1, it returns squeezed arrays... so we need to unsqueeze them</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="n">distances_list</span><span class="p">,</span> <span class="n">indices_list</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">indices</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Set minimum distance threshold</span>
        <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span><span class="p">)</span> <span class="o">*</span> <span class="n">min_distance</span>
        <span class="c1"># print(f&quot;{min_distance = }, {threshold = }&quot;)</span>

        <span class="c1"># Filter distances and indices based on thresholds</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances_list</span><span class="p">)):</span>
            <span class="k">while</span> <span class="n">distances_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">distances_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="n">distances_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">indices_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">distances_list</span><span class="p">,</span> <span class="n">indices_list</span>

    <span class="c1"># Convert lists back to numpy arrays for PBC</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distances_list</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices_list</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;FATAL ERROR: Uneven row lengths in PBC.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

    <span class="c1"># Apply mappings</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">vectorized_fn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mappings</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
        <span class="n">remapped_indices</span> <span class="o">=</span> <span class="n">vectorized_fn</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;FATAL ERROR: Mapping failed during vectorization. Check if all indices are valid.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
    <span class="k">return</span> <span class="n">distances</span><span class="p">,</span> <span class="n">remapped_indices</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.query_non_self" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">query_non_self</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Queries the KDTree for the k nearest neighbors of given points, excluding the point itself.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>points</code></b>
                  (<code><span title="numpy.ndarray">ndarray</span></code>)
              –
              <div class="doc-md-description">
                <p>An (N, 2) array of points for which to find the nearest neighbors.</p>
              </div>
            </li>
            <li>
              <b><code>k</code></b>
                  (<code>int</code>, default:
                      <code>1</code>
)
              –
              <div class="doc-md-description">
                <p>The number of nearest neighbors to query (excluding the point itself).
Defaults to 1.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="typing.Tuple">Tuple</span>[<span title="numpy.ndarray">ndarray</span>, <span title="numpy.ndarray">ndarray</span>]</code>
              –
              <div class="doc-md-description">
                <p>Tuple[np.ndarray, np.ndarray]:
- distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors.
- indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors
    in <code>self.points</code>. If PBC is enabled, the indices are remapped using <code>self.mappings</code>.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<details class="behavior" open>
  <summary>Behavior</summary>
  <ul>
<li>Calls <code>self.query(points, k=k+1)</code> to get <code>k+1</code> neighbors, including the point itself.</li>
<li>Removes the first neighbor (which is the query point itself) from both distances and indices.</li>
<li>If <code>self.pbc</code> is False, it processes the lists iteratively.</li>
<li>If <code>self.pbc</code> is True, it slices the arrays to exclude the self-point.</li>
</ul>
</details>        <p>Example:</p>
<pre><code class="language-python">&gt;&gt;&gt; layer = Layer()
&gt;&gt;&gt; layer.generate_kdtree()
&gt;&gt;&gt; points = np.array([[0.5, 0.5], [1.0, 1.0]])
&gt;&gt;&gt; distances, indices = layer.query_non_self(points, k=2)
</code></pre>

            <details class="quote">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">query_non_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Queries the KDTree for the k nearest neighbors of given points, excluding the point itself.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): An (N, 2) array of points for which to find the nearest neighbors.</span>
<span class="sd">        k (int, optional): The number of nearest neighbors to query (excluding the point itself).</span>
<span class="sd">            Defaults to 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            - distances (np.ndarray): An (N, k) array containing the distances to the k nearest neighbors.</span>
<span class="sd">            - indices (np.ndarray): An (N, k) array containing the indices of the k nearest neighbors</span>
<span class="sd">                in `self.points`. If PBC is enabled, the indices are remapped using `self.mappings`.</span>

<span class="sd">    Behavior:</span>
<span class="sd">        - Calls `self.query(points, k=k+1)` to get `k+1` neighbors, including the point itself.</span>
<span class="sd">        - Removes the first neighbor (which is the query point itself) from both distances and indices.</span>
<span class="sd">        - If `self.pbc` is False, it processes the lists iteratively.</span>
<span class="sd">        - If `self.pbc` is True, it slices the arrays to exclude the self-point.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt;&gt;&gt; layer = Layer()</span>
<span class="sd">    &gt;&gt;&gt; layer.generate_kdtree()</span>
<span class="sd">    &gt;&gt;&gt; points = np.array([[0.5, 0.5], [1.0, 1.0]])</span>
<span class="sd">    &gt;&gt;&gt; distances, indices = layer.query_non_self(points, k=2)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># return distances[:, 1:], indices[:, 1:]</span>
    <span class="k">return</span> <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../find_theta/" class="btn btn-neutral float-left" title="Angle Value Calculator"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../moire/" class="btn btn-neutral float-right" title="Moire">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../find_theta/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../moire/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
