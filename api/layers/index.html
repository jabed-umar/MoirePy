<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://jabed-umar.github.io/MoirePy/api/layers/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Layers - MoirePy – Python Library for Moiré Lattice Simulation</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../assets/_mkdocstrings.css" rel="stylesheet" />
        <link href="../../assets/style.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Layers";
        var mkdocs_page_input_path = "api/layers.md";
        var mkdocs_page_url = "/MoirePy/api/layers/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> MoirePy – Python Library for Moiré Lattice Simulation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Getting Started</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting_started/quickstart_tbg/">Quickstart TBG in 5 Minutes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting_started/k_space_hamiltonian/">K-Space Hamiltonian Generation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting_started/obc_vs_pbc/">Simulating Lattices in Open vs. Periodic Boundary Conditions</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting_started/prepare_layers/">Defining Custom Layers</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../getting_started/custom_hoppings/">Designing Custom Hopping</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials and Benchmarks</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../examples/">Tutorials and Replicated Papers</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="../../benchmarks.md">Benchmarks and Performance Tips</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Theory</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../theory/theory_intro/">Theoretical Background</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../theory/tight_binding_ham/">Tight Binding Formulation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../theory/search_algorithm_kdtree/">Searching Algorithm & KDTree</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../theory/angle_calculation_process/">Angle Calculation Logic</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../theory/avc/">Angle Value Calculator</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">API Reference</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Layers</a>
    <ul class="current">
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../moire/">Moire</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../utils/">Utils</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">MoirePy – Python Library for Moiré Lattice Simulation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">API Reference</li>
      <li class="breadcrumb-item active">Layers</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/jabed-umar/MoirePy/edit/master/docs/api/layers.md">Edit on jabed-umar/MoirePy</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <div class="doc doc-object doc-module">



<a id="moirepy.layers"></a>
    <div class="doc doc-contents first">










<div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="moirepy.layers.Layer" class="doc doc-heading">
            <code>Layer</code>


</h2>


    <div class="doc doc-contents ">









              <details class="quote">
                <summary>Source code in <code>moirepy/layers.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Layer</span><span class="p">:</span>  <span class="c1"># parent class</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">study_proximity</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the Layer object</span>

<span class="sd">        Args:</span>
<span class="sd">            pbc (bool): Flag to indicate if periodic boundary conditions</span>
<span class="sd">                (PBC) are applied.</span>
<span class="sd">            study_proximity (int): Scaling factor for proximity calculations,</span>
<span class="sd">                **enabling** the number of nearest neighbors. This is the upper</span>
<span class="sd">                bound for the number of nearest neighbours you will be calculating</span>
<span class="sd">                throughout the code. If you try to calculate higher order neighbours,</span>
<span class="sd">                it might lead to errors, or worse give wrong answers silently.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `lv1` is not along the x-axis</span>
<span class="sd">                or if `lv2` has a negative y-component.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">required_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lv1&quot;</span><span class="p">,</span> <span class="s2">&quot;lv2&quot;</span><span class="p">,</span> <span class="s2">&quot;lattice_points&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbours&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">required_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subclass </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must define &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;lv1 was expected to be along the x-axis,</span>
<span class="sd">                and lv2 should have a +ve y component</span>
<span class="sd">                Please refer to the documentation for more information: https://jabed-umar.github.io/MoirePy/find_theta/</span>
<span class="sd">                &quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rot_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># will be replaced if called perform_rotation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span> <span class="o">=</span> <span class="n">study_proximity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">perform_rotation_translation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rot</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">translation</span><span class="p">:</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates and translates the lattice layer and its components. Has to be applied before point generation.</span>

<span class="sd">        Args:</span>
<span class="sd">            rot (float): The rotation angle in radians. Default to `None`.</span>
<span class="sd">            translation (Tuple[float, float]): The translation vector (dx, dy) for each point on the lattice.</span>
<span class="sd">                new position = old position + translation</span>
<span class="sd">                translation will be applied before the rotation</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: The function modifies the rotation matrix</span>
<span class="sd">                and updates the lattice points and neighbors in place.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        layer.perform_rotation_translation(np.pi/4, (1, 1))</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Cannot perform rotation and translation after points have been generated.&quot;</span>

        <span class="n">rot_m</span> <span class="o">=</span> <span class="n">get_rotation_matrix</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rot_m</span> <span class="o">=</span> <span class="n">rot_m</span>

        <span class="c1"># Rotate lv1 and lv2 vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span> <span class="o">=</span> <span class="n">rot_m</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span> <span class="o">=</span> <span class="n">rot_m</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span>

        <span class="c1"># Rotate lattice_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="o">*</span><span class="p">(</span><span class="n">rot_m</span> <span class="o">@</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">translation</span><span class="p">))),</span> <span class="n">point_type</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">point_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span>
        <span class="p">]</span>

        <span class="c1"># Rotate neighbours</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">point_type</span><span class="p">:</span> <span class="p">[</span><span class="n">rot_m</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">neighbour_list</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">point_type</span><span class="p">,</span> <span class="n">neighbour_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">generate_points</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">mlv1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">mlv2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">mln1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">mln2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">test</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates points for a Moiré lattice based on the given lattice</span>
<span class="sd">        vectors and the number of unit cells along each direction.</span>

<span class="sd">        Args:</span>
<span class="sd">            mlv1 (np.ndarray): The first Moiré lattice vector.</span>
<span class="sd">            mlv2 (np.ndarray): The second Moiré lattice vector.</span>
<span class="sd">            mln1 (int, optional): The number of Moiré unit cells</span>
<span class="sd">                along the first lattice vector. Defaults to 1.</span>
<span class="sd">            mln2 (int, optional): The number of Moiré unit</span>
<span class="sd">                cells along the second lattice vector. Defaults to 1.</span>
<span class="sd">            test (bool, optional): If we are generating points just for testing purpose.</span>
<span class="sd">                kdtree will not be prepared and mln1 and mln2 both need to be 1</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: The function modifies the object state and</span>
<span class="sd">            stores the generated points and their types.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssersionError: If mln1 and mln2 are not positive integers.</span>
<span class="sd">            AssersionError: if test is True and mln1 or mln2 is not 1</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        &gt;&gt;&gt; lattice = MyLattice()  # a class inheriting the Layer class</span>
<span class="sd">        &gt;&gt;&gt; lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1)</span>
<span class="sd">        &gt;&gt;&gt; print(lattice.points)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># raise the promised errors:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mln1</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mln1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;mln1 must be a positive integer.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mln2</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mln2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;mln2 must be a positive integer.&quot;</span>
        <span class="k">if</span> <span class="n">test</span><span class="p">:</span> <span class="k">assert</span> <span class="n">mln1</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">mln2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;If test is True, both mln1 and mln2 must be 1.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">=</span> <span class="n">mlv1</span>  <span class="c1"># Moire lattice vector 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span> <span class="o">=</span> <span class="n">mlv2</span>  <span class="c1"># Moire lattice vector 2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">=</span> <span class="n">mln1</span>  <span class="c1"># Number of moire unit cells along mlv1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">=</span> <span class="n">mln2</span>  <span class="c1"># Number of moire unit cells along mlv2</span>

        <span class="c1"># Step 1: Find the maximum distance to determine the number of points along each direction</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">mlv1</span><span class="p">,</span> <span class="n">mlv2</span><span class="p">,</span> <span class="n">mlv1</span> <span class="o">+</span> <span class="n">mlv2</span><span class="p">]</span>
        <span class="n">max_distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
        <span class="p">)</span>

        <span class="c1"># Calculate number of grid points based on maximum distance and lattice vectors</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_distance</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="c1"># print(f&quot;Calculated grid size: {n}&quot;)</span>

        <span class="c1"># Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`)</span>
        <span class="n">step1_points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold points inside the unit cell</span>
        <span class="n">step1_names</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold the names of the points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Iterate along mlv1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Iterate along mlv2</span>
                <span class="c1"># Calculate the lattice point inside the unit cell</span>
                <span class="n">point_o</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span>
                <span class="k">for</span> <span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="p">:</span>
                    <span class="n">point</span> <span class="o">=</span> <span class="n">point_o</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span><span class="p">])</span>
                    <span class="n">step1_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                    <span class="n">step1_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">step1_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">step1_points</span><span class="p">)</span>
        <span class="n">step1_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">step1_names</span><span class="p">)</span>

        <span class="c1"># Apply the boundary check method (inside_boundaries) to filter the points</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_boundaries</span><span class="p">(</span><span class="n">step1_points</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># generating points only inside the first cell now</span>
        <span class="n">step1_points</span> <span class="o">=</span> <span class="n">step1_points</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">step1_names</span> <span class="o">=</span> <span class="n">step1_names</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># Step 3: Copy and translate the unit cell to create the full lattice</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold all the moire points</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mln1</span><span class="p">):</span>  <span class="c1"># Translate along mlv1 direction</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mln2</span><span class="p">):</span>  <span class="c1"># Translate along mlv2 direction</span>
                <span class="n">translation_vector</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">mlv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">mlv2</span>
                <span class="n">translated_points</span> <span class="o">=</span> <span class="n">step1_points</span> <span class="o">+</span> <span class="n">translation_vector</span>  <span class="c1"># Translate points</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">translated_points</span><span class="p">)</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step1_names</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="c1"># print(f&quot;{self.point_types.shape=}, {self.points.shape=}&quot;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">test</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_kdtree</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_point_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the position of each point relative to a parallelogram defined by vectors A and B.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray): Array of points to be analyzed.</span>
<span class="sd">            A (np.ndarray): The first vector of the parallelogram.</span>
<span class="sd">            B (np.ndarray): The second vector of the parallelogram.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: An array indicating the position of each point:</span>
<span class="sd">                - (0, 0) for points inside the parallelogram.</span>
<span class="sd">                - (-1, 1) or (1, -1) for points outside on specific sides.</span>
<span class="sd">                left side and right side will give -1 and 1 respectively</span>
<span class="sd">                top side and bottom side will give -1 and 1 respectively</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute determinants for positions relative to OA and BC</span>
        <span class="n">det_OA</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
        <span class="n">det_BC</span> <span class="o">=</span> <span class="p">((</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
        <span class="n">position_y</span> <span class="o">=</span> <span class="n">det_OA</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="n">det_BC</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Compute determinants for positions relative to OB and AC</span>
        <span class="n">det_OB</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
        <span class="n">det_AC</span> <span class="o">=</span> <span class="p">((</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-2</span>
        <span class="n">position_x</span> <span class="o">=</span> <span class="n">det_OB</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">+</span> <span class="n">det_AC</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">position_x</span><span class="p">,</span> <span class="n">position_y</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inside_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if each point is inside a polygon using the ray-casting method.</span>


<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray): Array of points to check.</span>
<span class="sd">            polygon (np.ndarray): Vertices of the polygon to</span>
<span class="sd">                test against, in counterclockwise order.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A boolean array where True indicates</span>
<span class="sd">                that the point is inside the polygon.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        points = np.array([[0.5, 0.5], [1, 1], [-1, -1]])</span>
<span class="sd">        polygon = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])</span>
<span class="sd">        inside = _inside_polygon(points, polygon)</span>
<span class="sd">        print(inside)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">px_next</span><span class="p">,</span> <span class="n">py_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">edge_cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="n">py_next</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="n">py_next</span><span class="p">))</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">xinters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">py</span> <span class="o">!=</span> <span class="n">py_next</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">py</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">px_next</span> <span class="o">-</span> <span class="n">px</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">py_next</span> <span class="o">-</span> <span class="n">py</span><span class="p">)</span> <span class="o">+</span> <span class="n">px</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">ray_crosses</span> <span class="o">=</span> <span class="n">edge_cond</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xinters</span><span class="p">)</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ray_crosses</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">inside</span>  <span class="c1"># mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inside_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mln1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mln2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if the given points lie within the boundaries of the Moiré lattice pattern.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray): Array of points to check.</span>
<span class="sd">            mln1 (int, optional): The number of unit cells along the first direction.</span>
<span class="sd">                Defaults to the object&#39;s current value.</span>
<span class="sd">            mln2 (int, optional): The number of unit cells along the second direction.</span>
<span class="sd">                Defaults to the object&#39;s current value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A boolean array where True indicates that</span>
<span class="sd">                the point is within the boundaries of the lattice.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the points array has an invalid shape.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        points = np.array([[0.5, 0.5], [2, 2], [-1, -1]])</span>
<span class="sd">        lattice_boundaries = _inside_boundaries(points, mln1=3, mln2=3)</span>
<span class="sd">        print(lattice_boundaries)</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="p">(</span><span class="n">mln1</span> <span class="k">if</span> <span class="n">mln1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="p">(</span><span class="n">mln2</span> <span class="k">if</span> <span class="n">mln2</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">p3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">p4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="n">shift_dir</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">)</span>
        <span class="n">shift_dir</span> <span class="o">=</span> <span class="n">shift_dir</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">shift_dir</span><span class="p">)</span>  <span class="c1"># normalize</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">shift_dir</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-4</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_polygon</span><span class="p">(</span>
            <span class="n">points</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">p3</span><span class="p">])</span> <span class="o">+</span> <span class="n">shift</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_kdtree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a KDTree for spatial queries of points in the Moiré lattice.</span>
<span class="sd">        If PBC is enabled, additional points outside the primary unit cell are</span>
<span class="sd">        considered for accurate queries (same numbers of neigbours for all points).</span>

<span class="sd">        Returns:</span>
<span class="sd">            None: The function modifies the object state by generating</span>
<span class="sd">                a KDTree for spatial queries.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the points in the lattice are not defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>  <span class="c1"># OBC is easy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># in case of periodic boundary conditions, we need to generate a bigger set of points</span>
        <span class="n">all_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_point_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">all_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">)</span>
                <span class="n">all_point_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_types</span><span class="p">)</span>

        <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
        <span class="n">all_point_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">all_point_names</span><span class="p">)</span>

        <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span>

        <span class="n">neigh_pad_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
        <span class="n">neigh_pad_2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_polygon</span><span class="p">(</span><span class="n">all_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
            <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
        <span class="p">]))</span>
        <span class="c1"># print(mask.shape, mask.dtype)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">all_points</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">point_names</span> <span class="o">=</span> <span class="n">all_point_names</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bigger_point_types</span> <span class="o">=</span> <span class="n">point_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_generate_mapping</span><span class="p">()</span>
        <span class="c1"># # plot the points but with colours based on the point_positions</span>
        <span class="c1"># # - point_positions = [0, 0] -&gt; black</span>
        <span class="c1"># # - point_positions = [1, 0] -&gt; red</span>
        <span class="c1"># # - do not plot the rest of the points at all</span>

        <span class="c1"># plt.plot(points[point_positions[:, 0] == 0][:, 0], points[point_positions[:, 0] == 0][:, 1], &#39;k.&#39;)</span>
        <span class="c1"># plt.plot(points[point_positions[:, 0] == 1][:, 0], points[point_positions[:, 0] == 1][:, 1], &#39;r.&#39;)</span>

        <span class="c1"># plt.plot(*all_points.T, &quot;ro&quot;)</span>
        <span class="c1"># plt.plot(*points.T, &quot;b.&quot;)</span>

        <span class="c1"># # parallellogram around the whole lattice</span>
        <span class="c1"># plt.plot([0, self.mln1*self.mlv1[0]], [0, self.mln1*self.mlv1[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([0, self.mln2*self.mlv2[0]], [0, self.mln2*self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([self.mln1*self.mlv1[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln1*self.mlv1[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([self.mln2*self.mlv2[0], self.mln1*self.mlv1[0] + self.mln2*self.mlv2[0]], [self.mln2*self.mlv2[1], self.mln1*self.mlv1[1] + self.mln2*self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>

        <span class="c1"># # just plot mlv1 and mlv2 parallellogram</span>
        <span class="c1"># plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
        <span class="c1"># plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.mlv2[1], self.mlv1[1] + self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>

        <span class="c1"># plt.grid()</span>
        <span class="c1"># plt.show()</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a mapping between two sets of points (larger and smaller lattices) based on their positions</span>
<span class="sd">        and computes the distances between corresponding points. If the distance between a point in the larger lattice</span>
<span class="sd">        and its nearest neighbor in the smaller lattice exceeds a specified tolerance, it raises a `ValueError` and plots</span>
<span class="sd">        the lattice points for visualization.</span>

<span class="sd">        This function uses a KDTree to find the nearest neighbor in the smaller lattice for each point in the larger lattice.</span>
<span class="sd">        It stores the resulting mappings in the `self.mappings` dictionary, where keys are indices in `self.bigger_points`</span>
<span class="sd">        and values are the corresponding indices in `self.points`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the distance between a point and its nearest neighbor exceeds the tolerance defined by `self.toll_scale`.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        my_lattice._generate_mapping()</span>
<span class="sd">        ```</span>
<span class="sd">        The function performs the following steps:</span>
<span class="sd">        1. Initializes an empty dictionary `self.mappings`.</span>
<span class="sd">        2. Uses a KDTree to query the neighbors for each point in the larger lattice (`self.bigger_points`).</span>
<span class="sd">        3. Computes the translation needed for each point based on a lattice scaling factor.</span>
<span class="sd">        4. If the distance between the corresponding points exceeds the tolerance, it raises a `ValueError` and plots the points.</span>
<span class="sd">        5. Stores the index mappings of the larger lattice points to smaller lattice points in `self.mappings`.</span>
<span class="sd">        6. The lattice plots show the parallelograms formed by `mlv1` and `mlv2` vectors for visualization.</span>

<span class="sd">        Note:</span>
<span class="sd">            - The function assumes `self.points` and `self.bigger_points`</span>
<span class="sd">            are defined as numpy arrays with the coordinates of the points in the lattices.</span>
<span class="sd">            - The translations used in the function are calculated based on `mln1`, `mln2`,</span>
<span class="sd">            `mlv1`, and `mlv2`, which define the lattice scaling and vectors.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mappings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>  <span class="c1"># smaller set</span>
        <span class="n">translations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_positions</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">translations</span><span class="p">):</span>
            <span class="n">mapped_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span><span class="p">)</span>
            <span class="n">distance</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mapped_point</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">:</span>
                <span class="c1"># print(f&quot;Distance {distance} exceeds tolerance for {i}th point {self.bigger_points[i]} mapped at location {mapped_point} with translation ({dx}, {dy}).&quot;)</span>
                <span class="c1"># plt.plot(*self.bigger_points.T, &quot;ko&quot;, alpha=0.3)</span>
                <span class="c1"># plt.plot(*self.points.T, &quot;k.&quot;)</span>
                <span class="c1"># # plt.plot(*self.bigger_points[i], &quot;b.&quot;)</span>
                <span class="c1"># # plt.plot(*mapped_point, &quot;r.&quot;)</span>
                <span class="c1"># # plt.plot(*self.points[index], &quot;g.&quot;)</span>
                <span class="c1"># # parallellogram around the whole lattice</span>
                <span class="c1"># plt.plot([0, self.mln1 * self.mlv1[0]], [0, self.mln1 * self.mlv1[1]], &#39;k&#39;, linewidth=1)</span>
                <span class="c1"># plt.plot([0, self.mln2 * self.mlv2[0]], [0, self.mln2 * self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
                <span class="c1"># plt.plot([self.mln1 * self.mlv1[0], self.mln1 * self.mlv1[0] + self.mln2 * self.mlv2[0]], [self.mln1 * self.mlv1[1], self.mln1 * self.mlv1[1] + self.mln2 * self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
                <span class="c1"># plt.plot([self.mln2 * self.mlv2[0], self.mln1 * self.mlv1[0] + self.mln2 * self.mlv2[0]], [self.mln2 * self.mlv2[1], self.mln1 * self.mlv1[1] + self.mln2 * self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>

                <span class="c1"># # just plot mlv1 and mlv2 parallellogram</span>
                <span class="c1"># plt.plot([0, self.mlv1[0]], [0, self.mlv1[1]], &#39;k&#39;, linewidth=1)</span>
                <span class="c1"># plt.plot([0, self.mlv2[0]], [0, self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
                <span class="c1"># plt.plot([self.mlv1[0], self.mlv1[0] + self.mlv2[0]], [self.mlv1[1], self.mlv1[1] + self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
                <span class="c1"># plt.plot([self.mlv2[0], self.mlv1[0] + self.mlv2[0]], [self.            mlv2[1], self.mlv1[1] + self.mlv2[1]], &#39;k&#39;, linewidth=1)</span>
                <span class="c1"># # for index, mapped_point in enumerate(self.bigger_points):</span>
                <span class="c1"># #     plt.text(*mapped_point, f&quot;{index}&quot;, fontsize=6)</span>
                <span class="c1"># plt.gca().add_patch(plt.Circle(mapped_point, distance / 2, color=&#39;r&#39;, fill=False))</span>

                <span class="c1"># plt.grid()</span>
                <span class="c1"># plt.show()</span>

                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FATAL ERROR: Distance </span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2"> exceeds tolerance for </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">th point </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> mapped at location </span><span class="si">{</span><span class="n">mapped_point</span><span class="si">}</span><span class="s2"> with translation (</span><span class="si">{</span><span class="n">dx</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">dy</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mappings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

        <span class="c1"># point positions... for each point in self.point, point position is a array of length 2 (x, y)</span>
        <span class="c1"># where the elemnts are -1, 0 and 1... this is what their value mean about their position</span>
        <span class="c1"># (-1, 1) | (0, 1) | (1, 1)</span>
        <span class="c1"># -----------------------------</span>
        <span class="c1"># (-1, 0) | (0, 0) | (1, 0)</span>
        <span class="c1"># -----------------------------</span>
        <span class="c1"># (-1,-1) | (0,-1) | (1,-1)</span>
        <span class="c1"># -----------------------------</span>
        <span class="c1"># (0, 0) is our actual lattice part...</span>
        <span class="c1"># do this for all points in self.bigger_points:</span>
        <span class="c1"># all point with point_positions = (x, y) need to be translated by</span>
        <span class="c1"># (-x*self.mlv1*self.mln1 - y*self.mlv2*self.mln2) to get the corresponding point inside the lattice</span>
        <span class="c1"># then you would need to run a query on a newly kdtree of the smaller points...</span>
        <span class="c1"># to the get the index of the corresponding point inside the lattice (distance should be zero, just saying)</span>
        <span class="c1"># now we already know the index of the point in the self.bigger_points... so we can map that to the index of the point in the self.points</span>
        <span class="c1"># then we will store that in `self.mappings``</span>
        <span class="c1"># self.mapppings will be a dictionary with keys as the indices in the</span>
        <span class="c1"># self.bigger_points (unique) and values as the indices in the self.points (not unique)</span>

    <span class="c1"># def kth_nearest_neighbours(self, points, types, k = 1) -&gt; None:</span>
    <span class="c1">#     distance_matrix = self.kdtree.sparse_distance_matrix(self.kdtree, k)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">first_nearest_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">types</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">unique_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">types</span><span class="p">)</span>
        <span class="n">max_neighs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">unique_types</span><span class="p">)</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">bigger_indices_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="n">max_neighs</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">smaller_indices_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="n">max_neighs</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">smaller_distances_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="n">max_neighs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Pre-compute mapping array for vectorized indexing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>
            <span class="n">map_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mappings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="p">))])</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">unique_types</span><span class="p">:</span>
            <span class="c1"># 1. Mask to find all points of this specific type</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">types</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">type_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>  <span class="c1"># Shape (N_t, 2)</span>
            <span class="n">rel_neighs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>  <span class="c1"># Shape (M_t, 2)</span>
            <span class="n">n_curr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel_neighs</span><span class="p">)</span>

            <span class="c1"># 2. Vectorized meshgrid to get all absolute neighbor coordinates</span>
            <span class="c1"># absolute_coords shape: (N_t, M_t, 2)</span>
            <span class="n">absolute_coords</span> <span class="o">=</span> <span class="n">type_points</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">rel_neighs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

            <span class="c1"># 3. Bulk Query (KDTree supports multidimensional input)</span>
            <span class="c1"># distances/indices shape: (N_t, M_t)</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">absolute_coords</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># 4. Bulk Assignment</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">distances</span> <span class="o">&gt;</span> <span class="mf">1e-2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance exceeds tolerance for type </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">bigger_indices_arr</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_curr</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
                <span class="n">smaller_indices_arr</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_curr</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_arr</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bigger_indices_arr</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_curr</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
                <span class="n">smaller_indices_arr</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_curr</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>

            <span class="n">smaller_distances_arr</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:</span><span class="n">n_curr</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span>

        <span class="k">return</span> <span class="n">bigger_indices_arr</span><span class="p">,</span> <span class="n">smaller_indices_arr</span><span class="p">,</span> <span class="n">smaller_distances_arr</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_neighbors_within_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># 1. Scipy&#39;s fast radius search</span>
        <span class="c1"># Returns a list of lists: [[neighs_for_p0], [neighs_for_p1], ...]</span>
        <span class="n">indices_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span><span class="o">.</span><span class="n">query_ball_point</span><span class="p">(</span><span class="n">query_points</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>

        <span class="c1"># 2. Vectorized Flattening</span>
        <span class="c1"># Calculate counts per query point to repeat indices correctly</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">indices_list</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># query_indices: [0, 0, 0, 1, 1, ...]</span>
        <span class="n">query_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">query_points</span><span class="p">)),</span> <span class="n">counts</span><span class="p">)</span>
        <span class="c1"># tree_indices: flattened neighbor indices from the KDTree</span>
        <span class="n">tree_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">nb</span> <span class="k">for</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">indices_list</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># 3. Retrieve Coordinates</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>
            <span class="n">neighbor_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="p">[</span><span class="n">tree_indices</span><span class="p">]</span>
            <span class="c1"># REPLACEMENT FOR LAMBDA MAPPER: Direct Array Lookup</span>
            <span class="c1"># We pre-mapped these during generate_kdtree</span>
            <span class="n">map_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mappings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span><span class="p">))])</span>
            <span class="n">lattice_indices</span> <span class="o">=</span> <span class="n">map_arr</span><span class="p">[</span><span class="n">tree_indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neighbor_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">tree_indices</span><span class="p">]</span>
            <span class="n">lattice_indices</span> <span class="o">=</span> <span class="n">tree_indices</span>

        <span class="k">return</span> <span class="n">query_indices</span><span class="p">,</span> <span class="n">lattice_indices</span><span class="p">,</span> <span class="n">neighbor_coords</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">plot_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_connections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">colours</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the lattice points and optionally the connections between them and the unit cell structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            plot_connections (bool, optional): If True, plots the connections between nearest neighbors.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            colours (list, optional): List of matplotlib colours to use for different point types. </span>

<span class="sd">        Behavior:</span>
<span class="sd">            - Plots all lattice points grouped by type.</span>
<span class="sd">            - If `plot_connections` is True, it draws dashed red lines between nearest neighbors.</span>

<span class="sd">        Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        lattice = MyLattice()</span>
<span class="sd">        lattice.generate_points()</span>
<span class="sd">        lattice.plot_lattice(plot_connections=True)</span>
<span class="sd">        ```</span>

<span class="sd">        Visualization Details:</span>
<span class="sd">            - Lattice points are plotted as small dots.</span>
<span class="sd">            - Nearest neighbor connections (if enabled) are shown as dashed red lines.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colours</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">colours</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="p">)}</span>

        <span class="c1"># plt.scatter(</span>
        <span class="c1">#     [self.points[:, 0]],</span>
        <span class="c1">#     [self.points[:, 1]],</span>
        <span class="c1">#     s=10, c=np.vectorize(cols.get)(self.point_types)</span>
        <span class="c1"># )</span>

        <span class="k">if</span> <span class="n">plot_connections</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">this</span><span class="p">,</span> <span class="n">point_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_types</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">delta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="p">[</span><span class="n">point_type</span><span class="p">]:</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">this</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">this</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">this</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;k--&quot;</span><span class="p">)</span>
            <span class="c1"># a = a[:30]</span>
            <span class="c1"># print(a)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="c1"># plt.title(&quot;Lattice Points&quot;)</span>
        <span class="c1"># plt.xlabel(&quot;X Coordinate&quot;)</span>
        <span class="c1"># plt.ylabel(&quot;Y Coordinate&quot;)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Layer(</span>
<span class="s2">    lv1 = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="si">}</span><span class="s2">,</span>
<span class="s2">    lv2 = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="si">}</span><span class="s2">,</span>
<span class="s2">    lattice_points = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="si">}</span><span class="s2">,</span>
<span class="s2">    study_proximity = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span><span class="si">}</span><span class="s2">,</span>
<span class="s2">    pbc = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="si">}</span><span class="s2">,</span>
<span class="s2">)&quot;&quot;&quot;</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



<div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">study_proximity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Initializes the Layer object</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>pbc</code></b>
                  (<code><span title="bool">bool</span></code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>Flag to indicate if periodic boundary conditions
(PBC) are applied.</p>
              </div>
            </li>
            <li>
              <b><code>study_proximity</code></b>
                  (<code><span title="int">int</span></code>, default:
                      <code>1</code>
)
              –
              <div class="doc-md-description">
                <p>Scaling factor for proximity calculations,
<strong>enabling</strong> the number of nearest neighbors. This is the upper
bound for the number of nearest neighbours you will be calculating
throughout the code. If you try to calculate higher order neighbours,
it might lead to errors, or worse give wrong answers silently.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="ValueError">ValueError</span></code>
              –
              <div class="doc-md-description">
                <p>If <code>lv1</code> is not along the x-axis
or if <code>lv2</code> has a negative y-component.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="mkdocstrings-source">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">study_proximity</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes the Layer object</span>

<span class="sd">    Args:</span>
<span class="sd">        pbc (bool): Flag to indicate if periodic boundary conditions</span>
<span class="sd">            (PBC) are applied.</span>
<span class="sd">        study_proximity (int): Scaling factor for proximity calculations,</span>
<span class="sd">            **enabling** the number of nearest neighbors. This is the upper</span>
<span class="sd">            bound for the number of nearest neighbours you will be calculating</span>
<span class="sd">            throughout the code. If you try to calculate higher order neighbours,</span>
<span class="sd">            it might lead to errors, or worse give wrong answers silently.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `lv1` is not along the x-axis</span>
<span class="sd">            or if `lv2` has a negative y-component.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">required_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lv1&quot;</span><span class="p">,</span> <span class="s2">&quot;lv2&quot;</span><span class="p">,</span> <span class="s2">&quot;lattice_points&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbours&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">required_attrs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subclass </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must define &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">toll_scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;lv1 was expected to be along the x-axis,</span>
<span class="sd">            and lv2 should have a +ve y component</span>
<span class="sd">            Please refer to the documentation for more information: https://jabed-umar.github.io/MoirePy/find_theta/</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">rot_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># will be replaced if called perform_rotation</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span> <span class="o">=</span> <span class="n">study_proximity</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.generate_kdtree" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">generate_kdtree</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Generates a KDTree for spatial queries of points in the Moiré lattice.
If PBC is enabled, additional points outside the primary unit cell are
considered for accurate queries (same numbers of neigbours for all points).</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>None</code></b>(                  <code>None</code>
)              –
              <div class="doc-md-description">
                <p>The function modifies the object state by generating
a KDTree for spatial queries.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="ValueError">ValueError</span></code>
              –
              <div class="doc-md-description">
                <p>If the points in the lattice are not defined.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

            <details class="mkdocstrings-source">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_kdtree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a KDTree for spatial queries of points in the Moiré lattice.</span>
<span class="sd">    If PBC is enabled, additional points outside the primary unit cell are</span>
<span class="sd">    considered for accurate queries (same numbers of neigbours for all points).</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: The function modifies the object state by generating</span>
<span class="sd">            a KDTree for spatial queries.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the points in the lattice are not defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">:</span>  <span class="c1"># OBC is easy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># in case of periodic boundary conditions, we need to generate a bigger set of points</span>
    <span class="n">all_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_point_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">all_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span><span class="p">)</span>
            <span class="n">all_point_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_types</span><span class="p">)</span>

    <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
    <span class="n">all_point_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">all_point_names</span><span class="p">)</span>

    <span class="n">v1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span>

    <span class="n">neigh_pad_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
    <span class="n">neigh_pad_2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">study_proximity</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_polygon</span><span class="p">(</span><span class="n">all_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
        <span class="p">(</span><span class="o">-</span><span class="n">neigh_pad_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">neigh_pad_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">v2</span><span class="p">,</span>
    <span class="p">]))</span>
    <span class="c1"># print(mask.shape, mask.dtype)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">all_points</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">point_names</span> <span class="o">=</span> <span class="n">all_point_names</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bigger_points</span> <span class="o">=</span> <span class="n">points</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bigger_point_types</span> <span class="o">=</span> <span class="n">point_names</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_generate_mapping</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.generate_points" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">generate_points</span><span class="p">(</span><span class="n">mlv1</span><span class="p">,</span> <span class="n">mlv2</span><span class="p">,</span> <span class="n">mln1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mln2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Generates points for a Moiré lattice based on the given lattice
vectors and the number of unit cells along each direction.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>mlv1</code></b>
                  (<code><span title="numpy.ndarray">ndarray</span></code>)
              –
              <div class="doc-md-description">
                <p>The first Moiré lattice vector.</p>
              </div>
            </li>
            <li>
              <b><code>mlv2</code></b>
                  (<code><span title="numpy.ndarray">ndarray</span></code>)
              –
              <div class="doc-md-description">
                <p>The second Moiré lattice vector.</p>
              </div>
            </li>
            <li>
              <b><code>mln1</code></b>
                  (<code><span title="int">int</span></code>, default:
                      <code>1</code>
)
              –
              <div class="doc-md-description">
                <p>The number of Moiré unit cells
along the first lattice vector. Defaults to 1.</p>
              </div>
            </li>
            <li>
              <b><code>mln2</code></b>
                  (<code><span title="int">int</span></code>, default:
                      <code>1</code>
)
              –
              <div class="doc-md-description">
                <p>The number of Moiré unit
cells along the second lattice vector. Defaults to 1.</p>
              </div>
            </li>
            <li>
              <b><code>test</code></b>
                  (<code><span title="bool">bool</span></code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>If we are generating points just for testing purpose.
kdtree will not be prepared and mln1 and mln2 both need to be 1</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>None</code></b>(                  <code>None</code>
)              –
              <div class="doc-md-description">
                <p>The function modifies the object state and</p>
              </div>
            </li>
            <li>
                  <code>None</code>
              –
              <div class="doc-md-description">
                <p>stores the generated points and their types.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="AssersionError">AssersionError</span></code>
              –
              <div class="doc-md-description">
                <p>If mln1 and mln2 are not positive integers.</p>
              </div>
            </li>
            <li>
                  <code><span title="AssersionError">AssersionError</span></code>
              –
              <div class="doc-md-description">
                <p>if test is True and mln1 or mln2 is not 1</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Example:
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">lattice</span> <span class="o">=</span> <span class="n">MyLattice</span><span class="p">()</span>  <span class="c1"># a class inheriting the Layer class</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lattice</span><span class="o">.</span><span class="n">generate_points</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">]),</span> <span class="n">mln1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mln2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">lattice</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
</code></pre></div></p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mlv1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mlv2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mln1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">mln2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">test</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates points for a Moiré lattice based on the given lattice</span>
<span class="sd">    vectors and the number of unit cells along each direction.</span>

<span class="sd">    Args:</span>
<span class="sd">        mlv1 (np.ndarray): The first Moiré lattice vector.</span>
<span class="sd">        mlv2 (np.ndarray): The second Moiré lattice vector.</span>
<span class="sd">        mln1 (int, optional): The number of Moiré unit cells</span>
<span class="sd">            along the first lattice vector. Defaults to 1.</span>
<span class="sd">        mln2 (int, optional): The number of Moiré unit</span>
<span class="sd">            cells along the second lattice vector. Defaults to 1.</span>
<span class="sd">        test (bool, optional): If we are generating points just for testing purpose.</span>
<span class="sd">            kdtree will not be prepared and mln1 and mln2 both need to be 1</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: The function modifies the object state and</span>
<span class="sd">        stores the generated points and their types.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssersionError: If mln1 and mln2 are not positive integers.</span>
<span class="sd">        AssersionError: if test is True and mln1 or mln2 is not 1</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    &gt;&gt;&gt; lattice = MyLattice()  # a class inheriting the Layer class</span>
<span class="sd">    &gt;&gt;&gt; lattice.generate_points(np.array([1, 0]), np.array([0.5, np.sqrt(3)/2]), mln1=1, mln2=1)</span>
<span class="sd">    &gt;&gt;&gt; print(lattice.points)</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># raise the promised errors:</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mln1</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mln1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;mln1 must be a positive integer.&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mln2</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mln2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;mln2 must be a positive integer.&quot;</span>
    <span class="k">if</span> <span class="n">test</span><span class="p">:</span> <span class="k">assert</span> <span class="n">mln1</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">mln2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;If test is True, both mln1 and mln2 must be 1.&quot;</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">mlv1</span> <span class="o">=</span> <span class="n">mlv1</span>  <span class="c1"># Moire lattice vector 1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mlv2</span> <span class="o">=</span> <span class="n">mlv2</span>  <span class="c1"># Moire lattice vector 2</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mln1</span> <span class="o">=</span> <span class="n">mln1</span>  <span class="c1"># Number of moire unit cells along mlv1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mln2</span> <span class="o">=</span> <span class="n">mln2</span>  <span class="c1"># Number of moire unit cells along mlv2</span>

    <span class="c1"># Step 1: Find the maximum distance to determine the number of points along each direction</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">mlv1</span><span class="p">,</span> <span class="n">mlv2</span><span class="p">,</span> <span class="n">mlv1</span> <span class="o">+</span> <span class="n">mlv2</span><span class="p">]</span>
    <span class="n">max_distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
    <span class="p">)</span>

    <span class="c1"># Calculate number of grid points based on maximum distance and lattice vectors</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_distance</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lv2</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="c1"># print(f&quot;Calculated grid size: {n}&quot;)</span>

    <span class="c1"># Step 2: Generate points inside one moire unit cell (based on `lv1` and `lv2`)</span>
    <span class="n">step1_points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold points inside the unit cell</span>
    <span class="n">step1_names</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold the names of the points</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Iterate along mlv1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Iterate along mlv2</span>
            <span class="c1"># Calculate the lattice point inside the unit cell</span>
            <span class="n">point_o</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span>
            <span class="k">for</span> <span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="p">:</span>
                <span class="n">point</span> <span class="o">=</span> <span class="n">point_o</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xpos</span><span class="p">,</span> <span class="n">ypos</span><span class="p">])</span>
                <span class="n">step1_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                <span class="n">step1_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="n">step1_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">step1_points</span><span class="p">)</span>
    <span class="n">step1_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">step1_names</span><span class="p">)</span>

    <span class="c1"># Apply the boundary check method (inside_boundaries) to filter the points</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inside_boundaries</span><span class="p">(</span><span class="n">step1_points</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># generating points only inside the first cell now</span>
    <span class="n">step1_points</span> <span class="o">=</span> <span class="n">step1_points</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">step1_names</span> <span class="o">=</span> <span class="n">step1_names</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

    <span class="c1"># Step 3: Copy and translate the unit cell to create the full lattice</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to hold all the moire points</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mln1</span><span class="p">):</span>  <span class="c1"># Translate along mlv1 direction</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mln2</span><span class="p">):</span>  <span class="c1"># Translate along mlv2 direction</span>
            <span class="n">translation_vector</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">mlv1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">mlv2</span>
            <span class="n">translated_points</span> <span class="o">=</span> <span class="n">step1_points</span> <span class="o">+</span> <span class="n">translation_vector</span>  <span class="c1"># Translate points</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">translated_points</span><span class="p">)</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">step1_names</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">point_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
    <span class="c1"># print(f&quot;{self.point_types.shape=}, {self.points.shape=}&quot;)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">test</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_kdtree</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.perform_rotation_translation" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">perform_rotation_translation</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Rotates and translates the lattice layer and its components. Has to be applied before point generation.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>rot</code></b>
                  (<code><span title="float">float</span></code>)
              –
              <div class="doc-md-description">
                <p>The rotation angle in radians. Default to <code>None</code>.</p>
              </div>
            </li>
            <li>
              <b><code>translation</code></b>
                  (<code><span title="typing.Tuple">Tuple</span>[<span title="float">float</span>, <span title="float">float</span>]</code>, default:
                      <code>(0, 0)</code>
)
              –
              <div class="doc-md-description">
                <p>The translation vector (dx, dy) for each point on the lattice.
new position = old position + translation
translation will be applied before the rotation</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>None</code></b>(                  <code>None</code>
)              –
              <div class="doc-md-description">
                <p>The function modifies the rotation matrix
and updates the lattice points and neighbors in place.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>        <p>Example:
<div class="highlight"><pre><span></span><code><span class="n">layer</span><span class="o">.</span><span class="n">perform_rotation_translation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">perform_rotation_translation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rot</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">translation</span><span class="p">:</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotates and translates the lattice layer and its components. Has to be applied before point generation.</span>

<span class="sd">    Args:</span>
<span class="sd">        rot (float): The rotation angle in radians. Default to `None`.</span>
<span class="sd">        translation (Tuple[float, float]): The translation vector (dx, dy) for each point on the lattice.</span>
<span class="sd">            new position = old position + translation</span>
<span class="sd">            translation will be applied before the rotation</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: The function modifies the rotation matrix</span>
<span class="sd">            and updates the lattice points and neighbors in place.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    layer.perform_rotation_translation(np.pi/4, (1, 1))</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Cannot perform rotation and translation after points have been generated.&quot;</span>

    <span class="n">rot_m</span> <span class="o">=</span> <span class="n">get_rotation_matrix</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">rot_m</span> <span class="o">=</span> <span class="n">rot_m</span>

    <span class="c1"># Rotate lv1 and lv2 vectors</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span> <span class="o">=</span> <span class="n">rot_m</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span> <span class="o">=</span> <span class="n">rot_m</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">lv2</span>

    <span class="c1"># Rotate lattice_points</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="o">*</span><span class="p">(</span><span class="n">rot_m</span> <span class="o">@</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">translation</span><span class="p">))),</span> <span class="n">point_type</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">point_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span>
    <span class="p">]</span>

    <span class="c1"># Rotate neighbours</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">point_type</span><span class="p">:</span> <span class="p">[</span><span class="n">rot_m</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">neighbour_list</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">point_type</span><span class="p">,</span> <span class="n">neighbour_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="moirepy.layers.Layer.plot_lattice" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">plot_lattice</span><span class="p">(</span><span class="n">plot_connections</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">colours</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">])</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Plots the lattice points and optionally the connections between them and the unit cell structure.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>plot_connections</code></b>
                  (<code><span title="bool">bool</span></code>, default:
                      <code>True</code>
)
              –
              <div class="doc-md-description">
                <p>If True, plots the connections between nearest neighbors.
Defaults to True.</p>
              </div>
            </li>
            <li>
              <b><code>colours</code></b>
                  (<code><span title="list">list</span></code>, default:
                      <code>[&#39;r&#39;, &#39;g&#39;, &#39;b&#39;, &#39;c&#39;, &#39;m&#39;, &#39;y&#39;, &#39;k&#39;]</code>
)
              –
              <div class="doc-md-description">
                <p>List of matplotlib colours to use for different point types. </p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<details class="behavior" open>
  <summary>Behavior</summary>
  <ul>
<li>Plots all lattice points grouped by type.</li>
<li>If <code>plot_connections</code> is True, it draws dashed red lines between nearest neighbors.</li>
</ul>
</details>        <p>Example:
<div class="highlight"><pre><span></span><code><span class="n">lattice</span> <span class="o">=</span> <span class="n">MyLattice</span><span class="p">()</span>
<span class="n">lattice</span><span class="o">.</span><span class="n">generate_points</span><span class="p">()</span>
<span class="n">lattice</span><span class="o">.</span><span class="n">plot_lattice</span><span class="p">(</span><span class="n">plot_connections</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div></p>


<details class="visualization-details" open>
  <summary>Visualization Details</summary>
  <ul>
<li>Lattice points are plotted as small dots.</li>
<li>Nearest neighbor connections (if enabled) are shown as dashed red lines.</li>
</ul>
</details>

            <details class="mkdocstrings-source">
              <summary>Source code in <code>moirepy/layers.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">plot_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_connections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">colours</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the lattice points and optionally the connections between them and the unit cell structure.</span>

<span class="sd">    Args:</span>
<span class="sd">        plot_connections (bool, optional): If True, plots the connections between nearest neighbors.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        colours (list, optional): List of matplotlib colours to use for different point types. </span>

<span class="sd">    Behavior:</span>
<span class="sd">        - Plots all lattice points grouped by type.</span>
<span class="sd">        - If `plot_connections` is True, it draws dashed red lines between nearest neighbors.</span>

<span class="sd">    Example:</span>
<span class="sd">    ```python</span>
<span class="sd">    lattice = MyLattice()</span>
<span class="sd">    lattice.generate_points()</span>
<span class="sd">    lattice.plot_lattice(plot_connections=True)</span>
<span class="sd">    ```</span>

<span class="sd">    Visualization Details:</span>
<span class="sd">        - Lattice points are plotted as small dots.</span>
<span class="sd">        - Nearest neighbor connections (if enabled) are shown as dashed red lines.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colours</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">colours</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="p">)}</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">colours</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice_points</span><span class="p">)}</span>

    <span class="c1"># plt.scatter(</span>
    <span class="c1">#     [self.points[:, 0]],</span>
    <span class="c1">#     [self.points[:, 1]],</span>
    <span class="c1">#     s=10, c=np.vectorize(cols.get)(self.point_types)</span>
    <span class="c1"># )</span>

    <span class="k">if</span> <span class="n">plot_connections</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">this</span><span class="p">,</span> <span class="n">point_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_types</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">delta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbours</span><span class="p">[</span><span class="n">point_type</span><span class="p">]:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">this</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">this</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">this</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;k--&quot;</span><span class="p">)</span>
        <span class="c1"># a = a[:30]</span>
        <span class="c1"># print(a)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="c1"># plt.title(&quot;Lattice Points&quot;)</span>
    <span class="c1"># plt.xlabel(&quot;X Coordinate&quot;)</span>
    <span class="c1"># plt.ylabel(&quot;Y Coordinate&quot;)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>


</div>




  </div>

    </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../theory/avc/" class="btn btn-neutral float-left" title="Angle Value Calculator"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../moire/" class="btn btn-neutral float-right" title="Moire">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/jabed-umar/MoirePy" class="fa fa-code-fork" style="color: #fcfcfc"> jabed-umar/MoirePy</a>
        </span>
    
    
      <span><a href="../../theory/avc/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../moire/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
